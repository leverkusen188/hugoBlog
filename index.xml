<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>https://leverkusen188.github.io/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 22 Nov 2022 12:39:53 +0800</lastBuildDate><atom:link href="https://leverkusen188.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RxSwift迁移Combine指南</title>
      <link>https://leverkusen188.github.io/rxswift/rxswift%E8%BF%81%E7%A7%BBcombine%E6%8C%87%E5%8D%97/</link>
      <pubDate>Tue, 22 Nov 2022 12:39:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/rxswift/rxswift%E8%BF%81%E7%A7%BBcombine%E6%8C%87%E5%8D%97/</guid>
      <description>译自 RxSwift to Combine: The Complete Transition Guide
不逐字翻译了，只翻主要的知识点信息。 简介 Combine 是swift新推出的一种面向 响应式编程的框架。 很多开发者都想从RxSwift 切换到Combine，两者之间有很多的相似之处。 但细节方面还是有很多区别的，如果你想切换过来，这篇文章会列出 RxSwift和Combine之间的 操作符，函数，类型等等的映射。
响应式编程可以让 数据状态在对象之间，工程之间，甚至app之间互相同步。 在ios开发中，最常见的就是在UI和Model之间进行状态同步。在之前很长一段时间里，RxSwift都是最好的选择。但apple推出了 跟SwiftUI 更契合的Combine 作为响应式编程的框架，基本可以完全替代RxSwift的所有功能了。
此文章将分为 Combine是怎么工作的 切换到Combine是好的选择吗 怎么更简单地从RxSwift切换到Combine 三个部分。
Combine是怎么工作的 考虑到本文章是介绍如何从RxSwift迁移到Combine， 假设读者已经对RxSwift有一定的了解了。 如果需要了解RxSwift，可以参考 RxSwift repository on GitHub.
Combine在很多方面跟RxSwift都有相似之处以及对等的映射概念映射，比如 方法，类型声明等。 如果要找出两者之间更深层次的差异，需要对Combine进行更深地挖掘，看看它的底层机制。
Publisher 跟RxSwift的Observable 相对应的是Combine里的Publisher。 在RxSwift里是一个类，而在Combine里是一个协议。
protocol Publisher { associatedtype Output associatedtype Failure: Error func receive&amp;lt;S: Subscriber&amp;gt;(subscriber: S) where Self.Failure == S.Failure, Self.Output == S.Input } Combine 不会指定 Wrapper types来描述它的唯一特征，比如RxSwift里的Infallible, Maybe or Single。 但每个Publisher也有自己的自定义类型，借由该类型，Publisher的特征也能被推导出来。</description>
    </item>
    
    <item>
      <title>2010天涯KK大神预测总结</title>
      <link>https://leverkusen188.github.io/%E9%9D%9E%E6%8A%80%E6%9C%AF/2010%E5%A4%A9%E6%B6%AFkk%E5%A4%A7%E7%A5%9E%E9%A2%84%E6%B5%8B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/%E9%9D%9E%E6%8A%80%E6%9C%AF/2010%E5%A4%A9%E6%B6%AFkk%E5%A4%A7%E7%A5%9E%E9%A2%84%E6%B5%8B%E6%80%BB%E7%BB%93/</guid>
      <description>kkndme_tianya（持续更新中&amp;hellip;）
房产的稀缺性 房产的稀缺性来自于土地的稀缺性，更来自于 该土地周围的相关配套资源的稀缺性，包括生活便利性，交通，教育，医疗等。
zf对土地和房产的垄断 zf垄断土地资源，可以进行几乎无风险的卖地行为，将风险（开发商的资金压力，居民的中长期贷款）甩给开发商和银行。
社会的基本稳定是zf的治理目标 zf只用保证最底层的农民吃饱即可，就能基本保证社会的稳定，底层农民们只关心最基本的生活资源，他们并不关心城市的房产价格如何。而对房产价格极其敏感的所谓中产阶级白领，他们出了呻吟几声外没有任何的其他能量。
维持大量底层劳力是zf的治理目标 zf必须维持大量的底层劳力，几乎不用给予他们上升空间，因为大量的低端人口才能保证精英们的幸福生活，类似于网络游戏里免费玩家是付费玩家的福利一样。
zf通过创造需求来提高土地和房产的稀缺性 zf可以通过各种行为来创造需求，以提高房产的出售数和价格，比如拆迁城中村，把居民赶入城里买房；为某地规划交通和教育医疗资源以提高该地附近的房产价格；对城中村进行改造，提高租赁价格以提高整体租房价格，并对该地人员进行经济筛选，没钱的滚回老家去。</description>
    </item>
    
    <item>
      <title>IOS app性能调优相关知识点</title>
      <link>https://leverkusen188.github.io/iosrelated/ios%E6%80%A7%E8%83%BD/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/iosrelated/ios%E6%80%A7%E8%83%BD/</guid>
      <description>前言 本文较长（5000字左右），建议阅读时间： 20min+
一个iOS App的稳定性，主要决定于整体的系统架构设计，同时也不可忽略编程的细节，正所谓“千里之堤，溃于蚁穴”，一旦考虑不周，看似无关紧要的代码片段可能会带来整体软件系统的崩溃。尤其因为苹果限制了热更新机制，App本身的稳定性及容错性就显的更加重要，之前可以通过发布热补丁的方式解决线上代码问题，现在就需要在提交之前对App开发周期内的各个指标进行实时监测，尽量让问题暴漏在开发阶段，然后及时修复，减少线上出问题的几率。针对一个App的开发周期，它的稳定性指标主要有以下几个环节构成，用一个脑图表示如下：
1 开发过程 开发过程中，主要是通过监控内存使用及泄露，CPU使用率，FPS，启动时间等指标，以及常见的UI的主线程监测，NSAssert断言等，最好能在Debug模式下，实时显示在界面上，针对出现的问题及早解决。
内存问题 内存问题主要包括两个部分，一个是iOS中常见循环引用导致的内存泄露 ，另外就是大量数据加载及使用导致的内存警告。
mmap 虽然苹果并没有明确每个App在运行期间可以使用的内存最大值，但是有开发者进行了实验和统计，一般在占用系统内存超过20%的时候会有内存警告，而超过50%的时候，就很容易Crash了，所以内存使用率还是尽量要少，对于数据量比较大的应用，可以采用分步加载数据的方式，或者采用mmap方式。mmap 是使用逻辑内存对磁盘文件进行映射，中间只是进行映射没有任何拷贝操作，避免了写文件的数据拷贝。 操作内存就相当于在操作文件，避免了内核空间和用户空间的频繁切换。之前在开发输入法的时候 ，词库的加载也是使用mmap方式，可以有效降低App的内存占用率，具体使用可以参考链接第一篇文章。
循环引用 循环引用是iOS开发中经常遇到的问题，尤其对于新手来说是个头疼的问题。循环引用对App有潜在的危害，会使内存消耗过高，性能变差和Crash等，iOS常见的内存主要以下三种情况：
Delegate 代理协议是一个最典型的场景，需要你使用弱引用来避免循环引用。ARC时代，需要将代理声明为weak是一个即好又安全的做法：
@property (nonatomic, weak) id &amp;lt;MyCustomDelegate&amp;gt; delegate; 复制代码 NSTimer NSTimer我们开发中会用到很多，比如下面一段代码
- (void)viewDidLoad { [super viewDidLoad]; self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(doSomeThing) userInfo:nil repeats:YES]; } - (void)doSomeThing { } - (void)dealloc { [self.timer invalidate]; self.timer = nil; } 复制代码 这是典型的循环引用，因为timer会强引用self，而self又持有了timer，所有就造成了循环引用。那有人可能会说，我使用一个weak指针，比如
__weak typeof(self) weakSelf = self; self.mytimer = [NSTimer scheduledTimerWithTimeInterval:1 target:weakSelf selector:@selector(doSomeThing) userInfo:nil repeats:YES]; 复制代码 但是其实并没有用，因为不管是weakSelf还是strongSelf，最终在NSTimer内部都会重新生成一个新的指针指向self，这是一个强引用的指针，结果就会导致循环引用。那怎么解决呢？主要有如下三种方式：</description>
    </item>
    
    <item>
      <title>iOS 与外设通信</title>
      <link>https://leverkusen188.github.io/iosrelated/ios%E4%B8%8E%E5%A4%96%E8%AE%BE%E9%80%9A%E4%BF%A1/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/iosrelated/ios%E4%B8%8E%E5%A4%96%E8%AE%BE%E9%80%9A%E4%BF%A1/</guid>
      <description>蓝牙通讯 PS： _notifyCharacteristicID，_writeCharacteristicID，_externalCharacteristicID 都是跟硬件约定好的对应权限的Characteristic特征的uuid
基本概念 Peripheral、Central：中心和外设，发起连接的是 Central，被连接的设备为 Peripheral；外设设备会不停地向外广播以寻求连接。 在Mimo里，app的角色是 Central，而相机是 Peripheral
Service: 每个service 有唯一的uuid，多个外设可以共用一个service，也就是 扫描指定的uuid的service时，会返回所有使用了该service的 外设（Peripheral） 每个service会有一个或多个 Characteristic（特征），
Characteristic：特征，也是设备之间的数据传输通道，每个特征也有唯一的标识符（uuid）。分为 write，notify， Write类型用以 往外设上发送数据。
工作流程（以Central端为例） 开始扫描使用指定 uuid service的Peripheral 外设 //创建 CBCentralManager _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:_bleWorkQueue options:options]; //扫描指定的多个uuid的service [_centralManager scanForPeripheralsWithServices:_scanServices options:options]; 扫描到Peripheral 信息后，开始连接该外设 - (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&amp;lt;NSString *, id&amp;gt; *)advertisementData RSSI:(NSNumber *)RSSI { //发现外设后，尝试连接 [[DJIBLECentralManager defautManager] connectPeripheral:aPeripheral] } 连接到外设后，在该外设上检索 指定的service，并监听相关回调 - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral { [peripheral setDelegate:self]; [peripheral discoverServices:@[_serviceUUID]]; } 检索到service以后，开始在该service上检索 Characteristic 特征。 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error { for (CBService *aService in peripheral.</description>
    </item>
    
    <item>
      <title>IOS 子工程 源码和二进制库 编译方式切换方案</title>
      <link>https://leverkusen188.github.io/iosrelated/%E6%BA%90%E7%A0%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E5%88%87%E6%8D%A2/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/iosrelated/%E6%BA%90%E7%A0%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E5%88%87%E6%8D%A2/</guid>
      <description>https://www.jianshu.com/p/a6d0f37cdc27 这个主要是用 环境变量控制 podspec 里，是使用源码还是 .a 。最终 pod install 来让主工程切换子模块的 源码和二进制编译方式。
https://juejin.im/entry/5b5308c66fb9a04f932ff87e 这个好一点，需要创建私有pod，在podspec里配置 subspec；然后通过修改 主工程podfile，指定私有pod的 subspec 来切换编译方式。
具体实施：
为需要提供切换功能的工程配好podspec，作为local pods来管理。 pod lib create &amp;ldquo;podname&amp;rdquo;
编写 该工程的 build 脚本，用以将该工程的 framework / .a 以及头文件等输出为二进制，以供切换编译用。 #!/bin/sh #要build的target名 TARGET_NAME=&amp;#39;BottomStatic&amp;#39; CONFIGURATION=&amp;#39;Debug&amp;#39; #${PROJECT_NAME} if [[ $1 ]] then TARGET_NAME=$1 fi UNIVERSAL_OUTPUT_FOLDER=&amp;#34;${SRCROOT}/${PROJECT_NAME}_Products/&amp;#34; UNIVERSAL_OUTPUT_FOLDER=&amp;#34;${TARGET_NAME}_Products/&amp;#34; BUILD_DIR=&amp;#34;Build/&amp;#34; BUILD_ROOT=&amp;#34;Output/&amp;#34; SRCROOT=&amp;#34;.&amp;#34; #创建输出目录，并删除之前的framework文件 mkdir -p &amp;#34;${UNIVERSAL_OUTPUT_FOLDER}&amp;#34; mkdir -p &amp;#34;${BUILD_DIR}&amp;#34; mkdir -p &amp;#34;${BUILD_ROOT}&amp;#34; rm -rf &amp;#34;${UNIVERSAL_OUTPUT_FOLDER}/${TARGET_NAME}.framework&amp;#34; #分别编译模拟器和真机的Framework xcodebuild -target &amp;#34;${TARGET_NAME}&amp;#34; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos BUILD_DIR=&amp;#34;${BUILD_DIR}&amp;#34; BUILD_ROOT=&amp;#34;${BUILD_ROOT}&amp;#34; clean build xcodebuild -target &amp;#34;${TARGET_NAME}&amp;#34; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphonesimulator BUILD_DIR=&amp;#34;${BUILD_DIR}&amp;#34; BUILD_ROOT=&amp;#34;${BUILD_ROOT}&amp;#34; clean build #拷贝framework到univer目录 cp -R &amp;#34;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${TARGET_NAME}.</description>
    </item>
    
    <item>
      <title>IOS 组件化-动态库实战</title>
      <link>https://leverkusen188.github.io/iosrelated/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%8A%A8%E6%80%81%E5%BA%93/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/iosrelated/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%8A%A8%E6%80%81%E5%BA%93/</guid>
      <description>起因
理论功底
动态库和静态库
介绍
静态库和动态库的区别
举个例子， iOS 项目中使用 Embeded Framework
静态库和动态库如何构建和加载
静态库和动态库依赖关系
Xcode 项目结构
iOS 依赖管理事实上的标准
解决问题
制作动态库
剖析下动态库 Framework 吧
回过头来看 Embened Framework
Why Swift does not Support Staic Libraies
CocoaPods 使用 Use_framework!
动态库 Framework 的文件结构
更愉快的导入文件
资源问题
参考
起因
去年，公司iOS端，之前由于所有的业务端代码都是混乱管理，造成开发有很多痛点无法单测，团队成员提交代码冲突机率大，CI配合效果差，功能性代码多端无法复用，单仓库代码量大，编译时间长 等等痛点，领导和组内多次沟通开始着手组件化开发，希望能改进这些开发中的痛点，成立组件化团队。
组件化的方案大同小异，基础性代码封装私有库，业务组件交互交由中间件负责，项目依赖工具用iOS项目事实上的标准CocoaPods
前期的基础性组件拆分都较为顺利，从依赖树的叶子节点开发是最合适的方案。
随着组件抽离的越来越多，私有库的依赖体系也越来越复杂，慢慢过渡到了业务组件。业务组件用了Swift的第三方组件，用了Swift库的同学都知道必须加上use_frameworks!，这个标记是说Pod管理的依赖全部编译为动态库，然后呢我们的很多组件又依赖了诸如百度地图，微信分享等静态库，于是我在执行 pod install 报了一个没有碰见过的错误。
1[!] The &amp;lsquo;Pods-LJA_Example&amp;rsquo;target has transitive dependencies that include static binaries:
这就尴尬了，于是一阵疯狂的搜索google stackoverflow等，然而并没有什么卵用，而且上面催得急，根本没时间处理这些小问题 业务重构是最主要的，以至于我们的业务组件没有做到独立仓库拆分。
直到最近终于找到了解决办法:( 主要是自己的功力不够深厚）
理论功底
动态库和静态库
介绍
首先静态库和动态库都是以二进制提供代码复用的代码库
静态库 常见的是 .</description>
    </item>
    
    <item>
      <title>JS 使用原生UI组件</title>
      <link>https://leverkusen188.github.io/reactnative/js_native_ui/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/reactnative/js_native_ui/</guid>
      <description>使用原生UIView Native端： 首先创建一个RCTViewManager的子类。 @interface NativeView : RCTViewManager @end
添加RCT_EXPORT_MODULE()宏标记导出的模块名称 RCT_EXPORT_MODULE(MyNativeView)
实现-(UIView *)view方法，返回对应的native视图给JS
- (UITextField*)view { UITextField * field = [UITextField new]; field.text = @&amp;#34;BBBB&amp;#34;; field.textColor = [UIColor blueColor]; field.textAlignment = UITextAlignmentCenter; return field; } JS端： 用一个js文件来导入模块。 NativeView.js import { requireNativeComponent } from &amp;#39;react-native&amp;#39;; // requireNativeComponent 自动把&amp;#39;RNTMap&amp;#39;解析为&amp;#39;RNTMapManager&amp;#39; export default requireNativeComponent(&amp;#39;MyNativeView&amp;#39;); 然后在其他js里使用即可。 import NativeView from &amp;#39;./MyNativeView&amp;#39; &amp;lt;NativeView style={{width:150, height:50, backgroundColor:&amp;#34;green&amp;#34;}}&amp;gt; &amp;lt;/NativeView&amp;gt; 封装原生属性 可以将view 方法里返回的视图的属性封装并供给JS端来设置.
以上面代码为例，Native 端：
RCT_EXPORT_VIEW_PROPERTY(userInteractionEnabled, BOOL) JS端：
&amp;lt;NativeView style={{width:150, height:50, backgroundColor:&amp;#34;green&amp;#34;}} userInteractionEnabled={false}&amp;gt; &amp;lt;/NativeView&amp;gt; 那么view返回的UITextField 将无法接收点击等操作。</description>
    </item>
    
    <item>
      <title>python基础环境搭建</title>
      <link>https://leverkusen188.github.io/python/python%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/python/python%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>虚拟环境： 主要是创建一个虚拟的 python 环境，相关的第三方package会独立放在指定的目录下。 但python相关的bin文件，都是从正式环境 景象过来的。 参考：https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/
安装虚拟环境： On macOS and Linux:
python3 -m pip install --user virtualenv On Windows:
py -m pip install --user virtualenv 创建虚拟环境： On macOS and Linux:
python3 -m venv env_name On Windows:
py -m venv env_name 进入/退出 虚拟环境： On macOS and Linux:
source env/bin/activate On Windows:
.\env\Scripts\activate 退出 deactivate 关于python package安装包 参考： https://python-packaging.readthedocs.io/en/latest/minimal.html
package文件结构和组成 用pip install安装的包，在根目录下需要有个 setup.py 文件，里面配置了 这个package的相关信息（类似cocoapods的 podspec 文件） from setuptools import setup setup(name=&amp;#39;requests1&amp;#39;, version=&amp;#39;0.</description>
    </item>
    
    <item>
      <title>React Native 优化相关</title>
      <link>https://leverkusen188.github.io/reactnative/rn_optimization/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/reactnative/rn_optimization/</guid>
      <description>JS加载 在 react-native 执行 JS 代码之前，必须将代码加载到内存中并进行解析。如果你加载了一个 50MB 的 bundle，那么所有的 50mb 都必须被加载和解析才能被执行。RAM 格式的 bundle 则对此进行了优化，即启动时只加载 50MB 中实际需要的部分，之后再逐渐按需加载更多的包。
使用内联引用，可以实现懒加载，降低启动时间。
直接加载的样例代码：
import ModalApp from &amp;#39;./MyJS/Modal&amp;#39;; AppRegistry.registerComponent(&amp;#34;ModalApp&amp;#34;, () =&amp;gt; ModalApp); 内联引用加载:
let m = require(&amp;#39;./MyJS/Modal&amp;#39;).default AppRegistry.registerComponent(&amp;#34;ModalApp&amp;#34;, () =&amp;gt; m); </description>
    </item>
    
    <item>
      <title>React Native 的JS与Oc 通信</title>
      <link>https://leverkusen188.github.io/reactnative/js_native_communication/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/reactnative/js_native_communication/</guid>
      <description>JS 调用 OC 创建一个OC类，实现 RCTBridgeModule 协议。 H 头文件 #import &amp;lt;React/RCTBridgeModule.h&amp;gt; @interface TestObjectForJS : NSObject&amp;lt;RCTBridgeModule&amp;gt; @end M 文件 #import &amp;lt;React/RCTLog.h&amp;gt; @implementation TestObjectForJS RCT_EXPORT_MODULE(TestObject); //声明导出的模块名 //声明并实现导出的方法（实际上是类方法） RCT_EXPORT_METHOD(testFunc:(NSString *)first location:(NSString *)second) { NSString *output = [first stringByAppendingString:second]; RCTLogInfo(@&amp;#34;Pretending to create an event: %@&amp;#34;, output); } @end 在JS中调用即可。 import { NativeModules } from &amp;#39;react-native&amp;#39;; NativeModules.TestObject.testFunc(&amp;#39;11&amp;#39;, &amp;#39;22&amp;#39;) OC 给JS调用的方法支持的参数类型 RCT_EXPORT_METHOD 支持所有标准 JSON 类型，包括：
string (NSString) number (NSInteger, float, double, CGFloat, NSNumber) boolean (BOOL, NSNumber) array (NSArray) 可包含本列表中任意类型 object (NSDictionary) 可包含 string 类型的键和本列表中任意类型的值 function (RCTResponseSenderBlock) RCTConvert 声明的也都可以支持 以NSDate 为例： JS端, 可以传递 Date 的 getTime() (时间戳) const date = new Date(&amp;#39;1995-12-17T03:24:00&amp;#39;); NativeModules.</description>
    </item>
    
    <item>
      <title>RxFeedback 学习</title>
      <link>https://leverkusen188.github.io/rxswift/rxfeedback/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/rxswift/rxfeedback/</guid>
      <description>核心功能：自定义Event的触发事件集合，以及订阅该事件触发后会修改的一个状态集对象的Observable。同时自定义 在事件触发后，对状态集对象进行数据变更。
样例代码：
//在下面代码中，状态集对象就是Int typealias State = Int //自定义事件是 增加和减少 enum Event { case increment case decrement } Observable.system( initialState: 0,	//声明状态集对象的初始化值 //reduce里，是接收到 event事件后，对状态集对象进行自定义处理的代码。然后将新的状态集对象返回。 STEP 2 reduce: { (state, event) -&amp;gt; State in switch event { case .increment: return state + 1 case .decrement: return state - 1 } }, scheduler: MainScheduler.instance, feedback: //bind 传入owner对象，作为 第二个closure的首个参数返回。 //第二个closure参数作用是 自定义Event的触发时机，以及 对状态集对象Observable的订阅操作 //state就是一个 状态集对象的Observable，即 ObservableSchedulerContext&amp;lt;State&amp;gt; bind(self) { me, state -&amp;gt; Bindings&amp;lt;Event&amp;gt; in //对状态集对象Observable的订阅集合 let subscriptions = [ state.</description>
    </item>
    
    <item>
      <title>RxSwift 的Subject</title>
      <link>https://leverkusen188.github.io/rxswift/rxswift_subject/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/rxswift/rxswift_subject/</guid>
      <description>ReplaySubject ReplaySubject 在创建时候需要设置一个 bufferSize，表示它对于它发送过的 event 的缓存个数。 比如一个 ReplaySubject 的 bufferSize 设置为 2，它发出了 3 个 .next 的 event，那么它会将后两个（最近的两个）event 给缓存起来。此时如果有一个 subscriber 订阅了这个 ReplaySubject，那么这个 subscriber 就会立即收到前面缓存的两个.next 的 event。 如果一个 subscriber 订阅已经结束的 ReplaySubject，除了会收到缓存的 .next 的 event外，还会收到那个终结的 .error 或者 .complete 的event。 样例代码：
let subject = ReplaySubject&amp;lt;String&amp;gt;.create(bufferSize: 2) subject.onNext(“1”) subject.onNext(“2”) subject.onNext(“3”) //第一次订阅，会收到 2 和 3 事件 subject.subscribe(onNext: { (event) in print(event) }, onError: { (error) in print(error) }, onCompleted: { print(&amp;#34;这是一个 完成&amp;#34;) }) { print(&amp;#34;销毁了&amp;#34;) }.disposed(by: bag) subject.</description>
    </item>
    
    <item>
      <title>RxSwift 笔记</title>
      <link>https://leverkusen188.github.io/rxswift/rxswift_note/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/rxswift/rxswift_note/</guid>
      <description>响应机制 响应机制核心是 Observable 和 ObserverType. 前者用来发送事件，使用者可以订阅（subscribe）后，监听 onNext ，onError等事件。 样例代码：
let switch = UISwitch! = UISwitch.init(frame: CGRect(x: 0, y: 50, width: 100, height: 40)) Let swiOnEvent = switch.rx.isOn swiOnEvent.subscribe(onNext: { booValue in print(“isOn=\(booValue)&amp;#34;) }, onError: { i in }) Observable 转换 Observable 的 map 可以在监听到onNext 事件后，将当前Observable的 element 换成自定义的其他类型，并返回一个对应泛型的Observable。 样例代码：
let switch = UISwitch! = UISwitch.init(frame: CGRect(x: 0, y: 50, width: 100, height: 40)) Let swiOnEvent = switch.rx.isOn swiOnEvent.map{ isOn in //isOn 是swiOnEvent的泛型类型，也就是 Bool return 12 //换成Int了 }.</description>
    </item>
    
    <item>
      <title>RxSwift 高阶函数用法</title>
      <link>https://leverkusen188.github.io/rxswift/rxswift_advanced_function/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/rxswift/rxswift_advanced_function/</guid>
      <description>distinctUntilChanged(). 是ObservableType的扩展方法，当 ObservableType 的Element 必须是遵循Equatable 协议的类型。 该函数返回一个ObservableType，只有Element的值发生变化时，才会抛出onNext事件。 例如 Observable.of(1,2,1,3,5,4).distinctUntilChanged() , 会抛出 1,2,1,3,5,4 而 Observable.of(1,1,3,5,4).distinctUntilChanged() , 会抛出 1,3,5,4
element(at:) 只通知 指定index的Element 的onNext事件
ignoreElements() 忽略onNext事件，只抛出 onError 和 completed事件
take(count) 只抛出序列中指定count数的事件，满足count 数后，直接抛出 completed
takeLast(count) 只抛出序列中最后的指定count数的事件。满足count 数后，直接抛出 completed
PS: 注意take系列，如果是未指定个数的事件序列，则takeLast是不生效的。
skip(count)： 跳过指定个数的事件。
delaySubscription() 在指定的时间内，无法获取到序列事件，到时间后，就能获取到事件了。
delay() 将所有信号事件 delay 指定时间后再发送。订阅者获取到的事件都是延迟后的。
PS：但对于指定个数序列事件的ObservableType，两者行为是一致的，都会延迟 指定时间后，订阅者才收到消息
debounce() 指定信号之间间隔未达到指定时差时，就会忽略前面的事件，只抛出最后一个事件。
groupBy() 可以将指定的Observable 分割成多个 字定义key的Observable。 样例代码（根据自定义的 keySelector，将 1-6的序列化的Observable 分组成 两个GroupedObservable，它们的key 就是自定义的 “奇数”和“偶数”）：
Observable.of(1,2,3,4,5,6).groupBy(keySelector: { (ele) -&amp;gt; String in return ele % 2 == 1 ?</description>
    </item>
    
    <item>
      <title>SDK 开发规范 &amp; 经验总结</title>
      <link>https://leverkusen188.github.io/iosrelated/sdk%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/iosrelated/sdk%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</guid>
      <description>开发规范 1. 开发规范 API功能单一，减少类似enum的入参设计 线程处理， 如非必要不要使用应用主线程，不能长时间占用，SDK内应有一个专门线程处理SDK 相关操作 尽量减少全局回调 提供异常情况回调和输出方便接入方定位，错误回调采用code+msg组合 能不用单例的就尽量少的使用 对iOS 来说能不用xib 就不用，能不用通知就不用通知 2. 命名规范 接口名称，参数命名清晰规范，参数尽可能少，所有传入参数要做好校验，禁止使用拼音和中文 类名，全局静态变量，宏等命名尽量使用自定义前缀来保证唯一性，避免与其他模块发生命名冲突。c++ 可以使用namespace来声明类和结构的模块层级，还能避免命名冲突。 函数命名遵循共性，不要出现歧义或者违背大家的共识 所有资源命名前缀：imageName_工程命名_平台名：toast_xxxSDK_iOS 3. 日志设计 log模块相关功能可配置（比如日志开关，日志文件输出目录，日志打印接管接口） log优先级分不同级别，可控制打印log级别 4. 第三方库依赖处理原则 最小可用性原则，即用最少的代码，如无必要勿增实体； 最少依赖性原则，即用最低限度的外部依赖，如无必要勿增依赖 SDK开发中，需要尽量避免依赖第三方库以免引起不必要的冲突；如实在需要，可以以源码形式引入稳定版本，并对类，结构，全局变量等添加前缀以避免外部使用到该第三方库时产生冲突。 5. 版本管理规范 使用三位版本号，每位版本号最高三位数字如：1.0.12
版本号递增原则： 第三位：bug修复，极小的变更 第二位：一般的功能迭代 第一位：项目重构，功能变更较大，需团队共同确定 6. 打包原则 使用脚本一键打包，提升打包效率，降低手动打包带来的出错率 要提供示例工程， 示例工程必须让开发者以最低的成本运行起来，可以用来验证主要功能接口 以及 SDK的接入方式。 经验 &amp;amp; 问题总结 业务型SDK里，当业务形态发生变化后，之前的接口参数无法满足需求，该如何处理？
添加新的接口，老接口标识为 该版本弃用，在SDK迭代数个版本后删除。 如何设计log的tag，才便于跟踪某个业务场景下产生的问题？</description>
    </item>
    
    <item>
      <title>String 自定义格式化</title>
      <link>https://leverkusen188.github.io/swift/string_custom_format/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/string_custom_format/</guid>
      <description>比如一个自定义结构，在打印时，print 会按照 Swift struct 的默认格式打印 Person 值
struct Person { let name: String let place: String } print(&amp;#34;Hi, \(Person(name: &amp;#34;Geralt&amp;#34;, place: &amp;#34;Rivia&amp;#34;))&amp;#34;) 如果要自定义Person的打印结果，可以 扩展String.StringInterpolation，样例代码：
extension String.StringInterpolation { mutating func appendInterpolation(_ person: Person) { // 调用的 `appendLiteral(_ literal: String)` 接受 `String` 参数 appendLiteral(&amp;#34;\(person.name) of \(person.place)&amp;#34;) } } 这样，打印出来的Person会变成
print(&amp;#34;Hi, \(Person(name: &amp;#34;Geralt&amp;#34;, place: &amp;#34;Rivia&amp;#34;))&amp;#34;) Hi, Geralt of Rivia</description>
    </item>
    
    <item>
      <title>Stub 和 Mock</title>
      <link>https://leverkusen188.github.io/xctest/stub_mock/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/xctest/stub_mock/</guid>
      <description>Stub 用在修改 测试代码里出现无法预期其行为（比如返回数据）的相关函数时，将该函数的返回值用插桩方式修改为自定义的数据（修改方式可自定义，比如 在输入参数为多少时，才返回对应的字定义数据），以满足整块代码的单测需要。
下面是例子说明 (stub 实现基于 Kiwi 框架 https://github.com/kiwi-bdd/Kiwi)：
功能是接收温度和湿度参数，通过weatherForecaster 的方法计算出对应的结果，并存入数据库。
假设 resultWithTemprature 方法是无法被测试的，那么整块代码里，可以测试的是 写入数据库的代码（write函数）
@class WeatherRecorder -(void) writeResultToDatabaseWithTemprature:(NSInteger)temprature humidity:(NSInteger)humidity { id result = [self.weatherForecaster resultWithTemprature:temprature humidity:humidity]; [self write:result]; } 为了不影响单测用例，可以改写 resultWithTemprature 的行为，返回自定义的 result，来测试数据库写入代码。
[weatherForecaster stub:@selector(resultWithTemprature:humidity:) andReturn:someResult withArguments:theValue(23),theValue(50)]; mock 其实就是一个对象，它是对现有类的行为一种模拟（或是对现有接口实现的模拟），它是一种更全面更智能的 Stub。
以上面代码为例，在OC里，实际上就是将 weatherForecaster 换为自定义的mock类，从而使 resultWithTemprature 函数的行为是我们测试需要的。
样例代码：
创建 weatherForecaster 的 mock实例 id weatherForecasterMock **=** [WeatherForecaster **mock**]; [[weatherForecasterMock **should**] **receive**:**@selector**(**resultWithTemprature**:humidity**:**) andReturn**:**someResult withArguments**:**theValue(23),theValue(50)]; 然后将WeatherRecorder的 weatherForecaster 属性替换为该mock实例 [weatherRecorder stub:@selector(weatherForecaster) andReturn:weatherForecasterMock]; </description>
    </item>
    
    <item>
      <title>Swift 5.7 note</title>
      <link>https://leverkusen188.github.io/swift/swift5.7_note/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/swift5.7_note/</guid>
      <description>译自 Swift 5.7: Optional Binding, Closure Type Inference, Clock, Noasync
什么是Swift Apple 的swift是一种运行在 iOS，MacOS，WatchOS，TvOS以及 linux上的编程语言。
Swift是一种可编译的跑在apple相关产品设备以及电脑的类linux系统上的语言。这些系统上的应用可以使用c，c++，ObjectiveC等语言和swift 混合开发编译运行。
我们啥时可以开始使用swift 5.7？ 根据最新消息，5.7 将于xcode14 以及 iOS SDK16 开始使用。
根据最新消息，swift将有哪些新的变化？ 根据介绍，最主要的让开发者们的工作变得更轻松的点有，增强和简化了最常用的开发工具比如 binding optional语法；还有一些常用的表达式语法以及常用语法。
速记：隐藏一个现有的optional变量 什么是optional变量？
optional变量在swift里可以赋予一个有效的值或对象或是一个空指针。
作为一个iOS的swift开发者，在编码时要经常使用到optional变量，它可以决定变量/容器是否可以赋值/包含 nil。
在编码时检查一个变量是否有值是跟呼吸一样频繁的事。
尽管使用起来已经够简单了，但每次都要把很长的变量名重写一遍还是比较麻烦。swift5.7 就在这方面很好地改进了相关语法。
之前的swift let colleageName : String? = &amp;#34;John&amp;#34; if let colleageName = colleageName { print(colleageName) } 有时变量名过长时，每次重写就有点繁琐，或者有时候超过了一行的字数限制。
下面的代码就显得特别冗长而且可读性较差
let colleageNameiohfahiefhaohgho : String? = &amp;#34;John&amp;#34; let colleageNameiohfahiefhaohgho2 : String? = &amp;#34;Bill&amp;#34; if let colleageNameiohfahiefhaohgho = colleageNameiohfahiefhaohgho, let colleageNameiohfahiefhaohgho2 = colleageNameiohfahiefhaohgho2 { print(&amp;#34;\(colleageNameiohfahiefhaohgho) \(colleageNameiohfahiefhaohgho2)&amp;#34;) } 而且这会导致变量命名趋向于简短且描述性差。</description>
    </item>
    
    <item>
      <title>Swift 5.7 note (Pointer 功能加强)</title>
      <link>https://leverkusen188.github.io/swift/swift5.7_note_unsafepointer/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/swift5.7_note_unsafepointer/</guid>
      <description>译自 Swift 5.7: Pointer API Usability Improvements
简介 这篇文章介绍了UnsafePointer 以及它的 Mutable 和 Raw 变种的强大且实用的改进细节。
新增了一个可以获取 指定alignment（位移）的UnsafePointer 指针的接口。 新增了一个可以获取给定 UnsafePointer&amp;lt;T&amp;gt; 里，T的指定属性指针的接口。 可以compare 两个不同类型的指针了。 起因(To Be Continued) 每次我们实用 UnsafePointer 以及它的扩展变种时，都会碰到很多跟这些类型的不安全性无关的困难和麻烦。在不用隐藏这些不安全性的基础上，我们也可以改进这些类型的工作效率。
举个例子，如果你想要</description>
    </item>
    
    <item>
      <title>Swift dynamicMemberLookup</title>
      <link>https://leverkusen188.github.io/swift/swift_dynamicmemberlookup/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/swift_dynamicmemberlookup/</guid>
      <description>类或是struct声明为 @dynamicMemberLookup 后，并实现 subscript(dynamicMember:), 就可以用带 点的语法来访问对应的数据了。
实现dynamicMemberLookup 的类： @dynamicMemberLookup class TestData&amp;lt;Value&amp;gt; { var value : Value var name : String init(_ v : Value, name : String) { self.value = v self.name = name } //subscript(dynamicMember:) 只能用 String 或 KeyPath 作为参数 subscript(dynamicMember pro : String) -&amp;gt; Bool { return true } subscript&amp;lt;T&amp;gt;(dynamicMember key : KeyPath&amp;lt;Value, T&amp;gt;) -&amp;gt; T { value[keyPath: key] } } 使用方法 //使用带点语法访问数据时有优先级 let data = TestData(&amp;#34;b&amp;#34;, name: &amp;#34;haha”) //Value 泛型推导为 “b”的类型，也就是String //优先级1: 访问已有的属性，比如 TestData 的name属性。 let name = data.</description>
    </item>
    
    <item>
      <title>Swift Keypath</title>
      <link>https://leverkusen188.github.io/swift/swift-keypath/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/swift-keypath/</guid>
      <description>译自 The power of key path in Swift
Swift 最初的设计就专注于编译期尽量保证程序运行安全 以及 静态类型匹配，因此它比较缺乏类似 OC，Javascript 和ruby等运行时语言的动态特性。比如，在OC里，我们可以在运行时动态访问类对象的属性和方法，甚至改变方法的实现。
但这些动态特性的缺乏正表现出Swift的伟大，它能保证我们写出的程序运行结果更加可预料，且更可能运行不出错。不过有时候我们的代码能拥有一些动态特性也是很有帮助的。
谢天谢地，随着版本更新，Swift 开始拥有更多的动态特性，但却依然保持着静态安全类型特性。其中一种新特性就是KeyPath。本周，我们一起来看看KeyPath在Swift中是如何运作的，以及我们能用它来实现哪些强大的功能。
基础 KeyPath 本质上让我们可以用一个值来引用任意对象的特定属性。像这样，它可以被到处传递引用，在表达式中使用，甚至可以在不用知道它是哪个类的属性时，对它进行set 和get 操作。
KeyPath一般有三种类型：
KeyPath：提供只读的属性访问 WritableKeyPath: 通过特定语法，提供某个对象的可变更属性的读写权限。（该对象必须是可修改的） ReferenceWritableKeyPath: 只能对可引用的类型使用，比如类的对象实例。同上，提供该对象的某个可修改的属性的读写权限。 还有一些其他的keyPath类型，用来减少代码重复性，同时移除类型限制。不过我们暂时只关注主要的这几个类型。
让我们来看看如何使用KeyPath，以及为什么它这么有趣又功能强大。
功能速记 比如说我们要开发一个 让用户可以从各种Web上阅读文章的App，可以设计一个Article 数据模型来表示一篇文章，像这样：
struct Article { let id: UUID let source: URL let title: String let body: String } 当我们使用这种数据模型的数组时，经常需要从类里摘取单一属性出来重新生成一个新的数据数组。比如下面的例子，我们将所有id 和source数据拿出来生成新的数据数组。
let articleIDs = articles.map { $0.id } let articleSources = articles.map { $0.source } 当我们只需要使用到一个属性数据时，上面的代码是ok的。但其实我们不需要使用到闭包的所有功能，这时候使用keypath 就是比较合适的选择了。
我们可以重载Sequence 的map 方法，让它使用一个keypath来替代之前的闭包作为参数。在这个例子里，我们只对只读属性数据感兴趣，因此使用KeyPath 类型即可。使用传入的KeyPath 来生成数据返回，就像下面这样：</description>
    </item>
    
    <item>
      <title>Swift 与 OC的互相使用tips</title>
      <link>https://leverkusen188.github.io/swift/swift_oc_communicate/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/swift_oc_communicate/</guid>
      <description>Swift要使用OC代码 Case1 : 如果是主工程里，则需要将对应的OC头文件放入 生成的 &amp;ldquo;-Bridging-Header.h&amp;rdquo; 头文件里。 Case2: 如果是子工程，必须将OC对应的头文件设为Public；再将该头文件放入modular header里来import。 Swift使用OC的 枚举。（不同的声明方式对应不同的使用方式） **Case1: **
typedef enum : NSUInteger { XXXX1, } XXXX; 在swift中： let vv : XXXX = XXXX1 Case2:
typedef NS_ENUM(NSUInteger, JapaneseFoodType1) { JapaneseFoodType1_Sushi = 1, JapaneseFoodType1_Tempura = 2, }; 在swift中： let v : JapaneseFoodType1 = .sushi PS：也都可以用 init(rawValue:) 来使用，但不推荐。
Swift 使用OC的指针 Swift 端的指针类型有： UnsafePointer: 类似于const Pointee * UnsafeMutablePointer: 类似于Pointee * UnsafeRawPointer: 类似于const void * UnsafeMutableRawPointer: 类似于void * //OC传指针给Swift //Swift端 @objc class SwiftClosure : NSObject { @objc class func test1(_ ptr: UnsafeMutablePointer&amp;lt;Int&amp;gt;) { ptr.</description>
    </item>
    
    <item>
      <title>Swift 函数和闭包</title>
      <link>https://leverkusen188.github.io/swift/swift_function_closure/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/swift_function_closure/</guid>
      <description>可变参数 可以设定同类型的参数为可变个数，然后在函数里将该参数作为数组来使用。 可变参数的位置不一定是最后一个。
示例代码：
func manyVar(v : Int..., d : Double) { for i in v {	//作为数组使用 } } manyVar( d: 2.2) //传 0 个v参数 manyVar(v:1,2,3, d: 2.2) //传3个 v参数 闭包 和 函数 对外部变量的引用 Block 和 函数在使用它们外部的变量时，使用的是该变量的引用（无论是基本类型还是 类结构），当变量变化时，block和函数内部的该变量也会一起变化。
代码例子：
var bInt : Int = 4 func capture(_ num : Int) -&amp;gt; String { bInt += num return &amp;#34;caturpe \(bInt)&amp;#34; } bInt += 1 print(&amp;#34;capture \(capture(1))”) //打印 capture 6 print(&amp;#34;capture \(capture(2))”) //打印 capture 7, 此时 bInt 变成7了 尾随闭包 当闭包作为函数最后一个参数时，可以将闭包体放在函数的括号外面，这是一个语法糖。</description>
    </item>
    
    <item>
      <title>Swift 字面量协议和模式匹配</title>
      <link>https://leverkusen188.github.io/swift/swift_pattern_match/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/swift_pattern_match/</guid>
      <description>字面量协议(Literal Type) 字面量(Literal Type)就是基本类型的常量值。 比如： 10、false、&amp;ldquo;Jack&amp;quot;就是字面量
var age = 10 var isRed = false var name = &amp;#34;Jack&amp;#34; 而如果类实现了对应的字面量协议后，就可以用字面量来初始化对象了。 常用的字面量协议有：
Bool: ExpressibleByBooleanLiteral Int: ExpressibleByIntegerLiteral Float、Double: ExpressibleByIntegerLiteral、ExpressibleByFloatLiteral String: ExpressibleByStringLiteral Array、Set: ExpressibleByArrayLiteral Dictionary: ExpressibleByDictionaryLiteral Optional: ExpressibleByNilLiteral 样例代码：
class LiteralTypeClass : ExpressibleByBooleanLiteral { var boolValue : Bool //实现了bool的字面量协议，可以用bool来初始化了 required init(booleanLiteral value: BooleanLiteralType) { boolValue = value } } let obj : LiteralTypeClass = false 模式匹配 模式是用于匹配的规则，比如switch的case、捕捉错误的catch、if\guard\while\for语句的条件等。
1. 通配符模式（Wildcard Pattern） 1.1 _ 匹配任何值 1.2 _?</description>
    </item>
    
    <item>
      <title>Swift 常用UI界面设置</title>
      <link>https://leverkusen188.github.io/swiftui/swiftui_pandding/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swiftui/swiftui_pandding/</guid>
      <description>背景色设置 一个指定颜色的空视图。 color.red.ignoresSafeArea() 给一个或多个视图指定背景颜色 Color.green.overlay { //用 overlay作为背景的 多个重叠的视图 Text(&amp;#34;hello&amp;#34;).bold().foregroundColor(.white) }.frame(width: 50, height: 50) 控件位置设置 HStack 和 VStack 初始化时都有spacing参数来设定 它们里面的控件的间距。
控件的offset 属性可以设置该控件相比原布局位置的位移。
但注意其他控件并不会因为它的位置变化而自动布局（也就是 如果下面的控件不设offset时，可能会跟它重叠，比如下面这样：） padding 填充设置
func padding( _ edges: Edge.Set = .all, _ length: CGFloat? = nil ) -&amp;gt; some View 往指定的Edge 填充指定(Length) 大小的空间。edges 可以是多个。 样例代码：
//往控件的底部和右边尾部 填充20像素宽度空间 Text(&amp;#34;Text padded by 20 points on the bottom and trailing edges.&amp;#34;) .padding([.bottom, .trailing], 20) .border(.gray) </description>
    </item>
    
    <item>
      <title>Swift 数组和字典</title>
      <link>https://leverkusen188.github.io/swift/swift_array_dictionary/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/swift_array_dictionary/</guid>
      <description>数组和字典的遍历(enumerated) 数组和字典的遍历有两种方式。
方式1: let arr = [1,2,3] for v in arr.enumerated() { v.offset //就是下标序号 v.element //就是当前元素 } let dict = [1: “first”, 2: “second”] for v in dict.enumerated() { v.offset //就是序号 v.element //类型是 [Int: String].Element, 有key 和value属性； } 方式2: for (index, value) in arr.enumerated() { //index 是下标，value是元素 } for (index, value) in arr.enumerated() { //index 是下标，value是 [Int: String].Element } 用数组里的对象的属性贵族归组 快速创建字典 样例代码：
struct Data { var i : Int var text : String } //dic 会用 Data的 i 属性来作为key生成。 let dic = Dictionary(grouping: [ Data999(i: 1, text: &amp;#34;haha&amp;#34;), Data999(i: 1, text: &amp;#34;baa&amp;#34;), Data999(i: 4, text: &amp;#34;abnn&amp;#34;), Data999(i: 4, text: &amp;#34;erwr&amp;#34;), Data999(i: 6, text: &amp;#34;babr&amp;#34;), ], by: { $0.</description>
    </item>
    
    <item>
      <title>Swift 类和结构</title>
      <link>https://leverkusen188.github.io/swift/swift_class_structure/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/swift_class_structure/</guid>
      <description>结构的mutating 函数 结构体中，除了init 函数外，其他函数中如果有修改自身属性，必须声明为 mutating
struct s { var str : String = &amp;#34;&amp;#34; mutating func(s1 : String) { self.str = s1 } } 类方法和 Static 方法 类方法和static方法都是通过 类名(结构名) 直接调用的方法。 但 类方法可以被子类重写，而static 不行.
class EqualClass { class func canOverride() { print(&amp;#34;EqualClass canOverride&amp;#34;) } static func cannotOverride() { print(&amp;#34;EqualClass cannotOverride&amp;#34;) } } class SubEqualClass : EqualClass { override class func canOverride() { print(&amp;#34;SubEqualClass canOverride&amp;#34;) } //下面代码无法编译 override static func cannotOverride() { print(&amp;#34;SubEqualClass cannotOverride&amp;#34;) } } 下标脚本（subscript） 在类，结构或是枚举 声明中，可以定义下标脚本，通过一个或多个索引来访问实例里的数据。</description>
    </item>
    
    <item>
      <title>Swift 访问控制等级</title>
      <link>https://leverkusen188.github.io/swift/swift_privilege/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/swift_privilege/</guid>
      <description>Top open: 允许在定义实体的模块、其他模块中访问，允许其他模块进行继承、重写（open只能用在类、类成员上） public: 允许在定义实体的模块、其他模块中访问，不允许其他模块进行继承、重写 internal: 只允许在定义实体的模块中访问，不允许在其他模块中访问 fileprivate: 只允许在定义实体的源文件中访问 private： 只允许在定义实体的封闭声明中访问 绝大部分实体默认都是internal级别
准则1: 低等级的定义不能被高等级的定义包含，并暴露出去 //fileprivate 等级的类 fileprivate class Person {} public var p : Person //❌ public class Jason : Person {} //❌ fileprivate class John : Person {} //正确 准则2: 泛型使用场景中，应该以最低访问等级的那个类型为准。 internal class Car {} fileprivate class Dog {} //最低等级 public class Person&amp;lt;T1, T2&amp;gt; {} fileprivate var p = Person&amp;lt;Car, Dog&amp;gt;() //以最低等级为准，该变量必须设定为 fileprivate 准则3: 类型的等级会影响它的函数，变量等访问等级。 fileprivate class Person { var age : Int //也是fileprivate } 准则4: 源码文件最外面的private等同于 fileprivate。 //文件最外层的 private Dog结构，等同于fileprivate等级。 private struct Dog { private var age: Int = 0 //但它的属性和函数都是 private，只能在 Dog结构声明里使用。 func run() {} //跟随 Dog的等级，都是fileprivate } fileprivate struct Person { var dog: Dog = Dog() mutating func walk() { dog.</description>
    </item>
    
    <item>
      <title>Swift 运算符重载</title>
      <link>https://leverkusen188.github.io/swift/swift_operator_override/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/swift_operator_override/</guid>
      <description>加减乘除重载 在对应的结构，类，枚举里重写即可。
struct Point { var x: Int, y: Int static func + (p1: Point, p2: Point) -&amp;gt; Point { Point(x: p1.x + p2.x, y: p1.y + p2.y) } } Equatable，Comparable Equatable 设定对象可以比较是否相等。重写 == 运算符。 Comparable 设定对象可以比较大小。重写 &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;= 等运算符。
自定义运算符（Custom Operator） 可以自定义新的运算符：在全局作用域使用operator进行声明。
prefix operator 前缀运算符 postfix operator 后缀运算符
//前后运算符，自定义 +++ 为整型加2 prefix operator +++ postfix operator ++- prefix func +++ (_ i: inout Int) { i += 2 } postfix func ++- (_ i: inout Int) { i -= 2 } var age = 10 +++age print(age) // 12 age++- print(age) // 10 //中缀运算符，也就是放置在两个变量中间的运算符，可以定义它的运算优先级 infix operator 中缀运算符：优先级组 precedencegroup 优先级组 { associativity: 结合性（left\right\none） higherThan: 比谁的优先级更高 lowerThan: 比谁的优先级低 assignment: true代表在可选链操作中拥有跟赋值运算符一样的优先级 } 样例代码：</description>
    </item>
    
    <item>
      <title>SwiftUI UI刷新细节</title>
      <link>https://leverkusen188.github.io/swiftui/swiftui_ui_refresh/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swiftui/swiftui_ui_refresh/</guid>
      <description>SwiftUI 的View 每次刷新都会重新创建里面的View //每次text改变引起的刷新，都会重新创建一个Text @State var text : String var body : some View { Text(text) } Body 中的ForEach 重用 Body中的ForEach 每次刷新并不会重建。 因此下面的例子里，即使多次刷新View，但ForEach对象还是最初那个，循环的次数也不会随着 increasingValue 增加而改变。
var increasingValue : Int = 1 func testLoopCount() -&amp;gt; Int { increasingValue += 1 return increasingValue } var body : some View { let loop = testLoopCount() //每次都只循环两次，因为第一次时 loop 是2 ForEach(0..&amp;lt;loop) {_ in Text(“Text”) } } </description>
    </item>
    
    <item>
      <title>SwiftUI 与 UIKit 混用</title>
      <link>https://leverkusen188.github.io/swiftui/swiftu_uikit_merge/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swiftui/swiftu_uikit_merge/</guid>
      <description>UIKit 到 SwiftUI 用实现了 UIViewRepresentable 协议的 “final class” 或是 “struct”，都可以直接作为 SwiftUI里的 View 来使用。样例代码如下： UIKit 里： final class ButtonForSwiftUI : UIViewRepresentable { var btn : UIButton = UIButton(type: .system) //当SwiftUI第一次初始化 ButtonForSwiftUI时 会调用 func makeUIView(context: Context) -&amp;gt; UIButton { btn.setTitle(&amp;#34;Button1&amp;#34;, for: .normal) btn.setTitleColor(.green, for: .normal) btn.backgroundColor = .black btn.addTarget(self, action: #selector(onClick), for: .touchUpInside) return btn } //当SwiftUI 初始化或刷新view时，如果用到了ButtonForSwiftUI，就会调用 func updateUIView(_ uiView: UIButton, context: Context) { //从 context.coordinator 来访问创建的 DoWithAction 实例 } //创建一个专门处理数据的实例 func makeCoordinator() -&amp;gt; DoWithAction { DoWithAction(self) } @objc private func onClick() { print(&amp;#34;\(self)&amp;#34;) } //声明 数据处理类 class DoWithAction { var control : ButtonForSwiftUI init(_ c : ButtonForSwiftUI) { control = c } } } SwiftUI里：</description>
    </item>
    
    <item>
      <title>SwiftUI 基础交互控件</title>
      <link>https://leverkusen188.github.io/swiftui/swiftui_common_controller/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swiftui/swiftui_common_controller/</guid>
      <description>导航页面跳转 导航页面（NavigationView）的点击（NavigationLink）后跳转至另一个页面。
样例代码：
//NavigationView 的点击事件与 NavigationLink 的跳转绑定 NavigationView { //NavigationLink 的跳转目标，也是一个View. 这里是 LandmarkDetail //创建 NavigationLink 的第二个参数，closure 返回的View 就是可点击的区域 NavigationLink(destination: LandmarkDetail(landmark: landmarkData[0])) { Text(&amp;#34;hello22&amp;#34;).background(Color.red) } //在 NavigationView 里可以创建多个 NavigationLink，跳转到不同的页面 NavigationLink(destination: LandmarkDetail(landmark: landmarkData[1])) { Text(&amp;#34;hello22&amp;#34;).background(Color.red) } } PS：页面跳转区域是该NavigationView 的区域，界面里可以有多个NavigationView，分别进行跳转。 参考截图： 弹出窗口(Present) 同 presentViewController 用一个 Binding 来控制弹出时机。
@State var showingProfile = false //当 showingProfile 为true时，触发present .sheet(isPresented: $showingProfile) { //返回 present出来的view ProfileHost() .environmentObject(self.userData) } //将 showingProfile 设为false，能dismiss对应的present view
开关控件Toggle（UISwitch） 可以绑定一个声明为 @State 的Bool属性。
//绑定声明为 @State的对象的一个bool属性，该bool属性需要设置为 @Pubished Toggle(isOn: $profile.</description>
    </item>
    
    <item>
      <title>SwiftUI 常用属性包装器</title>
      <link>https://leverkusen188.github.io/swiftui/swiftui_property_wapper/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swiftui/swiftui_property_wapper/</guid>
      <description>@State 可监听的基本类型 可监听的的数据属性，可以触发对应view的刷新。 用于基本数据类型，比如 Bool, Int, String
样例代码：
//声明 可监听的属性 @State private var showScore = true Button(“ShowOrHide”) { //修改该属性，会触发执行 使用该属性的代码 showScore = !showScore } if showScore { ScorePlate(model: model).padding(.top, 20) } @Binding 双向绑定两个属性 将一个 @State 属性绑定到一个 @Binding 属性上。 当双方发生改变时，都会改变另一个。
struct CategoryHome: View { @State var showingProfile = false var body: some View { List { //将 self.showingProfile 设为 true 来弹出 ProfileHost Button(&amp;#34;Change&amp;#34;) { self.showingProfile = true } } .sheet(isPresented: $showingProfile) { //将 showingProfile 绑定到 ProfileHost的 shouldHide 上，然后 ProfileHost就可以控制shouldHide来做dismiss操作了。 ProfileHost(shouldHide: $showingProfile) } } } struct ProfileHost: View { @Binding var shouldHide : Bool var body: some View { Button(&amp;#34;Close&amp;#34;) { // 绑定的showingProfile 也会改为false，将当前view 给dismiss掉 self.</description>
    </item>
    
    <item>
      <title>XCTest Mork</title>
      <link>https://leverkusen188.github.io/xctest/xctest_mork/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/xctest/xctest_mork/</guid>
      <description>以网络请求场景为例 样例代码：
class NetworkManager { func loadData(from url: URL, completionHandler: @escaping (NetworkResult) -&amp;gt; Void) { let task = URLSession.shared.dataTask(with: url) { data, _, error in // Create either a .success or .failure case of a result enum let result = data.map(NetworkResult.success) ?? .failure(error) completionHandler(result) } task.resume() } } 可以由两种方法来mock数据。
创建 使用到的类的mock子类，并重写调用路径上的相关方法，来返回mock数据 // We create a partial mock by subclassing the original class class URLSessionDataTaskMock: URLSessionDataTask { private let closure: () -&amp;gt; Void init(closure: @escaping () -&amp;gt; Void) { self.</description>
    </item>
    
    <item>
      <title>XCTest 基础知识 &amp; Waiter</title>
      <link>https://leverkusen188.github.io/xctest/xctest_waiter/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/xctest/xctest_waiter/</guid>
      <description>基本知识 异步接口测试，可以用 XCTestExpectation。 测试性能，可用 measureBlock 接口。 关于XCTWaiter用法 简单来说就是通过delegate的方式把处理XCTExpectation的方法解耦，可以在delegate回调中处理超时，中断等异步测试用例的异常，根据实际需求，决定是否让case 通过，或是抛出一个错误。
样例代码：
class WeiboModelTest : XCTestCase { var model : WeiboModel? let bag = DisposeBag() let chinaCode = &amp;#34;001&amp;#34; var waiter : XCTWaiter? override func setUpWithError() throws { self.model = WeiboModel() self.waiter = XCTWaiter(delegate: self) } func testWaiter() { let expectaton1:XCTestExpectation = expectation(description: &amp;#34;Fail1&amp;#34;) DispatchQueue.global().async { Thread.sleep(forTimeInterval: 1) expectaton1.fulfill() } expectaton1.isInverted = true waiter?.wait(for: [expectaton1], timeout: 2) } func testWaiterSuccess() { let expectaton1:XCTestExpectation = expectation(description: &amp;#34;Pass&amp;#34;) DispatchQueue.</description>
    </item>
    
    <item>
      <title>一次还原ios release包的卡顿堆栈的记录</title>
      <link>https://leverkusen188.github.io/iosrelated/%E4%B8%80%E6%AC%A1%E8%BF%98%E5%8E%9Fios-release%E5%8C%85%E7%9A%84%E5%8D%A1%E9%A1%BF%E5%A0%86%E6%A0%88%E7%9A%84%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/iosrelated/%E4%B8%80%E6%AC%A1%E8%BF%98%E5%8E%9Fios-release%E5%8C%85%E7%9A%84%E5%8D%A1%E9%A1%BF%E5%A0%86%E6%A0%88%E7%9A%84%E8%AE%B0%E5%BD%95/</guid>
      <description>前提： 测试提了一个关于某个操作下会比较卡顿的问题，并上传了applog。
log初探 app内部工具的InnerToolBlockDetect 里记录了卡顿的情况并打印了对应的线程堆栈信息。 但由于测试用的是release包，因此堆栈里都是相应函数的位移地址，无法看出真正的卡顿代码。
libsystem_kernel.dylib 0x1f59140f4 mach_msg_trap + 8 libsystem_kernel.dylib 0x1f59135a0 mach_msg + 72 libdispatch.dylib 0x1f5778884 &amp;lt;redacted&amp;gt; + 500 libdispatch.dylib 0x1f5778d14 &amp;lt;redacted&amp;gt; + 52 libxpc.dylib 0x1f59d891c xpc_connection_send_message_with_reply_sync + 204 CoreMedia 0x1f93a9514 FigXPCRemoteClientSendSyncMessageCreatingReply + 36 CoreMedia 0x1f92ca884 &amp;lt;redacted&amp;gt; + 192 CoreFoundation 0x1f5d15d30 &amp;lt;redacted&amp;gt; + 192 MediaToolbox 0x1fa95459c &amp;lt;redacted&amp;gt; + 1448 MediaToolbox 0x1fa953f6c FigAssetRemoteCreateWithURL + 120 AVFoundation 0x1fbdf5bb0 &amp;lt;redacted&amp;gt; + 192 AVFoundation 0x1fbd0a874 &amp;lt;redacted&amp;gt; + 884 AVFoundation 0x1fbd033e4 &amp;lt;redacted&amp;gt; + 100 Fly-rls 0x106382da0 _ZNSt3__114__thread_proxyINS_5tupleIJNS_10unique_ptrINS_15__thread_structENS_14default_deleteIS3_EEEEZN3dji6common6WorkerC1EvEUlvE_EEEEEPvSC_ + 1355164 Fly-rls 0x106383224 _ZNSt3__114__thread_proxyINS_5tupleIJNS_10unique_ptrINS_15__thread_structENS_14default_deleteIS3_EEEEZN3dji6common6WorkerC1EvEUlvE_EEEEEPvSC_ + 1356320 Fly-rls 0x1044c5fec _mh_execute_header + 303084 Fly-rls 0x1044c5e1c _mh_execute_header + 302620 Fly-rls 0x10466c0ec _mh_execute_header + 2031852 Fly-rls 0x10466b920 _mh_execute_header + 2029856 Fly-rls 0x1044bd92c _mh_execute_header + 268588 libdispatch.</description>
    </item>
    
    <item>
      <title>函数相关语法注意点</title>
      <link>https://leverkusen188.github.io/javascript/function/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/javascript/function/</guid>
      <description>参数与返回值 1. 无return值的函数，返回 undefined
function tttt() { } if (tttt() === undefined) { console.log(&amp;#39;undefined111&amp;#39;) } 2. 函数只用名字来限定唯一性
function t1(p1) { console.log(&amp;#39;t1 p1=&amp;#39; + p1) } function t1(p1, p2) { console.log(&amp;#39;t1 p1=&amp;#39; + p1 + &amp;#34;p2=&amp;#34;+p2) } 前面那个t1 会被覆盖
3. 调用函数时，参数个数不一定要一致 如果参数多了，函数会忽略 如果参数少了，默认为 undefined
4. 函数内使用 arguments arguments 可以访问函数传入的参数，但不同于数组。可以用 length 来判断个数，以及 下标来访问
function abs() { if (arguments.length === 0) { return 0; } var x = arguments[0]; return x &amp;gt;= 0 ?</description>
    </item>
    
    <item>
      <title>国家省份城市demo 笔记心得</title>
      <link>https://leverkusen188.github.io/rxswift/citydemo/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/rxswift/citydemo/</guid>
      <description>将view的rx的ControlEvent 于 model的某个Subject（Observable 和 Observer的合体）绑定起来。而model的这个subject作为网络请求的发起者，包装一个Observable 给UI去订阅，并获取查询返回的数据用以更新UI model提供Observable 来给UI 更新，尽量保证 该Observable的Element 与View的Observer 或是 setter属性一致，这样就可以直接通过binding 来更新，而不用多余的代码。 禁止出现嵌套订阅代码，难以阅读以及 容易出现retain circle Demo下载地址</description>
    </item>
    
    <item>
      <title>图片组件（image）</title>
      <link>https://leverkusen188.github.io/reactnative/rn_image/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/reactnative/rn_image/</guid>
      <description>加载本地图片（js package里） 图片放置在 js的package里
使用 Image 组件即可。
&amp;lt;Image source={require(&amp;#39;./img/check.png&amp;#39;)} /&amp;gt; 也能用变量来动态加载
const icon = &amp;#34;small.png&amp;#34;; &amp;lt;Image source={require(&amp;#34;./&amp;#34;+icon)} /&amp;gt; 上面描述的require语法也可以用来静态地加载你项目中的声音、视频或者文档文件。
大多数常见文件类型都支持，包括.mp3, .wav, .mp4, .mov, .htm 和 .pdf等。
参考 https://github.com/facebook/metro/blob/main/packages/metro-config/src/defaults/defaults.js#L14-L44
加载混合app的图片 指的是加载原生app的asset里的图片资源。
iOS &amp;lt;Image source={{ uri: &amp;#39;app_icon&amp;#39; }} style={{ width: 40, height: 40 }} /&amp;gt; android &amp;lt;Image source={{ uri: &amp;#39;asset:/app_icon.png&amp;#39; }} style={{ width: 40, height: 40 }} /&amp;gt; 注意：这些做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。
加载网络图片 使用远程地址作为参数即可. &amp;lt;Image source={{uri: &amp;#39;https://facebook.github.io/react/logo-og.png&amp;#39;}} style={{width: 400, height: 400}} /&amp;gt; 注意：跟加载app图片一样，需要指定尺寸。
还能直接制定请求参数
&amp;lt;Image source={{ uri: &amp;#39;https://facebook.</description>
    </item>
    
    <item>
      <title>基于Python &#43;Selenium的爬虫详解</title>
      <link>https://leverkusen188.github.io/python/python_selenium%E7%88%AC%E8%99%AB/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/python/python_selenium%E7%88%AC%E8%99%AB/</guid>
      <description>背景 Selenium Selenium 是一个用于web应用程序自动化测试的工具，直接运行在浏览器当中，支持chrome、firefox等主流浏览器。可以通过代码控制与页面上元素进行交互（点击、输入等），也可以获取指定元素的内容。
2.优劣
劣势：
相比于抓包→构造请求→解析返回值的爬虫，由于Selenium需要生成一个浏览器环境，所有操作（与元素交互、获取元素内容等）均需要等待页面加载完毕后才可以继续进行，所以速度相比构造请求的慢很多。
对于为了反爬做了特殊处理的展示内容，如字体加密（参考猫眼）、图片替换数字（参考自如）等，可能取不到想要的数据。
使用图片替换数字的自如：
优势：
1、不需要做复杂的抓包、构造请求、解析数据等，开发难度相对要低一些。
2、其访问参数跟使用浏览器的正常用户一模一样，访问行为也相对更像正常用户，不容易被反爬虫策略命中。
3、生成的浏览器环境可以自动运行 JS 文件，所以不用担心如何逆向混淆过的JS文件生成用作人机校验的参数，如马蜂窝酒店评论的人机校验参数_sn，网易云音乐评论的人机校验参数params、encSecKey。可以自行抓包查看。
4、如果需要抓取同一个前端页面上面来自不同后端接口的信息，如OTA酒店详情页的酒店基础信息、价格、评论等，使用Selenium可以在一次请求中同时完成对三个接口的调用，相对方便。
实现 1.环境
python3.6 + Macos
2.依赖包
Selenium
安装的时候是大写的 S ，import的时候是 小写 s。
pip install Selenium 3.浏览器驱动（webdriver）
加载浏览器环境需要下载对应的浏览器驱动，此处选择 Chrome。
下载地址：http://npm.taobao.org/mirrors/chromedriver/ ，
选择合适的版本下载解压后放在随便一个位置即可。
4.hello world
from selenium import webdriver &amp;#39;&amp;#39;&amp;#39;这里填刚刚下载的驱动的路径&amp;#39;&amp;#39;&amp;#39; path = &amp;#39;/Applications/Google Chrome.app/Contents/chromedriver&amp;#39; driver = webdriver.Chrome(executable_path=path) url = &amp;#39;http://hotel.qunar.com/city/beijing_city/&amp;#39; driver.get(url) &amp;#39;&amp;#39;&amp;#39;运行上述代码，会打开一个浏览器，并且加载去哪儿的酒店列表页&amp;#39;&amp;#39;&amp;#39; 这时候可以通过webdriver自带的一些的一些方法获取元素内容或者与元素进行交互。 #返回ID = js_block_beijing_city_7810的元素信息 hotel_info = driver.find_element_by_id(&amp;#39;js_block_beijing_city_7810&amp;#39;) print(hotel_info.text) #返回 展示在列表页的酒店信息 #同理，可以find_element_by_[class_name|name] 等，均可完成查询。 也可以通过方法 find_elements查找符合某条件的一组元素，以列表的形式返回。 #当需要查询的唯一标识带有空格时，可以使用find_elements_by_css_selector，否则会报错。 hotel_list = driver.</description>
    </item>
    
    <item>
      <title>基本语法注意点</title>
      <link>https://leverkusen188.github.io/javascript/basicgramma/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/javascript/basicgramma/</guid>
      <description>数据对比 不要使用==比较，始终坚持使用 === 比较。 == 会自动转换数据类型来对比，有时候会得到奇怪的结果（当对比数据类型不同时） === 会先判断数据类型是否一致（不一致返回false），再对比数据是否相同。
false == 0; // 返回 true false === 0; // 返回 false 特例：
NaN === NaN; //返回false 必须用 isNaN(Nan) 来判断
字符串相关 格式化多行字符串
var name = &amp;#39;小明&amp;#39;; var age = 20; var message = `你好, ${name}, 你今年${age}岁了!`; 字符串是不可变的 使用以下方法，都无法改变字符串
var s = &amp;#39;Hello, world!&amp;#39;; s[0] = &amp;#39;X&amp;#39;; //还是 Hello world s.toUpperCase() //返回大写的字符串，但 s 不变 数组相关 直接给Array的length赋一个新的值会导致Array大小的变化
var arr = [1, 2, 3]; arr.length = 6; //arr变为[1, 2, 3, undefined, undefined, undefined] 如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化：</description>
    </item>
    
    <item>
      <title>属性包装器Property Wrappers</title>
      <link>https://leverkusen188.github.io/swift/swift_property_wrappers/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/swift_property_wrappers/</guid>
      <description>代码示例：
@propertyWrapper struct Increase&amp;lt;T&amp;gt; { var wrappedValue : T { get {return value1} set { value1 = newValue if T.self is Int.Type { print(&amp;#34;\(T.self)&amp;#34;) } if T.self is NSObject.Type || T.self is (NSObject?).Type { print(&amp;#34;\(T.self)&amp;#34;) } } } var projectedValue : Increase&amp;lt;T&amp;gt; {return self} private var value1 : T init(wrappedValue: T) { self.value1 = wrappedValue } public func printValue() { if let v = wrappedValue as? Int { print(&amp;#34;Increase: value=\(v+1)&amp;#34;) } } } class SwiftTestObject : NSObject { @Increase var wrappedInt : Int = 1 @Increase(wrappedValue: nil) var wrappedObject : NSObject?</description>
    </item>
    
    <item>
      <title>简历自我介绍补全</title>
      <link>https://leverkusen188.github.io/%E9%9D%9E%E6%8A%80%E6%9C%AF/%E7%AE%80%E5%8E%86%E5%AD%97%E6%88%91%E4%BB%8B%E7%BB%8D%E8%A1%A5%E5%85%A8/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/%E9%9D%9E%E6%8A%80%E6%9C%AF/%E7%AE%80%E5%8E%86%E5%AD%97%E6%88%91%E4%BB%8B%E7%BB%8D%E8%A1%A5%E5%85%A8/</guid>
      <description>离职原因 腾讯 DJI的光环 收入的提升 DJI 对以硬件为主软件为辅的产品研发流程感到有点厌倦。 对拍摄相关兴趣不高，延伸到对自家软件产品的成就感，关注度不够高。 负责的模块处于对接多个模块（团队）的中心位置，除日常开发维护外的其他工作（比如软硬件功能问题定位，CI编译问题等）较多，耗费大量精力。 公司相关项目经历 腾讯经历： 主要负责ios 手机QQ App的群相关业务开发工作，以及移动端跨平台插件技术调研 &amp;amp; 研发。
lua-wax 要点： 内存管理：定时器检查引用计数。对象引用关系影响retain count。对象释放会有延迟。 lua创建的oc对象，不用显式地调用alloc，wax会帮你调用。在放入 strongtable中的对象，在定时器扫描时发现retainccount 小于2时，就会帮你调用release释放，模拟出arc效果。 线程模型：一个Lua stack 代表一个线程（stack是lua用来和C 进行数据通信的渠道）。一个wax instance等于一个stack。 block 支持不是很好，比如block的参数也是block时。 DJI 经历： 带领ios团队，承担电商部门ios平台的相关产品研发工作。 主要职责：app框架搭建，技术选型评估（比如内置IM的第三方sdk选型），参与业务需求讨论定型，前后端接口设计。
部门重组后加入软件部，参与软件部多个主要app产品的开发，维护，持续优化 以及 疑难问题攻关工作。以及一些能提高团队研发效率的相关技术调研和工具开发工作。 开发角色：前期主要负责DJI Go App上 远端 &amp;amp; 本地相册，视频编辑，用户中心，App内置H5 等模块的开发维护。 后期主要负责 跨平台回放，iOS端的智能相册模块。 团队效率方面：csdk 源码/二进制编译切换工具；分享，网络请求，用户中心几个功能的模块化；UI和Midware代码库合并（Fly 和Mimo）
案例1： 相机HTTP多线程下载开发，以及 32int 溢出导致的下载失败问题。 动态库引起的多单例问题。
案例2: 在使用内部的KVO工具绑定接收消息时，发现明显的性能问题。 跟踪发现是其他团队的内部性能检测工具在检测到DJI 开头的类的属性变化时，会记录当前的线程 callstack，并在耗时达到一定程度时 记录下来作为性能问题。
案例3: App性能优化：
缓存数据结构的优化，由整取整寸的文件缓存方式调整为 数据库，并做了相应的老数据迁移。 2022-10-12 腾讯面试
关于软件性能优化方面的成绩，技术助力不够。 runloop的相关概念细节。 </description>
    </item>
    
    <item>
      <title>组件布局</title>
      <link>https://leverkusen188.github.io/reactnative/rn_layout/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/reactnative/rn_layout/</guid>
      <description>Flex Direction 一种子组件的排列方式。 使用的是 flexDirection 属性，默认是 column，一共四种：
&amp;ldquo;column&amp;rdquo;, //从上往下 &amp;ldquo;row&amp;rdquo;, //从左往右 &amp;ldquo;row-reverse&amp;rdquo;, //从右往左 &amp;ldquo;column-reverse&amp;rdquo; //从下往上 Layout Direction 另一种排列方式，使用的是 direction 属性，决定子组件靠左，还是靠右，但不会递归传递下去。
一共两种： ltr: 从左往右 rtl: 从右往左 Justify Content 在组件的 style 中指定justifyContent可以决定其子元素沿着主轴的排列方式。
flex-start: 子元素从开始处依次排列。 当 flexDirection 为 row时 当 flexDirection 为 row-reverse时（因为布局是从右往左的） flex-end：所有子元素靠结尾处排列 当 flexDirection 为 row时(结尾处是右边) 当 flexDirection 为 row-reverse时（因为布局是从右往左的, 所以结尾处就是最左边） center： 所有子元素按总宽度计算后，靠中间一起排列 space-between：第一个和最后一个子元素分别靠开始和结尾，其他子元素平均排列，保证子元素之间距离相同。 space-around: 第一个和最后一个子元素会跟开始和结尾 空一小段，其他子元素平均排列，子元素之间距离相同 space-evenly：所有元素之间距离 以及 首尾元素跟边缘的距离 完全一样。 Align Items 在组件的 style 中指定alignItems可以决定其子元素沿着次轴（如果主轴是row，那么次轴就是 column）的排列方式
stretch: 将子元素往次轴方向拉伸，以填满。（要求width不能限定值; 下图里 第一二个元素限定了width:50, 第三个未限定） flex-start: 子元素靠次轴的开始方向布局。（次轴是row，开始方向就是最左边） flex-end：子元素靠次轴的结尾方向布局。 center：子元素靠次轴的中间布局。 Align Self 可以将alignSelf 给单独的子元素（可设置的值跟 alignItems 一样），那么该子元素就会遵从 alignSelf的设置而忽略父元素的alignItems。 比如下面例子，第一个元素的alignSelf 设为 stretch, 因此完全忽略了父元素的 center设置。 Flex Wrap flexWrap 决定子元素在主轴上超过父元素大小时，是否在次轴方向进行换行显示。 默认是no-wrap, 可以设置为 wrap</description>
    </item>
    
    <item>
      <title>组件的样式和大小</title>
      <link>https://leverkusen188.github.io/reactnative/styleandsize/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/reactnative/styleandsize/</guid>
      <description>样式 订制组件的样式，用style 属性。 Style 里可以放入js的变量，也能放入多个变量的数组（以数组靠后的变量样式为最优先）
样例代码：
import React from &amp;#39;react&amp;#39;; import { StyleSheet, Text, View } from &amp;#39;react-native&amp;#39;; const LotsOfStyles = () =&amp;gt; { return ( &amp;lt;View style={styles.container}&amp;gt; &amp;lt;Text style={styles.red}&amp;gt;just red&amp;lt;/Text&amp;gt; &amp;lt;Text style={styles.bigBlue}&amp;gt;just bigBlue&amp;lt;/Text&amp;gt; &amp;lt;Text style={[styles.bigBlue, styles.red]}&amp;gt;bigBlue, then red&amp;lt;/Text&amp;gt; &amp;lt;Text style={[styles.red, styles.bigBlue]}&amp;gt;red, then bigBlue&amp;lt;/Text&amp;gt; //red的color 被后面的 bigBlue的color覆盖了 &amp;lt;/View&amp;gt; ); }; const styles = StyleSheet.create({ container: { marginTop: 50, }, bigBlue: { color: &amp;#39;blue&amp;#39;, fontWeight: &amp;#39;bold&amp;#39;, fontSize: 30, }, red: { color: &amp;#39;red&amp;#39;, }, }); export default LotsOfStyles; 显示效果： 组件大小 高宽的绝对值 最简单的给组件设定尺寸的方式就是在样式中指定固定的width和height。React Native 中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点, 其实也就是系统的 UIScreen 获取到的大小。</description>
    </item>
    
    <item>
      <title>调试debug </title>
      <link>https://leverkusen188.github.io/reactnative/rndebug/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/reactnative/rndebug/</guid>
      <description>本机模拟器调试： 实际上就是在本机器上启动了一个NPM的 web服务，将对应的js文件也放进去。 模拟器app 通过 localhost 来加载所有的js文件，通过 react-native 解析成native代码，最终渲染出UI。
连手机调试： 在本机器上启动NPM的web服务，将对应的js文件也放进去。 联机编译时，react-native-xcode.sh 脚本会生成一个 ip.txt 文件，里面是本机器的ip地址，并将该txt文件放入app的bundle里。 手机app 通过该IP 以及 NPM的web服务来加载所有JS文件。
UI层次调试 可以使用 react-devtools。 安装方式：
export ELECTRON_MIRROR=&amp;#34;https://npm.taobao.org/mirrors/electron/&amp;#34; //换一下package源，避免墙问题 npm install -g react-devtools PS：如果连手机调试，需要手机和电脑在同一个网段下。
然后用 react-devtools 启动工具即可。
堆栈还原 npx metro-symbolicate android/app/build/generated/sourcemaps/react/release/index.android.bundle.map &amp;lt; stacktrace.txt </description>
    </item>
    
  </channel>
</rss>
