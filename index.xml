<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>https://leverkusen188.github.io/hugoBlog/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 22 Sep 2022 18:11:53 +0800</lastBuildDate><atom:link href="https://leverkusen188.github.io/hugoBlog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Swift Keypath</title>
      <link>https://leverkusen188.github.io/hugoBlog/ios%E7%9B%B8%E5%85%B3/swift-keypath/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/hugoBlog/ios%E7%9B%B8%E5%85%B3/swift-keypath/</guid>
      <description>译自 The power of key path in Swift
Swift 最初的设计就专注于编译期尽量保证程序运行安全 以及 静态类型匹配，因此它比较缺乏类似 OC，Javascript 和ruby等运行时语言的动态特性。比如，在OC里，我们可以在运行时动态访问类对象的属性和方法，甚至改变方法的实现。
但这些动态特性的缺乏正表现出Swift的伟大，它能保证我们写出的程序运行结果更加可预料，且更可能运行不出错。不过有时候我们的代码能拥有一些动态特性也是很有帮助的。
谢天谢地，随着版本更新，Swift 开始拥有更多的动态特性，但却依然保持着静态安全类型特性。其中一种新特性就是KeyPath。本周，我们一起来看看KeyPath在Swift中是如何运作的，以及我们能用它来实现哪些强大的功能。
基础 KeyPath 本质上让我们可以用一个值来引用任意对象的特定属性。像这样，它可以被到处传递引用，在表达式中使用，甚至可以在不用知道它是哪个类的属性时，对它进行set 和get 操作。
KeyPath一般有三种类型：
KeyPath：提供只读的属性访问 WritableKeyPath: 通过特定语法，提供某个对象的可变更属性的读写权限。（该对象必须是可修改的） ReferenceWritableKeyPath: 只能对可引用的类型使用，比如类的对象实例。同上，提供该对象的某个可修改的属性的读写权限。 还有一些其他的keyPath类型，用来减少代码重复性，同时移除类型限制。不过我们暂时只关注主要的这几个类型。
让我们来看看如何使用KeyPath，以及为什么它这么有趣又功能强大。
功能速记 比如说我们要开发一个 让用户可以从各种Web上阅读文章的App，可以设计一个Article 数据模型来表示一篇文章，像这样：
struct Article { let id: UUID let source: URL let title: String let body: String } 当我们使用这种数据模型的数组时，经常需要从类里摘取单一属性出来重新生成一个新的数据数组。比如下面的例子，我们将所有id 和source数据拿出来生成新的数据数组。
let articleIDs = articles.map { $0.id } let articleSources = articles.map { $0.source } 当我们只需要使用到一个属性数据时，上面的代码是ok的。但其实我们不需要使用到闭包的所有功能，这时候使用keypath 就是比较合适的选择了。
我们可以重载Sequence 的map 方法，让它使用一个keypath来替代之前的闭包作为参数。在这个例子里，我们只对只读属性数据感兴趣，因此使用KeyPath 类型即可。使用传入的KeyPath 来生成数据返回，就像下面这样：</description>
    </item>
    
    <item>
      <title>一次还原ios release包的卡顿堆栈的记录</title>
      <link>https://leverkusen188.github.io/hugoBlog/ios%E7%9B%B8%E5%85%B3/%E4%B8%80%E6%AC%A1%E8%BF%98%E5%8E%9Fios-release%E5%8C%85%E7%9A%84%E5%8D%A1%E9%A1%BF%E5%A0%86%E6%A0%88%E7%9A%84%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/hugoBlog/ios%E7%9B%B8%E5%85%B3/%E4%B8%80%E6%AC%A1%E8%BF%98%E5%8E%9Fios-release%E5%8C%85%E7%9A%84%E5%8D%A1%E9%A1%BF%E5%A0%86%E6%A0%88%E7%9A%84%E8%AE%B0%E5%BD%95/</guid>
      <description>前提： 测试提了一个关于某个操作下会比较卡顿的问题，并上传了applog。
log初探 app内部工具的InnerToolBlockDetect 里记录了卡顿的情况并打印了对应的线程堆栈信息。 但由于测试用的是release包，因此堆栈里都是相应函数的位移地址，无法看出真正的卡顿代码。
libsystem_kernel.dylib 0x1f59140f4 mach_msg_trap + 8 libsystem_kernel.dylib 0x1f59135a0 mach_msg + 72 libdispatch.dylib 0x1f5778884 &amp;lt;redacted&amp;gt; + 500 libdispatch.dylib 0x1f5778d14 &amp;lt;redacted&amp;gt; + 52 libxpc.dylib 0x1f59d891c xpc_connection_send_message_with_reply_sync + 204 CoreMedia 0x1f93a9514 FigXPCRemoteClientSendSyncMessageCreatingReply + 36 CoreMedia 0x1f92ca884 &amp;lt;redacted&amp;gt; + 192 CoreFoundation 0x1f5d15d30 &amp;lt;redacted&amp;gt; + 192 MediaToolbox 0x1fa95459c &amp;lt;redacted&amp;gt; + 1448 MediaToolbox 0x1fa953f6c FigAssetRemoteCreateWithURL + 120 AVFoundation 0x1fbdf5bb0 &amp;lt;redacted&amp;gt; + 192 AVFoundation 0x1fbd0a874 &amp;lt;redacted&amp;gt; + 884 AVFoundation 0x1fbd033e4 &amp;lt;redacted&amp;gt; + 100 Fly-rls 0x106382da0 _ZNSt3__114__thread_proxyINS_5tupleIJNS_10unique_ptrINS_15__thread_structENS_14default_deleteIS3_EEEEZN3dji6common6WorkerC1EvEUlvE_EEEEEPvSC_ + 1355164 Fly-rls 0x106383224 _ZNSt3__114__thread_proxyINS_5tupleIJNS_10unique_ptrINS_15__thread_structENS_14default_deleteIS3_EEEEZN3dji6common6WorkerC1EvEUlvE_EEEEEPvSC_ + 1356320 Fly-rls 0x1044c5fec _mh_execute_header + 303084 Fly-rls 0x1044c5e1c _mh_execute_header + 302620 Fly-rls 0x10466c0ec _mh_execute_header + 2031852 Fly-rls 0x10466b920 _mh_execute_header + 2029856 Fly-rls 0x1044bd92c _mh_execute_header + 268588 libdispatch.</description>
    </item>
    
  </channel>
</rss>
