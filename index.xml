<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>https://leverkusen188.github.io/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 22 Sep 2022 18:11:53 +0800</lastBuildDate><atom:link href="https://leverkusen188.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>IOS app性能调优相关知识点</title>
      <link>https://leverkusen188.github.io/ios%E7%9B%B8%E5%85%B3/ios%E6%80%A7%E8%83%BD/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/ios%E7%9B%B8%E5%85%B3/ios%E6%80%A7%E8%83%BD/</guid>
      <description>前言 本文较长（5000字左右），建议阅读时间： 20min+
一个iOS App的稳定性，主要决定于整体的系统架构设计，同时也不可忽略编程的细节，正所谓“千里之堤，溃于蚁穴”，一旦考虑不周，看似无关紧要的代码片段可能会带来整体软件系统的崩溃。尤其因为苹果限制了热更新机制，App本身的稳定性及容错性就显的更加重要，之前可以通过发布热补丁的方式解决线上代码问题，现在就需要在提交之前对App开发周期内的各个指标进行实时监测，尽量让问题暴漏在开发阶段，然后及时修复，减少线上出问题的几率。针对一个App的开发周期，它的稳定性指标主要有以下几个环节构成，用一个脑图表示如下：
1 开发过程 开发过程中，主要是通过监控内存使用及泄露，CPU使用率，FPS，启动时间等指标，以及常见的UI的主线程监测，NSAssert断言等，最好能在Debug模式下，实时显示在界面上，针对出现的问题及早解决。
内存问题 内存问题主要包括两个部分，一个是iOS中常见循环引用导致的内存泄露 ，另外就是大量数据加载及使用导致的内存警告。
mmap 虽然苹果并没有明确每个App在运行期间可以使用的内存最大值，但是有开发者进行了实验和统计，一般在占用系统内存超过20%的时候会有内存警告，而超过50%的时候，就很容易Crash了，所以内存使用率还是尽量要少，对于数据量比较大的应用，可以采用分步加载数据的方式，或者采用mmap方式。mmap 是使用逻辑内存对磁盘文件进行映射，中间只是进行映射没有任何拷贝操作，避免了写文件的数据拷贝。 操作内存就相当于在操作文件，避免了内核空间和用户空间的频繁切换。之前在开发输入法的时候 ，词库的加载也是使用mmap方式，可以有效降低App的内存占用率，具体使用可以参考链接第一篇文章。
循环引用 循环引用是iOS开发中经常遇到的问题，尤其对于新手来说是个头疼的问题。循环引用对App有潜在的危害，会使内存消耗过高，性能变差和Crash等，iOS常见的内存主要以下三种情况：
Delegate 代理协议是一个最典型的场景，需要你使用弱引用来避免循环引用。ARC时代，需要将代理声明为weak是一个即好又安全的做法：
@property (nonatomic, weak) id &amp;lt;MyCustomDelegate&amp;gt; delegate; 复制代码 NSTimer NSTimer我们开发中会用到很多，比如下面一段代码
- (void)viewDidLoad { [super viewDidLoad]; self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(doSomeThing) userInfo:nil repeats:YES]; } - (void)doSomeThing { } - (void)dealloc { [self.timer invalidate]; self.timer = nil; } 复制代码 这是典型的循环引用，因为timer会强引用self，而self又持有了timer，所有就造成了循环引用。那有人可能会说，我使用一个weak指针，比如
__weak typeof(self) weakSelf = self; self.mytimer = [NSTimer scheduledTimerWithTimeInterval:1 target:weakSelf selector:@selector(doSomeThing) userInfo:nil repeats:YES]; 复制代码 但是其实并没有用，因为不管是weakSelf还是strongSelf，最终在NSTimer内部都会重新生成一个新的指针指向self，这是一个强引用的指针，结果就会导致循环引用。那怎么解决呢？主要有如下三种方式：</description>
    </item>
    
    <item>
      <title>IOS 子工程 源码和二进制库 编译方式切换方案</title>
      <link>https://leverkusen188.github.io/ios%E7%9B%B8%E5%85%B3/%E6%BA%90%E7%A0%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E5%88%87%E6%8D%A2/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/ios%E7%9B%B8%E5%85%B3/%E6%BA%90%E7%A0%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E5%88%87%E6%8D%A2/</guid>
      <description>https://www.jianshu.com/p/a6d0f37cdc27 这个主要是用 环境变量控制 podspec 里，是使用源码还是 .a 。最终 pod install 来让主工程切换子模块的 源码和二进制编译方式。
https://juejin.im/entry/5b5308c66fb9a04f932ff87e 这个好一点，需要创建私有pod，在podspec里配置 subspec；然后通过修改 主工程podfile，指定私有pod的 subspec 来切换编译方式。
具体实施：
为需要提供切换功能的工程配好podspec，作为local pods来管理。 pod lib create &amp;ldquo;podname&amp;rdquo;
编写 该工程的 build 脚本，用以将该工程的 framework / .a 以及头文件等输出为二进制，以供切换编译用。 #!/bin/sh #要build的target名 TARGET_NAME=&amp;#39;BottomStatic&amp;#39; CONFIGURATION=&amp;#39;Debug&amp;#39; #${PROJECT_NAME} if [[ $1 ]] then TARGET_NAME=$1 fi UNIVERSAL_OUTPUT_FOLDER=&amp;#34;${SRCROOT}/${PROJECT_NAME}_Products/&amp;#34; UNIVERSAL_OUTPUT_FOLDER=&amp;#34;${TARGET_NAME}_Products/&amp;#34; BUILD_DIR=&amp;#34;Build/&amp;#34; BUILD_ROOT=&amp;#34;Output/&amp;#34; SRCROOT=&amp;#34;.&amp;#34; #创建输出目录，并删除之前的framework文件 mkdir -p &amp;#34;${UNIVERSAL_OUTPUT_FOLDER}&amp;#34; mkdir -p &amp;#34;${BUILD_DIR}&amp;#34; mkdir -p &amp;#34;${BUILD_ROOT}&amp;#34; rm -rf &amp;#34;${UNIVERSAL_OUTPUT_FOLDER}/${TARGET_NAME}.framework&amp;#34; #分别编译模拟器和真机的Framework xcodebuild -target &amp;#34;${TARGET_NAME}&amp;#34; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos BUILD_DIR=&amp;#34;${BUILD_DIR}&amp;#34; BUILD_ROOT=&amp;#34;${BUILD_ROOT}&amp;#34; clean build xcodebuild -target &amp;#34;${TARGET_NAME}&amp;#34; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphonesimulator BUILD_DIR=&amp;#34;${BUILD_DIR}&amp;#34; BUILD_ROOT=&amp;#34;${BUILD_ROOT}&amp;#34; clean build #拷贝framework到univer目录 cp -R &amp;#34;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${TARGET_NAME}.</description>
    </item>
    
    <item>
      <title>IOS 组件化-动态库实战</title>
      <link>https://leverkusen188.github.io/ios%E7%9B%B8%E5%85%B3/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%8A%A8%E6%80%81%E5%BA%93/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/ios%E7%9B%B8%E5%85%B3/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%8A%A8%E6%80%81%E5%BA%93/</guid>
      <description>起因
理论功底
动态库和静态库
介绍
静态库和动态库的区别
举个例子， iOS 项目中使用 Embeded Framework
静态库和动态库如何构建和加载
静态库和动态库依赖关系
Xcode 项目结构
iOS 依赖管理事实上的标准
解决问题
制作动态库
剖析下动态库 Framework 吧
回过头来看 Embened Framework
Why Swift does not Support Staic Libraies
CocoaPods 使用 Use_framework!
动态库 Framework 的文件结构
更愉快的导入文件
资源问题
参考
起因
去年，公司iOS端，之前由于所有的业务端代码都是混乱管理，造成开发有很多痛点无法单测，团队成员提交代码冲突机率大，CI配合效果差，功能性代码多端无法复用，单仓库代码量大，编译时间长 等等痛点，领导和组内多次沟通开始着手组件化开发，希望能改进这些开发中的痛点，成立组件化团队。
组件化的方案大同小异，基础性代码封装私有库，业务组件交互交由中间件负责，项目依赖工具用iOS项目事实上的标准CocoaPods
前期的基础性组件拆分都较为顺利，从依赖树的叶子节点开发是最合适的方案。
随着组件抽离的越来越多，私有库的依赖体系也越来越复杂，慢慢过渡到了业务组件。业务组件用了Swift的第三方组件，用了Swift库的同学都知道必须加上use_frameworks!，这个标记是说Pod管理的依赖全部编译为动态库，然后呢我们的很多组件又依赖了诸如百度地图，微信分享等静态库，于是我在执行 pod install 报了一个没有碰见过的错误。
1[!] The &amp;lsquo;Pods-LJA_Example&amp;rsquo;target has transitive dependencies that include static binaries:
这就尴尬了，于是一阵疯狂的搜索google stackoverflow等，然而并没有什么卵用，而且上面催得急，根本没时间处理这些小问题 业务重构是最主要的，以至于我们的业务组件没有做到独立仓库拆分。
直到最近终于找到了解决办法:( 主要是自己的功力不够深厚）
理论功底
动态库和静态库
介绍
首先静态库和动态库都是以二进制提供代码复用的代码库
静态库 常见的是 .</description>
    </item>
    
    <item>
      <title>python基础环境搭建</title>
      <link>https://leverkusen188.github.io/python/python%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/python/python%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>虚拟环境： 主要是创建一个虚拟的 python 环境，相关的第三方package会独立放在指定的目录下。 但python相关的bin文件，都是从正式环境 景象过来的。 参考：https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/
安装虚拟环境： On macOS and Linux:
python3 -m pip install --user virtualenv On Windows:
py -m pip install --user virtualenv 创建虚拟环境： On macOS and Linux:
python3 -m venv env_name On Windows:
py -m venv env_name 进入/退出 虚拟环境： On macOS and Linux:
source env/bin/activate On Windows:
.\env\Scripts\activate 退出 deactivate 关于python package安装包 参考： https://python-packaging.readthedocs.io/en/latest/minimal.html
package文件结构和组成 用pip install安装的包，在根目录下需要有个 setup.py 文件，里面配置了 这个package的相关信息（类似cocoapods的 podspec 文件） from setuptools import setup setup(name=&amp;#39;requests1&amp;#39;, version=&amp;#39;0.</description>
    </item>
    
    <item>
      <title>RxFeedback 学习</title>
      <link>https://leverkusen188.github.io/rxswift/rxfeedback/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/rxswift/rxfeedback/</guid>
      <description>核心功能：自定义Event的触发事件集合，以及订阅该事件触发后会修改的一个状态集对象的Observable。同时自定义 在事件触发后，对状态集对象进行数据变更。
样例代码：
//在下面代码中，状态集对象就是Int typealias State = Int //自定义事件是 增加和减少 enum Event { case increment case decrement } Observable.system( initialState: 0,	//声明状态集对象的初始化值 //reduce里，是接收到 event事件后，对状态集对象进行自定义处理的代码。然后将新的状态集对象返回。 STEP 2 reduce: { (state, event) -&amp;gt; State in switch event { case .increment: return state + 1 case .decrement: return state - 1 } }, scheduler: MainScheduler.instance, feedback: //bind 传入owner对象，作为 第二个closure的首个参数返回。 //第二个closure参数作用是 自定义Event的触发时机，以及 对状态集对象Observable的订阅操作 //state就是一个 状态集对象的Observable，即 ObservableSchedulerContext&amp;lt;State&amp;gt; bind(self) { me, state -&amp;gt; Bindings&amp;lt;Event&amp;gt; in //对状态集对象Observable的订阅集合 let subscriptions = [ state.</description>
    </item>
    
    <item>
      <title>RxSwift 的Subject</title>
      <link>https://leverkusen188.github.io/rxswift/rxswift_subject/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/rxswift/rxswift_subject/</guid>
      <description>ReplaySubject ReplaySubject 在创建时候需要设置一个 bufferSize，表示它对于它发送过的 event 的缓存个数。 比如一个 ReplaySubject 的 bufferSize 设置为 2，它发出了 3 个 .next 的 event，那么它会将后两个（最近的两个）event 给缓存起来。此时如果有一个 subscriber 订阅了这个 ReplaySubject，那么这个 subscriber 就会立即收到前面缓存的两个.next 的 event。 如果一个 subscriber 订阅已经结束的 ReplaySubject，除了会收到缓存的 .next 的 event外，还会收到那个终结的 .error 或者 .complete 的event。 样例代码：
let subject = ReplaySubject&amp;lt;String&amp;gt;.create(bufferSize: 2) subject.onNext(“1”) subject.onNext(“2”) subject.onNext(“3”) //第一次订阅，会收到 2 和 3 事件 subject.subscribe(onNext: { (event) in print(event) }, onError: { (error) in print(error) }, onCompleted: { print(&amp;#34;这是一个 完成&amp;#34;) }) { print(&amp;#34;销毁了&amp;#34;) }.disposed(by: bag) subject.</description>
    </item>
    
    <item>
      <title>RxSwift 笔记</title>
      <link>https://leverkusen188.github.io/rxswift/rxswift_note/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/rxswift/rxswift_note/</guid>
      <description>响应机制 响应机制核心是 Observable 和 ObserverType. 前者用来发送事件，使用者可以订阅（subscribe）后，监听 onNext ，onError等事件。 样例代码：
let switch = UISwitch! = UISwitch.init(frame: CGRect(x: 0, y: 50, width: 100, height: 40)) Let swiOnEvent = switch.rx.isOn swiOnEvent.subscribe(onNext: { booValue in print(“isOn=\(booValue)&amp;#34;) }, onError: { i in }) Observable 转换 Observable 的 map 可以在监听到onNext 事件后，将当前Observable的 element 换成自定义的其他类型，并返回一个对应泛型的Observable。 样例代码：
let switch = UISwitch! = UISwitch.init(frame: CGRect(x: 0, y: 50, width: 100, height: 40)) Let swiOnEvent = switch.rx.isOn swiOnEvent.map{ isOn in //isOn 是swiOnEvent的泛型类型，也就是 Bool return 12 //换成Int了 }.</description>
    </item>
    
    <item>
      <title>RxSwift 高阶函数用法</title>
      <link>https://leverkusen188.github.io/rxswift/rxswift_advanced_function/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/rxswift/rxswift_advanced_function/</guid>
      <description>distinctUntilChanged(). 是ObservableType的扩展方法，当 ObservableType 的Element 必须是遵循Equatable 协议的类型。 该函数返回一个ObservableType，只有Element的值发生变化时，才会抛出onNext事件。 例如 Observable.of(1,2,1,3,5,4).distinctUntilChanged() , 会抛出 1,2,1,3,5,4 而 Observable.of(1,1,3,5,4).distinctUntilChanged() , 会抛出 1,3,5,4
element(at:) 只通知 指定index的Element 的onNext事件
ignoreElements() 忽略onNext事件，只抛出 onError 和 completed事件
take(count) 只抛出序列中指定count数的事件，满足count 数后，直接抛出 completed
takeLast(count) 只抛出序列中最后的指定count数的事件。满足count 数后，直接抛出 completed
PS: 注意take系列，如果是未指定个数的事件序列，则takeLast是不生效的。
skip(count)： 跳过指定个数的事件。
delaySubscription() 在指定的时间内，无法获取到序列事件，到时间后，就能获取到事件了。
delay() 将所有信号事件 delay 指定时间后再发送。订阅者获取到的事件都是延迟后的。
PS：但对于指定个数序列事件的ObservableType，两者行为是一致的，都会延迟 指定时间后，订阅者才收到消息
debounce() 指定信号之间间隔未达到指定时差时，就会忽略前面的事件，只抛出最后一个事件。
groupBy() 可以将指定的Observable 分割成多个 字定义key的Observable。 样例代码（根据自定义的 keySelector，将 1-6的序列化的Observable 分组成 两个GroupedObservable，它们的key 就是自定义的 “奇数”和“偶数”）：
Observable.of(1,2,3,4,5,6).groupBy(keySelector: { (ele) -&amp;gt; String in return ele % 2 == 1 ?</description>
    </item>
    
    <item>
      <title>Stub 和 Mock</title>
      <link>https://leverkusen188.github.io/xctest/stub_mock/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/xctest/stub_mock/</guid>
      <description>Stub 用在修改 测试代码里出现无法预期其行为（比如返回数据）的相关函数时，将该函数的返回值用插桩方式修改为自定义的数据（修改方式可自定义，比如 在输入参数为多少时，才返回对应的字定义数据），以满足整块代码的单测需要。
下面是例子说明 (stub 实现基于 Kiwi 框架 https://github.com/kiwi-bdd/Kiwi)：
功能是接收温度和湿度参数，通过weatherForecaster 的方法计算出对应的结果，并存入数据库。
假设 resultWithTemprature 方法是无法被测试的，那么整块代码里，可以测试的是 写入数据库的代码（write函数）
@class WeatherRecorder -(void) writeResultToDatabaseWithTemprature:(NSInteger)temprature humidity:(NSInteger)humidity { id result = [self.weatherForecaster resultWithTemprature:temprature humidity:humidity]; [self write:result]; } 为了不影响单测用例，可以改写 resultWithTemprature 的行为，返回自定义的 result，来测试数据库写入代码。
[weatherForecaster stub:@selector(resultWithTemprature:humidity:) andReturn:someResult withArguments:theValue(23),theValue(50)]; mock 其实就是一个对象，它是对现有类的行为一种模拟（或是对现有接口实现的模拟），它是一种更全面更智能的 Stub。
以上面代码为例，在OC里，实际上就是将 weatherForecaster 换为自定义的mock类，从而使 resultWithTemprature 函数的行为是我们测试需要的。
样例代码：
创建 weatherForecaster 的 mock实例 id weatherForecasterMock **=** [WeatherForecaster **mock**]; [[weatherForecasterMock **should**] **receive**:**@selector**(**resultWithTemprature**:humidity**:**) andReturn**:**someResult withArguments**:**theValue(23),theValue(50)]; 然后将WeatherRecorder的 weatherForecaster 属性替换为该mock实例 [weatherRecorder stub:@selector(weatherForecaster) andReturn:weatherForecasterMock]; </description>
    </item>
    
    <item>
      <title>Swift dynamicMemberLookup</title>
      <link>https://leverkusen188.github.io/swift/swift_dynamicmemberlookup/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/swift_dynamicmemberlookup/</guid>
      <description>类或是struct声明为 @dynamicMemberLookup 后，并实现 subscript(dynamicMember:), 就可以用带 点的语法来访问对应的数据了。
实现dynamicMemberLookup 的类： @dynamicMemberLookup class TestData&amp;lt;Value&amp;gt; { var value : Value var name : String init(_ v : Value, name : String) { self.value = v self.name = name } //subscript(dynamicMember:) 只能用 String 或 KeyPath 作为参数 subscript(dynamicMember pro : String) -&amp;gt; Bool { return true } subscript&amp;lt;T&amp;gt;(dynamicMember key : KeyPath&amp;lt;Value, T&amp;gt;) -&amp;gt; T { value[keyPath: key] } } 使用方法 //使用带点语法访问数据时有优先级 let data = TestData(&amp;#34;b&amp;#34;, name: &amp;#34;haha”) //Value 泛型推导为 “b”的类型，也就是String //优先级1: 访问已有的属性，比如 TestData 的name属性。 let name = data.</description>
    </item>
    
    <item>
      <title>Swift Keypath</title>
      <link>https://leverkusen188.github.io/swift/swift-keypath/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/swift-keypath/</guid>
      <description>译自 The power of key path in Swift
Swift 最初的设计就专注于编译期尽量保证程序运行安全 以及 静态类型匹配，因此它比较缺乏类似 OC，Javascript 和ruby等运行时语言的动态特性。比如，在OC里，我们可以在运行时动态访问类对象的属性和方法，甚至改变方法的实现。
但这些动态特性的缺乏正表现出Swift的伟大，它能保证我们写出的程序运行结果更加可预料，且更可能运行不出错。不过有时候我们的代码能拥有一些动态特性也是很有帮助的。
谢天谢地，随着版本更新，Swift 开始拥有更多的动态特性，但却依然保持着静态安全类型特性。其中一种新特性就是KeyPath。本周，我们一起来看看KeyPath在Swift中是如何运作的，以及我们能用它来实现哪些强大的功能。
基础 KeyPath 本质上让我们可以用一个值来引用任意对象的特定属性。像这样，它可以被到处传递引用，在表达式中使用，甚至可以在不用知道它是哪个类的属性时，对它进行set 和get 操作。
KeyPath一般有三种类型：
KeyPath：提供只读的属性访问 WritableKeyPath: 通过特定语法，提供某个对象的可变更属性的读写权限。（该对象必须是可修改的） ReferenceWritableKeyPath: 只能对可引用的类型使用，比如类的对象实例。同上，提供该对象的某个可修改的属性的读写权限。 还有一些其他的keyPath类型，用来减少代码重复性，同时移除类型限制。不过我们暂时只关注主要的这几个类型。
让我们来看看如何使用KeyPath，以及为什么它这么有趣又功能强大。
功能速记 比如说我们要开发一个 让用户可以从各种Web上阅读文章的App，可以设计一个Article 数据模型来表示一篇文章，像这样：
struct Article { let id: UUID let source: URL let title: String let body: String } 当我们使用这种数据模型的数组时，经常需要从类里摘取单一属性出来重新生成一个新的数据数组。比如下面的例子，我们将所有id 和source数据拿出来生成新的数据数组。
let articleIDs = articles.map { $0.id } let articleSources = articles.map { $0.source } 当我们只需要使用到一个属性数据时，上面的代码是ok的。但其实我们不需要使用到闭包的所有功能，这时候使用keypath 就是比较合适的选择了。
我们可以重载Sequence 的map 方法，让它使用一个keypath来替代之前的闭包作为参数。在这个例子里，我们只对只读属性数据感兴趣，因此使用KeyPath 类型即可。使用传入的KeyPath 来生成数据返回，就像下面这样：</description>
    </item>
    
    <item>
      <title>Swift 常用UI界面设置</title>
      <link>https://leverkusen188.github.io/swiftui/swiftui_pandding/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swiftui/swiftui_pandding/</guid>
      <description>背景色设置 一个指定颜色的空视图。 color.red.ignoresSafeArea() 给一个或多个视图指定背景颜色 Color.green.overlay { //用 overlay作为背景的 多个重叠的视图 Text(&amp;#34;hello&amp;#34;).bold().foregroundColor(.white) }.frame(width: 50, height: 50) 控件位置设置 HStack 和 VStack 初始化时都有spacing参数来设定 它们里面的控件的间距。
控件的offset 属性可以设置该控件相比原布局位置的位移。
但注意其他控件并不会因为它的位置变化而自动布局（也就是 如果下面的控件不设offset时，可能会跟它重叠，比如下面这样：） padding 填充设置
func padding( _ edges: Edge.Set = .all, _ length: CGFloat? = nil ) -&amp;gt; some View 往指定的Edge 填充指定(Length) 大小的空间。edges 可以是多个。 样例代码：
//往控件的底部和右边尾部 填充20像素宽度空间 Text(&amp;#34;Text padded by 20 points on the bottom and trailing edges.&amp;#34;) .padding([.bottom, .trailing], 20) .border(.gray) </description>
    </item>
    
    <item>
      <title>Swift 数组和字典</title>
      <link>https://leverkusen188.github.io/swift/swift_array_dictionary/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swift/swift_array_dictionary/</guid>
      <description>数组和字典的遍历(enumerated) 数组和字典的遍历有两种方式。
方式1: let arr = [1,2,3] for v in arr.enumerated() { v.offset //就是下标序号 v.element //就是当前元素 } let dict = [1: “first”, 2: “second”] for v in dict.enumerated() { v.offset //就是序号 v.element //类型是 [Int: String].Element, 有key 和value属性； } 方式2: for (index, value) in arr.enumerated() { //index 是下标，value是元素 } for (index, value) in arr.enumerated() { //index 是下标，value是 [Int: String].Element } 用数组里的对象的属性贵族归组 快速创建字典 样例代码：
struct Data { var i : Int var text : String } //dic 会用 Data的 i 属性来作为key生成。 let dic = Dictionary(grouping: [ Data999(i: 1, text: &amp;#34;haha&amp;#34;), Data999(i: 1, text: &amp;#34;baa&amp;#34;), Data999(i: 4, text: &amp;#34;abnn&amp;#34;), Data999(i: 4, text: &amp;#34;erwr&amp;#34;), Data999(i: 6, text: &amp;#34;babr&amp;#34;), ], by: { $0.</description>
    </item>
    
    <item>
      <title>SwiftUI UI刷新细节</title>
      <link>https://leverkusen188.github.io/swiftui/swiftui_ui_refresh/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swiftui/swiftui_ui_refresh/</guid>
      <description>SwiftUI 的View 每次刷新都会重新创建里面的View //每次text改变引起的刷新，都会重新创建一个Text @State var text : String var body : some View { Text(text) } Body 中的ForEach 重用 Body中的ForEach 每次刷新并不会重建。 因此下面的例子里，即使多次刷新View，但ForEach对象还是最初那个，循环的次数也不会随着 increasingValue 增加而改变。
var increasingValue : Int = 1 func testLoopCount() -&amp;gt; Int { increasingValue += 1 return increasingValue } var body : some View { let loop = testLoopCount() //每次都只循环两次，因为第一次时 loop 是2 ForEach(0..&amp;lt;loop) {_ in Text(“Text”) } } </description>
    </item>
    
    <item>
      <title>SwiftUI 与 UIKit 混用</title>
      <link>https://leverkusen188.github.io/swiftui/swiftu_uikit_merge/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swiftui/swiftu_uikit_merge/</guid>
      <description>UIKit 到 SwiftUI 用实现了 UIViewRepresentable 协议的 “final class” 或是 “struct”，都可以直接作为 SwiftUI里的 View 来使用。样例代码如下： UIKit 里： final class ButtonForSwiftUI : UIViewRepresentable { var btn : UIButton = UIButton(type: .system) //当SwiftUI第一次初始化 ButtonForSwiftUI时 会调用 func makeUIView(context: Context) -&amp;gt; UIButton { btn.setTitle(&amp;#34;Button1&amp;#34;, for: .normal) btn.setTitleColor(.green, for: .normal) btn.backgroundColor = .black btn.addTarget(self, action: #selector(onClick), for: .touchUpInside) return btn } //当SwiftUI 初始化或刷新view时，如果用到了ButtonForSwiftUI，就会调用 func updateUIView(_ uiView: UIButton, context: Context) { //从 context.coordinator 来访问创建的 DoWithAction 实例 } //创建一个专门处理数据的实例 func makeCoordinator() -&amp;gt; DoWithAction { DoWithAction(self) } @objc private func onClick() { print(&amp;#34;\(self)&amp;#34;) } //声明 数据处理类 class DoWithAction { var control : ButtonForSwiftUI init(_ c : ButtonForSwiftUI) { control = c } } } SwiftUI里：</description>
    </item>
    
    <item>
      <title>SwiftUI 基础交互控件</title>
      <link>https://leverkusen188.github.io/swiftui/swiftui_common_controller/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swiftui/swiftui_common_controller/</guid>
      <description>导航页面跳转 导航页面（NavigationView）的点击（NavigationLink）后跳转至另一个页面。
样例代码：
//NavigationView 的点击事件与 NavigationLink 的跳转绑定 NavigationView { //NavigationLink 的跳转目标，也是一个View. 这里是 LandmarkDetail //创建 NavigationLink 的第二个参数，closure 返回的View 就是可点击的区域 NavigationLink(destination: LandmarkDetail(landmark: landmarkData[0])) { Text(&amp;#34;hello22&amp;#34;).background(Color.red) } //在 NavigationView 里可以创建多个 NavigationLink，跳转到不同的页面 NavigationLink(destination: LandmarkDetail(landmark: landmarkData[1])) { Text(&amp;#34;hello22&amp;#34;).background(Color.red) } } PS：页面跳转区域是该NavigationView 的区域，界面里可以有多个NavigationView，分别进行跳转。 参考截图： 弹出窗口(Present) 同 presentViewController 用一个 Binding 来控制弹出时机。
@State var showingProfile = false //当 showingProfile 为true时，触发present .sheet(isPresented: $showingProfile) { //返回 present出来的view ProfileHost() .environmentObject(self.userData) } //将 showingProfile 设为false，能dismiss对应的present view
开关控件Toggle（UISwitch） 可以绑定一个声明为 @State 的Bool属性。
//绑定声明为 @State的对象的一个bool属性，该bool属性需要设置为 @Pubished Toggle(isOn: $profile.</description>
    </item>
    
    <item>
      <title>SwiftUI 常用属性包装器</title>
      <link>https://leverkusen188.github.io/swiftui/swiftui_property_wapper/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/swiftui/swiftui_property_wapper/</guid>
      <description>@State 可监听的基本类型 可监听的的数据属性，可以触发对应view的刷新。 用于基本数据类型，比如 Bool, Int, String
样例代码：
//声明 可监听的属性 @State private var showScore = true Button(“ShowOrHide”) { //修改该属性，会触发执行 使用该属性的代码 showScore = !showScore } if showScore { ScorePlate(model: model).padding(.top, 20) } @Binding 双向绑定两个属性 将一个 @State 属性绑定到一个 @Binding 属性上。 当双方发生改变时，都会改变另一个。
struct CategoryHome: View { @State var showingProfile = false var body: some View { List { //将 self.showingProfile 设为 true 来弹出 ProfileHost Button(&amp;#34;Change&amp;#34;) { self.showingProfile = true } } .sheet(isPresented: $showingProfile) { //将 showingProfile 绑定到 ProfileHost的 shouldHide 上，然后 ProfileHost就可以控制shouldHide来做dismiss操作了。 ProfileHost(shouldHide: $showingProfile) } } } struct ProfileHost: View { @Binding var shouldHide : Bool var body: some View { Button(&amp;#34;Close&amp;#34;) { // 绑定的showingProfile 也会改为false，将当前view 给dismiss掉 self.</description>
    </item>
    
    <item>
      <title>XCTest Mork</title>
      <link>https://leverkusen188.github.io/xctest/xctest_mork/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/xctest/xctest_mork/</guid>
      <description>以网络请求场景为例 样例代码：
class NetworkManager { func loadData(from url: URL, completionHandler: @escaping (NetworkResult) -&amp;gt; Void) { let task = URLSession.shared.dataTask(with: url) { data, _, error in // Create either a .success or .failure case of a result enum let result = data.map(NetworkResult.success) ?? .failure(error) completionHandler(result) } task.resume() } } 可以由两种方法来mock数据。
创建 使用到的类的mock子类，并重写调用路径上的相关方法，来返回mock数据 // We create a partial mock by subclassing the original class class URLSessionDataTaskMock: URLSessionDataTask { private let closure: () -&amp;gt; Void init(closure: @escaping () -&amp;gt; Void) { self.</description>
    </item>
    
    <item>
      <title>XCTest 基础知识 &amp; Waiter</title>
      <link>https://leverkusen188.github.io/xctest/xctest_waiter/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/xctest/xctest_waiter/</guid>
      <description>基本知识 异步接口测试，可以用 XCTestExpectation。 测试性能，可用 measureBlock 接口。 关于XCTWaiter用法 简单来说就是通过delegate的方式把处理XCTExpectation的方法解耦，可以在delegate回调中处理超时，中断等异步测试用例的异常，根据实际需求，决定是否让case 通过，或是抛出一个错误。
样例代码：
class WeiboModelTest : XCTestCase { var model : WeiboModel? let bag = DisposeBag() let chinaCode = &amp;#34;001&amp;#34; var waiter : XCTWaiter? override func setUpWithError() throws { self.model = WeiboModel() self.waiter = XCTWaiter(delegate: self) } func testWaiter() { let expectaton1:XCTestExpectation = expectation(description: &amp;#34;Fail1&amp;#34;) DispatchQueue.global().async { Thread.sleep(forTimeInterval: 1) expectaton1.fulfill() } expectaton1.isInverted = true waiter?.wait(for: [expectaton1], timeout: 2) } func testWaiterSuccess() { let expectaton1:XCTestExpectation = expectation(description: &amp;#34;Pass&amp;#34;) DispatchQueue.</description>
    </item>
    
    <item>
      <title>一次还原ios release包的卡顿堆栈的记录</title>
      <link>https://leverkusen188.github.io/ios%E7%9B%B8%E5%85%B3/%E4%B8%80%E6%AC%A1%E8%BF%98%E5%8E%9Fios-release%E5%8C%85%E7%9A%84%E5%8D%A1%E9%A1%BF%E5%A0%86%E6%A0%88%E7%9A%84%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/ios%E7%9B%B8%E5%85%B3/%E4%B8%80%E6%AC%A1%E8%BF%98%E5%8E%9Fios-release%E5%8C%85%E7%9A%84%E5%8D%A1%E9%A1%BF%E5%A0%86%E6%A0%88%E7%9A%84%E8%AE%B0%E5%BD%95/</guid>
      <description>前提： 测试提了一个关于某个操作下会比较卡顿的问题，并上传了applog。
log初探 app内部工具的InnerToolBlockDetect 里记录了卡顿的情况并打印了对应的线程堆栈信息。 但由于测试用的是release包，因此堆栈里都是相应函数的位移地址，无法看出真正的卡顿代码。
libsystem_kernel.dylib 0x1f59140f4 mach_msg_trap + 8 libsystem_kernel.dylib 0x1f59135a0 mach_msg + 72 libdispatch.dylib 0x1f5778884 &amp;lt;redacted&amp;gt; + 500 libdispatch.dylib 0x1f5778d14 &amp;lt;redacted&amp;gt; + 52 libxpc.dylib 0x1f59d891c xpc_connection_send_message_with_reply_sync + 204 CoreMedia 0x1f93a9514 FigXPCRemoteClientSendSyncMessageCreatingReply + 36 CoreMedia 0x1f92ca884 &amp;lt;redacted&amp;gt; + 192 CoreFoundation 0x1f5d15d30 &amp;lt;redacted&amp;gt; + 192 MediaToolbox 0x1fa95459c &amp;lt;redacted&amp;gt; + 1448 MediaToolbox 0x1fa953f6c FigAssetRemoteCreateWithURL + 120 AVFoundation 0x1fbdf5bb0 &amp;lt;redacted&amp;gt; + 192 AVFoundation 0x1fbd0a874 &amp;lt;redacted&amp;gt; + 884 AVFoundation 0x1fbd033e4 &amp;lt;redacted&amp;gt; + 100 Fly-rls 0x106382da0 _ZNSt3__114__thread_proxyINS_5tupleIJNS_10unique_ptrINS_15__thread_structENS_14default_deleteIS3_EEEEZN3dji6common6WorkerC1EvEUlvE_EEEEEPvSC_ + 1355164 Fly-rls 0x106383224 _ZNSt3__114__thread_proxyINS_5tupleIJNS_10unique_ptrINS_15__thread_structENS_14default_deleteIS3_EEEEZN3dji6common6WorkerC1EvEUlvE_EEEEEPvSC_ + 1356320 Fly-rls 0x1044c5fec _mh_execute_header + 303084 Fly-rls 0x1044c5e1c _mh_execute_header + 302620 Fly-rls 0x10466c0ec _mh_execute_header + 2031852 Fly-rls 0x10466b920 _mh_execute_header + 2029856 Fly-rls 0x1044bd92c _mh_execute_header + 268588 libdispatch.</description>
    </item>
    
    <item>
      <title>国家省份城市demo 笔记心得</title>
      <link>https://leverkusen188.github.io/rxswift/citydemo/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/rxswift/citydemo/</guid>
      <description>将view的rx的ControlEvent 于 model的某个Subject（Observable 和 Observer的合体）绑定起来。而model的这个subject作为网络请求的发起者，包装一个Observable 给UI去订阅，并获取查询返回的数据用以更新UI model提供Observable 来给UI 更新，尽量保证 该Observable的Element 与View的Observer 或是 setter属性一致，这样就可以直接通过binding 来更新，而不用多余的代码。 禁止出现嵌套订阅代码，难以阅读以及 容易出现retain circle Demo下载地址</description>
    </item>
    
    <item>
      <title>基于Python &#43;Selenium的爬虫详解</title>
      <link>https://leverkusen188.github.io/python/python_selenium%E7%88%AC%E8%99%AB/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/python/python_selenium%E7%88%AC%E8%99%AB/</guid>
      <description>背景 Selenium Selenium 是一个用于web应用程序自动化测试的工具，直接运行在浏览器当中，支持chrome、firefox等主流浏览器。可以通过代码控制与页面上元素进行交互（点击、输入等），也可以获取指定元素的内容。
2.优劣
劣势：
相比于抓包→构造请求→解析返回值的爬虫，由于Selenium需要生成一个浏览器环境，所有操作（与元素交互、获取元素内容等）均需要等待页面加载完毕后才可以继续进行，所以速度相比构造请求的慢很多。
对于为了反爬做了特殊处理的展示内容，如字体加密（参考猫眼）、图片替换数字（参考自如）等，可能取不到想要的数据。
使用图片替换数字的自如：
优势：
1、不需要做复杂的抓包、构造请求、解析数据等，开发难度相对要低一些。
2、其访问参数跟使用浏览器的正常用户一模一样，访问行为也相对更像正常用户，不容易被反爬虫策略命中。
3、生成的浏览器环境可以自动运行 JS 文件，所以不用担心如何逆向混淆过的JS文件生成用作人机校验的参数，如马蜂窝酒店评论的人机校验参数_sn，网易云音乐评论的人机校验参数params、encSecKey。可以自行抓包查看。
4、如果需要抓取同一个前端页面上面来自不同后端接口的信息，如OTA酒店详情页的酒店基础信息、价格、评论等，使用Selenium可以在一次请求中同时完成对三个接口的调用，相对方便。
实现 1.环境
python3.6 + Macos
2.依赖包
Selenium
安装的时候是大写的 S ，import的时候是 小写 s。
pip install Selenium 3.浏览器驱动（webdriver）
加载浏览器环境需要下载对应的浏览器驱动，此处选择 Chrome。
下载地址：http://npm.taobao.org/mirrors/chromedriver/ ，
选择合适的版本下载解压后放在随便一个位置即可。
4.hello world
from selenium import webdriver &amp;#39;&amp;#39;&amp;#39;这里填刚刚下载的驱动的路径&amp;#39;&amp;#39;&amp;#39; path = &amp;#39;/Applications/Google Chrome.app/Contents/chromedriver&amp;#39; driver = webdriver.Chrome(executable_path=path) url = &amp;#39;http://hotel.qunar.com/city/beijing_city/&amp;#39; driver.get(url) &amp;#39;&amp;#39;&amp;#39;运行上述代码，会打开一个浏览器，并且加载去哪儿的酒店列表页&amp;#39;&amp;#39;&amp;#39; 这时候可以通过webdriver自带的一些的一些方法获取元素内容或者与元素进行交互。 #返回ID = js_block_beijing_city_7810的元素信息 hotel_info = driver.find_element_by_id(&amp;#39;js_block_beijing_city_7810&amp;#39;) print(hotel_info.text) #返回 展示在列表页的酒店信息 #同理，可以find_element_by_[class_name|name] 等，均可完成查询。 也可以通过方法 find_elements查找符合某条件的一组元素，以列表的形式返回。 #当需要查询的唯一标识带有空格时，可以使用find_elements_by_css_selector，否则会报错。 hotel_list = driver.</description>
    </item>
    
  </channel>
</rss>
