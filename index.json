[
{
	"uri": "https://leverkusen188.github.io/hugoBlog/ios%E7%9B%B8%E5%85%B3/",
	"title": "IOS相关s",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://leverkusen188.github.io/hugoBlog/",
	"title": "My New Hugo Site",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://leverkusen188.github.io/hugoBlog/ios%E7%9B%B8%E5%85%B3/swift-keypath/",
	"title": "Swift Keypath",
	"tags": [],
	"description": "",
	"content": "译自 The power of key path in Swift\nSwift 最初的设计就专注于编译期尽量保证程序运行安全 以及 静态类型匹配，因此它比较缺乏类似 OC，Javascript 和ruby等运行时语言的动态特性。比如，在OC里，我们可以在运行时动态访问类对象的属性和方法，甚至改变方法的实现。\n但这些动态特性的缺乏正表现出Swift的伟大，它能保证我们写出的程序运行结果更加可预料，且更可能运行不出错。不过有时候我们的代码能拥有一些动态特性也是很有帮助的。\n谢天谢地，随着版本更新，Swift 开始拥有更多的动态特性，但却依然保持着静态安全类型特性。其中一种新特性就是KeyPath。本周，我们一起来看看KeyPath在Swift中是如何运作的，以及我们能用它来实现哪些强大的功能。\n基础 KeyPath 本质上让我们可以用一个值来引用任意对象的特定属性。像这样，它可以被到处传递引用，在表达式中使用，甚至可以在不用知道它是哪个类的属性时，对它进行set 和get 操作。\nKeyPath一般有三种类型：\nKeyPath：提供只读的属性访问 WritableKeyPath: 通过特定语法，提供某个对象的可变更属性的读写权限。（该对象必须是可修改的） ReferenceWritableKeyPath: 只能对可引用的类型使用，比如类的对象实例。同上，提供该对象的某个可修改的属性的读写权限。 还有一些其他的keyPath类型，用来减少代码重复性，同时移除类型限制。不过我们暂时只关注主要的这几个类型。\n让我们来看看如何使用KeyPath，以及为什么它这么有趣又功能强大。\n功能速记 比如说我们要开发一个 让用户可以从各种Web上阅读文章的App，可以设计一个Article 数据模型来表示一篇文章，像这样：\nstruct Article { let id: UUID let source: URL let title: String let body: String } 当我们使用这种数据模型的数组时，经常需要从类里摘取单一属性出来重新生成一个新的数据数组。比如下面的例子，我们将所有id 和source数据拿出来生成新的数据数组。\nlet articleIDs = articles.map { $0.id } let articleSources = articles.map { $0.source } 当我们只需要使用到一个属性数据时，上面的代码是ok的。但其实我们不需要使用到闭包的所有功能，这时候使用keypath 就是比较合适的选择了。\n我们可以重载Sequence 的map 方法，让它使用一个keypath来替代之前的闭包作为参数。在这个例子里，我们只对只读属性数据感兴趣，因此使用KeyPath 类型即可。使用传入的KeyPath 来生成数据返回，就像下面这样：\nextension Sequence { func map\u0026lt;T\u0026gt;(_ keyPath: KeyPath\u0026lt;Element, T\u0026gt;) -\u0026gt; [T] { return map { $0[keyPath: keyPath] } } } 注意：Swift 5.2 以上的Sequence map函数已经支持用KeyPath作为参数了。automatically converted into functions.\n使用上面的扩展方法，我们可以很方便地将对象的单一任意属性从数组里截取出来，上面的例子代码可以修改为：\nlet articleIDs = articles.map(\\.id) let articleSources = articles.map(\\.source) 这很cool，但keypath真正的强大之处我们可以用更复杂一点的表达式体现出来，比如将数组进行排序。\n标准库已经可以将任意带有Sortable 元素的序列进行排序了，但是对于所有类型，我们都必须实现自己的排序闭包。然而，使用keypath，我们就可以很简单地使用数组元素的Comparable类型keypath来进行排序了。像上面做的那样，我们给Sequence新增一个扩展方法，将传入的keypath 转换成排序闭包返回。\nextension Sequence { func sorted\u0026lt;T: Comparable\u0026gt;(by keyPath: KeyPath\u0026lt;Element, T\u0026gt;) -\u0026gt; [Element] { return sorted { a, b in return a[keyPath: keyPath] \u0026lt; b[keyPath: keyPath] } } } 使用上面的方法，我们可以用指定的keypath来更快速和方便地对一个序列进行排序了。如果我们要开发一个 使用可排序数据列表的app，比如一个带播放列表的音乐app，我们就可以使用任何可比较的属性来对播放列表进行排序，甚至可以使用嵌套的多层属性。\nplaylist.songs.sorted(by: \\.name) playlist.songs.sorted(by: \\.dateAdded) playlist.songs.sorted(by: \\.ratings.worldWide) 像上面那样的代码就像新增了一个语法糖，对任意属性都能使用同样的排序代码，不但能让处理序列的复杂代码的可读性变得更高，也能减少重复代码。\n不需要对象实例了 适量的语法糖还是很棒的。keypath的真正强大之处在于我们可以引用任意属性却不用关心它所属的对象实例。回到上面所说的音乐主题，比如说我们开发的app要显示一个音乐列表，需要为一首音乐配置一个UITableViewCell，我们可以定一个配置信息如下：\nstruct SongCellConfigurator { func configure(_ cell: UITableViewCell, for song: Song) { cell.textLabel?.text = song.name cell.detailTextLabel?.text = song.artistName cell.imageView?.image = song.albumArtwork } } 你可以从下面的网站了解到更多关于为视图定义配置信息的知识 \u0026ldquo;Preventing views from being model aware in Swift\u0026rdquo;.\n上面代码没什么问题，但有很高的几率我们还要用同样的风格来渲染数据模型（tableview经常要显示包含标题，副标题以及图片，无论它使用的是什么类型的数据模型）我们来看看是否可以用keypath来创建一套通用配置，无论什么类型的数据模型都能使用。\n先创建一个叫 CellConfigurator 的泛型类型，当我们需要为不同的数据模型渲染不同的数据时，可以定义一组基于keypath类型的属性，每一个属性对应一个需要渲染的数据。\nstruct CellConfigurator\u0026lt;Model\u0026gt; { let titleKeyPath: KeyPath\u0026lt;Model, String\u0026gt; let subtitleKeyPath: KeyPath\u0026lt;Model, String\u0026gt; let imageKeyPath: KeyPath\u0026lt;Model, UIImage?\u0026gt; func configure(_ cell: UITableViewCell, for model: Model) { cell.textLabel?.text = model[keyPath: titleKeyPath] cell.detailTextLabel?.text = model[keyPath: subtitleKeyPath] cell.imageView?.image = model[keyPath: imageKeyPath] } } 上面方法的美妙之处在于我们可以很简单地为每个数据模型设定一个泛型CellConfigurator，只要使用keypath就可以达到目的。就像这样：\nlet songCellConfigurator = CellConfigurator\u0026lt;Song\u0026gt;( titleKeyPath: \\.name, subtitleKeyPath: \\.artistName, imageKeyPath: \\.albumArtwork ) let playlistCellConfigurator = CellConfigurator\u0026lt;Playlist\u0026gt;( titleKeyPath: \\.title, subtitleKeyPath: \\.authorName, imageKeyPath: \\.artwork ) 我们可以用闭包来创建CellConfigurator，就像基础库里的功能性函数 sort 和 map方法一样。我们可以使用keypath来实现优美的语法，我们也不用编写特定的代码来与数据模型实例直接打交道了，也让这些配置声明更加简单和易懂。\n转换为函数 到目前为止，我们只用了keypath来读取数据，现在来看看我们怎么使用keypath来动态写入数据。在各种开源代码里最常见的就像下面的例子 - 我们在ListViewController里加载渲染一个物品列表，当加载工作完成时，我们将相关数据设置给ViewController的一个属性。\nclass ListViewController { private var items = [Item]() { didSet { render() } } func loadItems() { loader.load { [weak self] items in self?.items = items } } } 我们来看看keypath是否可以让上面的语法更加简单，我们是否可以将 weak self这种经常要手动实现的东西给移除掉（使用weak self 主要是为了避免循环引用）。\n我们需要做的是将传给我们实现的闭包的数据设置给ViewController的一个属性。如果我们可以为这个属性传递一个setter函数，那是不是就更酷了？方法是我们load函数直接传入一个函数作为回调处理，这样就行的通了。\n要实现这个功能，我们需要定义一个可以将传入的可写keypath转换成 为这个keypath设定数据的闭包的函数。这次我们可以使用 ReferenceWritableKeyPath 类型，因为我们需要限定只对可引用类型来使用（不然的话我们改变的是实例数据的拷贝而不是实例本身）。传入对象实例和实例的属性keypath后，就可以自动将实例捕获为weak引用，并在调用返回的闭包后更改keypath对应的属性 - 就像这样：\nfunc setter\u0026lt;Object: AnyObject, Value\u0026gt;( for object: Object, keyPath: ReferenceWritableKeyPath\u0026lt;Object, Value\u0026gt; ) -\u0026gt; (Value) -\u0026gt; Void { return { [weak object] value in object?[keyPath: keyPath] = value } } 用上面的方法，我们就可以将之前的代码简化，去掉weak self的语法，最终得到看上去更干净的代码。\nclass ListViewController { private var items = [Item]() { didSet { render() } } func loadItems() { loader.load(then: setter(for: self, keyPath: \\.items)) } } 太酷了！如果我们将它应用在进阶的功能里，比如函数组合，那就更酷了，比如我们可以将多个setter和其他函数绑定在一起。接下来我们会更深入地探讨keypath功能，函数组合将是接下来的文章话题。\n结论 一开始，可能有点难以理解如何以及何时使用swift的keypath，认为它只是简单的语法糖而已 而忽略它的真正强大之处。能更动态地引用对象的属性是一个强大的功能，尽管闭包能经常能达到相似的功能，但简单的语法和可声明性的本质让它成为处理各种各样的数据的很棒的选择。\n作为一个比较新出的功能（Swift 4 以上），我相信随着时间的推移，技术社区里会出现关于keypath的新用法和思路，因此在以后的技术文章里我们还会回顾keypath功能。到那时，我也想听听大家关于keypath的想法 - 比如你们是否真的在使用它 或是 正在尝试着使用它？\n谢谢阅读我的文章。\n"
},
{
	"uri": "https://leverkusen188.github.io/hugoBlog/ios%E7%9B%B8%E5%85%B3/%E4%B8%80%E6%AC%A1%E8%BF%98%E5%8E%9Fios-release%E5%8C%85%E7%9A%84%E5%8D%A1%E9%A1%BF%E5%A0%86%E6%A0%88%E7%9A%84%E8%AE%B0%E5%BD%95/",
	"title": "一次还原ios release包的卡顿堆栈的记录",
	"tags": [],
	"description": "",
	"content": "前提： 测试提了一个关于某个操作下会比较卡顿的问题，并上传了applog。\nlog初探 app内部工具的InnerToolBlockDetect 里记录了卡顿的情况并打印了对应的线程堆栈信息。 但由于测试用的是release包，因此堆栈里都是相应函数的位移地址，无法看出真正的卡顿代码。\nlibsystem_kernel.dylib 0x1f59140f4 mach_msg_trap + 8 libsystem_kernel.dylib 0x1f59135a0 mach_msg + 72 libdispatch.dylib 0x1f5778884 \u0026lt;redacted\u0026gt; + 500 libdispatch.dylib 0x1f5778d14 \u0026lt;redacted\u0026gt; + 52 libxpc.dylib 0x1f59d891c xpc_connection_send_message_with_reply_sync + 204 CoreMedia 0x1f93a9514 FigXPCRemoteClientSendSyncMessageCreatingReply + 36 CoreMedia 0x1f92ca884 \u0026lt;redacted\u0026gt; + 192 CoreFoundation 0x1f5d15d30 \u0026lt;redacted\u0026gt; + 192 MediaToolbox 0x1fa95459c \u0026lt;redacted\u0026gt; + 1448 MediaToolbox 0x1fa953f6c FigAssetRemoteCreateWithURL + 120 AVFoundation 0x1fbdf5bb0 \u0026lt;redacted\u0026gt; + 192 AVFoundation 0x1fbd0a874 \u0026lt;redacted\u0026gt; + 884 AVFoundation 0x1fbd033e4 \u0026lt;redacted\u0026gt; + 100 Fly-rls 0x106382da0 _ZNSt3__114__thread_proxyINS_5tupleIJNS_10unique_ptrINS_15__thread_structENS_14default_deleteIS3_EEEEZN3dji6common6WorkerC1EvEUlvE_EEEEEPvSC_ + 1355164 Fly-rls 0x106383224 _ZNSt3__114__thread_proxyINS_5tupleIJNS_10unique_ptrINS_15__thread_structENS_14default_deleteIS3_EEEEZN3dji6common6WorkerC1EvEUlvE_EEEEEPvSC_ + 1356320 Fly-rls 0x1044c5fec _mh_execute_header + 303084 Fly-rls 0x1044c5e1c _mh_execute_header + 302620 Fly-rls 0x10466c0ec _mh_execute_header + 2031852 Fly-rls 0x10466b920 _mh_execute_header + 2029856 Fly-rls 0x1044bd92c _mh_execute_header + 268588 libdispatch.dylib 0x1f57c0a38 \u0026lt;redacted\u0026gt; + 24 libdispatch.dylib 0x1f57c17d4 \u0026lt;redacted\u0026gt; + 16 libdispatch.dylib 0x1f576f008 \u0026lt;redacted\u0026gt; + 1068 CoreFoundation 0x1f5d1432c \u0026lt;redacted\u0026gt; + 12 CoreFoundation 0x1f5d0f264 \u0026lt;redacted\u0026gt; + 1924 CoreFoundation 0x1f5d0e7c0 CFRunLoopRunSpecific + 436 GraphicsServices 0x1f7f0f79c GSEventRunModal + 104 UIKitCore 0x222813c38 UIApplicationMain + 212 Fly-rls 0x10448482c _mh_execute_header + 34860 libdyld.dylib 0x1f57d28e0 \u0026lt;redacted\u0026gt; + 4 堆栈还原 手头上有对应app包的 dysm 文件，查了一下，发现可以用 xcrun 命令来还原堆栈。比如：\nxcrun atos -o Foo.app/Foo -arch arm64 -l 0xd7000 0x0033f9bb 其中 0xd7000 是app执行文件的 运行开始内存地址，0x0033f9bb 是 对应的堆栈函数地址（比如上面的0x1044bd92c） 函数地址都已知，但不像crash的 ips文件，这里并没有列出 Fly-rls 执行文件的运行起始地址。 在 crash 的ips文件里,列出了 对应执行文件的运行时内存地址区间。\nBinary Images: 0x104144000 - 0x10922bfff Fly-dbg arm64 \u0026lt;191a2e0e899a36d2affc5183f78af174\u0026gt; /var/containers/Bundle/Application/25A26AFE-CE43-4E1C-B3E0-543BA6C28ADB/Fly-dbg.app/Fly-dbg 但我发现，main函数的入口地址 就是app运行开始地址 加上一部分位移（该位移在不同的build 包里，是不一样的）。 如：\n34 Fly-dbg 0x000000010415466c 0x104144000 + 67180 于是我便去bugly上，搜索 对应release包的crash记录，看能不能找到产生卡顿的版本的app包的 main函数位移地址。 随便搜了一条crash记录，并查看这个记录的原始 堆栈地址信息，成功找到了 位移大小（就是34860）。\nFly-rls\t0x000000010252082c 0x0000000102518000 + 34860 看，跟卡顿堆栈log 的 位移是一样的。 那么用 ** 0x10448482c** 减去 34860 就是卡顿发生那次运行的app的起始内存地址了。 算出来是 0x10447c000 然后再跑xcrun 命令就可以顺利解析出卡顿堆栈了。\nxcrun atos -o /Users/spy.liu/Downloads/_GO_Lite_Develop_697.dSYM/\\ Fly-rls.app.dSYM/Contents/Resources/DWARF/\\ Fly-rls -arch arm64 -l 0x10447c000 0x1044c5e1c 把多个堆栈地址放到一个文件里，换行隔开，可以一次解析多个堆栈。\nxcrun atos -o /Users/spy.liu/Downloads/_GO_Lite_Develop_697.dSYM/\\ Fly-rls.app.dSYM/Contents/Resources/DWARF/\\ Fly-rls -arch arm64 -l 0x10447c000 -f addresss.txt "
},
{
	"uri": "https://leverkusen188.github.io/hugoBlog/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://leverkusen188.github.io/hugoBlog/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]