[
{
	"uri": "https://leverkusen188.github.io/iosrelated/ios%E6%80%A7%E8%83%BD/",
	"title": "IOS app性能调优相关知识点",
	"tags": [],
	"description": "",
	"content": "前言 本文较长（5000字左右），建议阅读时间： 20min+\n一个iOS App的稳定性，主要决定于整体的系统架构设计，同时也不可忽略编程的细节，正所谓“千里之堤，溃于蚁穴”，一旦考虑不周，看似无关紧要的代码片段可能会带来整体软件系统的崩溃。尤其因为苹果限制了热更新机制，App本身的稳定性及容错性就显的更加重要，之前可以通过发布热补丁的方式解决线上代码问题，现在就需要在提交之前对App开发周期内的各个指标进行实时监测，尽量让问题暴漏在开发阶段，然后及时修复，减少线上出问题的几率。针对一个App的开发周期，它的稳定性指标主要有以下几个环节构成，用一个脑图表示如下：\n1 开发过程 开发过程中，主要是通过监控内存使用及泄露，CPU使用率，FPS，启动时间等指标，以及常见的UI的主线程监测，NSAssert断言等，最好能在Debug模式下，实时显示在界面上，针对出现的问题及早解决。\n内存问题 内存问题主要包括两个部分，一个是iOS中常见循环引用导致的内存泄露 ，另外就是大量数据加载及使用导致的内存警告。\nmmap 虽然苹果并没有明确每个App在运行期间可以使用的内存最大值，但是有开发者进行了实验和统计，一般在占用系统内存超过20%的时候会有内存警告，而超过50%的时候，就很容易Crash了，所以内存使用率还是尽量要少，对于数据量比较大的应用，可以采用分步加载数据的方式，或者采用mmap方式。mmap 是使用逻辑内存对磁盘文件进行映射，中间只是进行映射没有任何拷贝操作，避免了写文件的数据拷贝。 操作内存就相当于在操作文件，避免了内核空间和用户空间的频繁切换。之前在开发输入法的时候 ，词库的加载也是使用mmap方式，可以有效降低App的内存占用率，具体使用可以参考链接第一篇文章。\n循环引用 循环引用是iOS开发中经常遇到的问题，尤其对于新手来说是个头疼的问题。循环引用对App有潜在的危害，会使内存消耗过高，性能变差和Crash等，iOS常见的内存主要以下三种情况：\nDelegate 代理协议是一个最典型的场景，需要你使用弱引用来避免循环引用。ARC时代，需要将代理声明为weak是一个即好又安全的做法：\n@property (nonatomic, weak) id \u0026lt;MyCustomDelegate\u0026gt; delegate; 复制代码 NSTimer NSTimer我们开发中会用到很多，比如下面一段代码\n- (void)viewDidLoad { [super viewDidLoad]; self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(doSomeThing) userInfo:nil repeats:YES]; } - (void)doSomeThing { } - (void)dealloc { [self.timer invalidate]; self.timer = nil; } 复制代码 这是典型的循环引用，因为timer会强引用self，而self又持有了timer，所有就造成了循环引用。那有人可能会说，我使用一个weak指针，比如\n__weak typeof(self) weakSelf = self; self.mytimer = [NSTimer scheduledTimerWithTimeInterval:1 target:weakSelf selector:@selector(doSomeThing) userInfo:nil repeats:YES]; 复制代码 但是其实并没有用，因为不管是weakSelf还是strongSelf，最终在NSTimer内部都会重新生成一个新的指针指向self，这是一个强引用的指针，结果就会导致循环引用。那怎么解决呢？主要有如下三种方式：\n使用类方法 使用weakProxy 使用GCD timer 具体如何使用，我就不做具体的介绍，网上有很多可以参考。\nBlock Block的循环引用，主要是发生在ViewController中持有了block，比如：\n@property (nonatomic, copy) LFCallbackBlock callbackBlock; 复制代码 同时在对callbackBlock进行赋值的时候又调用了ViewController的方法，比如：\nself.callbackBlock = ^{ [self doSomething]; }]; 复制代码 就会发生循环引用，因为：ViewController-\u0026gt;强引用了callback-\u0026gt;强引用了ViewController，解决方法也很简单：\n__weak __typeof(self) weakSelf = self; self.callbackBlock = ^{ [weakSelf doSomething]; }]; 复制代码 原因是使用MRC管理内存时，Block的内存管理需要区分是Global(全局)、Stack(栈)还是Heap(堆)，而在使用了ARC之后，苹果自动会将所有原本应该放在栈中的Block全部放到堆中。全局的Block比较简单，凡是没有引用到Block作用域外面的参数的Block都会放到全局内存块中，在全局内存块的Block不用考虑内存管理问题。(放在全局内存块是为了在之后再次调用该Block时能快速反应，当然没有调用外部参数的Block根本不会出现内存管理问题)。\n所以Block的内存管理出现问题的，绝大部分都是在堆内存中的Block出现了问题。默认情况下，Block初始化都是在栈上的，但可能随时被收回，通过将Block类型声明为copy类型，这样对Block赋值的时候，会进行copy操作，copy到堆上，如果里面有对self的引用，则会有一个强引用的指针指向self，就会发生循环引用，如果采用weakSelf，内部不会有强类型的指针，所以可以解决循环引用问题。\n那是不是所有的block都会发生循环引用呢？其实不然，比如UIView的类方法Block动画，NSArray等的类的遍历方法，也都不会发生循环引用，因为当前控制器一般不会强引用一个类。\n其他内存问题 1 NSNotification addObserver之后，记得在dealloc里面添加remove;\n2 动画的repeat count无限大，而且也不主动停止动画，基本就等于无限循环了;\n3 forwardingTargetForSelector返回了self。\n内存解决思路： 1 通过Instruments来查看leaks\n2 集成Facebook开源的FBRetainCycleDetector\n3 集成MLeaksFinder\n具体原理及使用，可以参考链接。\nCPU使用率 CPU的使用也可以通过两种方式来查看，一种是在调试的时候Xcode会有展示，具体详细信息可以进入Instruments内查看，通过查看Instruments的time profile来定位并解决问题。另一种常见的方法是通过代码读取CPU使用率，然后显示在App的调试面板上，可以在Debug环境下显示信息，具体代码如下：\nint result; mib[0] = CTL_HW; mib[1] = HW_CPU_FREQ; length = sizeof(result); if (sysctl(mib, 2, \u0026amp;result, \u0026amp;length, NULL, 0) \u0026lt; 0) { perror(\u0026#34;getting cpu frequency\u0026#34;); } printf(\u0026#34;CPU Frequency = %u hz\\n\u0026#34;, result); 复制代码 FPS监控 目前主要使用CADisplayLink来监控FPS，CADisplayLink是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。我们在应用中创建一个新的 CADisplayLink 对象，把它添加到一个runloop中，并给它提供一个 target 和selector 在屏幕刷新的时候调用，需要注意的是添加到runloop的common mode里面，代码如下：\n- (void)setupDisplayLink { _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(linkTicks:)]; [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; } - (void)linkTicks:(CADisplayLink *)link { //执行次数 _scheduleTimes ++; //当前时间戳 if(_timestamp == 0){ _timestamp = link.timestamp; } CFTimeInterval timePassed = link.timestamp - _timestamp; if(timePassed \u0026gt;= 1.f) //fps CGFloat fps = _scheduleTimes/timePassed; printf(\u0026#34;fps:%.1f, timePassed:%f\\n\u0026#34;, fps, timePassed); } } 复制代码 启动时间 点评App里面本身就包含了很多复杂的业务，比如外卖、团购、到综和酒店等，同时还引入了很多第三方SDK比如微信、QQ、微博等，在App初始化的时候，很多SDK及业务也开始初始化，这就会拖慢应用的启动时间。 如下主要参考了今日头条iOS客户端启动速度优化\nApp的启动时间t(App总启动时间) = t1(main()之前的加载时间) + t2(main()之后的加载时间)。 t1 = 系统dylib(动态链接库)和自身App可执行文件的加载； t2 = main方法执行之后到AppDelegate类中的- (BOOL)Application:(UIApplication *)Application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。 复制代码 针对t1的优化，优化主要有如下：\n减少不必要的framework，因为动态链接比较耗时； 检查framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查； 合并或者删减一些OC类，这些我会在后续的静态检查中进行详解； 针对t2的时间优化，可以采用：\n异步初始化部分操作，比如网络，数据读取； 采用延迟加载或者懒加载某些视图，图片等的初始化操作； 对与图片展示类的App，可以将解码的图片保存到本地，下次启动时直接加载解码后的图片； 对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。 UI的主线程监测 我们都知道iOS的UI的操作一定是在主线程进行，该监测可以通过hook UIView的如下三个方法\n-setNeedsLayout， -setNeedsDisplay， -setNeedsDisplayInRect 复制代码 确保它们都是在主线程执行。子线程操作UI可能会引起什么问题，苹果说得并不清楚，但是在实际开发中，我们经常会遇到整个App的动画丢失，很大原因就是UI操作不是在主线程导致。\n2 静态分析过程 静态分析在这里，我主要介绍两方面，一个是正常的code review机制，另外一个就是代码静态检查工具\ncode review 组内的code review机制，可以参考团队之前的OpenDoc - 前端团队CodeReview制度，iOS客户端开发，会在此基础上进行一些常见手误及Crash情况的重点标记，比如：\n1 我们开发中首先都是在测试环境开发，开发时可以将测试环境的url写死到代码中，但是在提交代码的时候一定要将他改为线上环境的url，这个就可以通过gitlab中的重点比较部分字符串，给提交者一个强力的提示；\n2 其他常见Crash的重点检查，比如NSMutableString/NSMutableArray/NSMutableDictionary/NSMutableSet 等类下标越界判断保护，或者 append/insert/add nil对象的保护；\n3 ARC下的release操作，UITableViewCell返回nil，以及前面介绍的常见的循环引用等。\ncode review机制，一方面是依赖写代码者的代码习惯及质量，另一名依赖审查者的经验和细心程度，即使让多人revew，也可能会漏过一些错误，所以我们又添加了代码的静态检查。\n代码静态检查 代码静态分析(Static Program Analysis)是指在不运行程序的条件下，由代码静态分析工具自动对程序进行分析的方法. iOS常见的静态扫描工具有Clang Static Analyzer、OCLint、Infer，这些主要是用来检查可能存在的问题，还有Deploymate用来检查api的兼容性。\nClang Static Analyzer Clang Static Analyzer是一款静态代码扫描工具，专门用于针对C，C++和Objective-C的程序进行分析。已经被Xcode集成，可以直接使用Xcode进行静态代码扫描分析，Clang默认的配置主要是空指针检测，类型转换检测，空判断检测，内存泄漏检测这种等问题。如果需要更多的配置，可以使用开源的Clang项目，然后集成到自己的CI上。\nOCLint OCLint是一个强大的静态代码分析工具，可以用来提高代码质量，查找潜在的bug，主要针对 C、C++和Objective-C的静态分析。功能非常强大，而且是出自国人之手。OCLint基于 Clang 输出的抽象语法树对代码进行静态分析，支持与现有的CI集成，部署之后基本不需要维护，简单方便。\nOCLint可以发现这些问题\n可能的bug - 空的 if / else / try / catch / finally 语句 未使用的代码 - 未使用的局部变量和参数 复杂的代码 - 高圈复杂度, NPath复杂, 高NCSS 冗余代码 - 多余的if语句和无用的括号 坏味道的代码 - 过长的方法和过长的参数列表 不好的使用 - 倒逻辑和入参重新赋值 对于OCLint的与原理和部署方法，这里不做细讲解，主要是每次提交代码后，可以在打包的过程中进行代码检查，及早发现有问题的代码。当然也可以在合并代码之前执行对应的检查，如果检查不通过，不能合并代码，这样检查的力度更大。\nInfer Infer facebook开源的静态分析工具，Infer可以分析 Objective-C， Java 或者 C 代码，报告潜在的问题。Infer效率高，规模大，几分钟能扫描数千行代码； C/OC中捕捉的bug类型主要有：\n1:Resource leak 2:Memory leak 3:Null dereference 4:Premature nil termination argument 复制代码 只在 OC中捕捉的bug类型\n1:Retain cycle 2:Parameter not null checked 3:Ivar not null checked 复制代码 结论 Clang Static Analyzer和Xcode集成度更高、更好用，支持命令行形式，并且能够用于持续集成。OCLint有更多的检查规则和定制，和很多工具集成，也同样可用于持续集成。Infer效率高，规模大，几分钟能扫描数千行代码；支持增量及非增量分析；分解分析，整合输出结果。infer能将代码分解，小范围分析后再将结果整合在一起，兼顾分析的深度和速度，所以根据自己的项目特点，选择合适的检查工具对代码进行检查，减少人力review成本，保证代码质量，最大限度的避免运行错误。\n3 测试过程 前面介绍了很多指标的监测，代码静态检查，这些都是性能相关的，真正决定一个App功能稳定是否的是测试环节。测试是发布之前的最后一道卡，如果bug不能在测试中发现，那么最终就会触达用户，所以一个App的稳定性，很大程度决定它的测试过程。iOS App的测试包括以下几个层次：单元测试，UI测试，功能测试，异常测试。\n单元测试 XCTest是苹果官方提供的单元测试框架，与Xcode集成在一起，由此苹果提供了很详细的文档XCTest。\nXcode单元测试包含在一个XCTestCase的子类中。依据约束，每一个 XCTestCase 子类封装一个特殊的有关联的集合，例如一个功能、用例或者一个程序流。同时还提供了XCTestExpectation来处理异步任务的测试，以及性能测试measureBlock()，还包括很多第三方测试框架比如：KiWi，Quick，Specta等，以及常用的mock框架OCMock。\n单元测试的目的是将程序中所有的源代码，隔离成最小的可测试单元，以确保每个单元的正确性，如果每个单元都能保证正确，就能保证应用程序整体相当程度的正确性。但是在实际的操作过程中，很多公司都很难彻底执行单元测试，主要就是单元测试代码量甚至大于功能开发，比较难于维护。\n对于测试用例覆盖度多少合适这个话题，也是仁者见仁智者见智，其实一个软件覆盖度在50%以上就可以称为一个健壮的软件了，要达到70，80这些已经是非常难了，不过我们常见的一些第三方开源框架的测试用例覆盖率还是非常高的，让人咋舌。例如，AFNNetWorking的覆盖率高达87%,SDWebImage的覆盖率高达77%。\nUI测试 Xcode7中新增了UI Test测试，UI测试是模拟用户操作，进而从业务处层面测试，常用第三方库有KIF，appium。关于XCTest的UI测试，建议看看WWDC 2015的视频UI Testing in Xcode。 UI测试还有一个核心功能是UI Recording。选中一个UI测试用例，然后点击图中的小红点既可以开始UI Recoding。你会发现：随着点击模拟器，自动合成了测试代码。（通常自动合成代码后，还需要手动的去调整）\n[图片上传中\u0026hellip;(image-bce7b8-1554696366212-78)]\n功能测试 功能测试跟上述的UT和UI测试有一些相通的地方，首先针对各个模块设计的功能，测试是否达到产品的目的，通常功能测试主要是测试及产品人员，然后还需要进行专项测试，比如我们公司的云测平台，会对整个App的性能，稳定性，UI等都进行整体评测，看是否达到标准，对于大规模的活动，还需要进行服务端的压力测试，确保整个功能无异常。测试通过后，可以进行estFlight测试，到最后正式发布。\n功能测试还包括如下场景：系统兼容性测试，屏幕分辨率兼容性测试，覆盖安装测试，UI是否符合设计，消息推送等，以及前面开发过程中需要监控的内存、cpu、电量、网络流量、冷启动时间、热启动时间、存储、安装包的大小等测试。\n异常测试 异常测试主要是针对一些不常规的操作\n使用过程中的来电时及结束后，界面显示是否正常； 状态栏为两倍高度时，界面是否显示正常； 意外断电后，数据是否保存，数据是否有损害等； 设备充电时，不同电量时的App响应速度及操作流畅度等； 其他App的相互切换，前后台转换时，是否正常； 网络变化时的提示，弱网环境下的网络请求成功率等； 各种monkey的随机点击，多点触摸测试等是否正常； 更改系统时间，字体大小，语言等显示是否正常； 设备存储不够时，是否能正常操作； \u0026hellip; 异常测试有很多，App针对自身的特点，可以选择性的进行边界和异常测试，也是保证App稳定行的一个重要方面。\n4 发布及监控 因为移动App的特点，即使我们通过了各种测试，产品最终发布后，还是会遇到很多问题，比如Crash，网络失败，数据损坏，账号异常等等。针对已经发布的App，主要有一下方式保证稳定性：\n热修复 目前比较流行的热修复方案都是基于JSPatch、React Native、Weex、lua+wax。\nJSPatch能做到通过js调用和改写OC方法。最根本的原因是 Objective-C 是动态语言，OC上所有方法的调用/类的生成都通过 objective-c Runtime 在运行时进行，我们可以通过类名和方法名反射得到相应的类和方法，也可以替换某个类的方法为新的实现，还可以新注册一个类，为类添加方法。JSPatch 的原理就是：JS传递字符串给OC，OC通过 Runtime 接口调用和替换OC方法。\nReact Native 是从 Web 前端开发框架 React 延伸出来的解决方案，主要解决的问题是 Web 页面在移动端性能低的问题，React Native 让开发者可以像开发 Web 页面那样用 React 的方式开发功能，同时框架会通过 JavaScript 与 Objective-C 的通信让界面使用原生组件渲染，让开发出来的功能拥有原生App的性能和体验。\nWeex阿里开源的，基于Vue+Native的开发模式，跟RN的主要区别就在React和Vue的区别，同时在RN的基础上进行了部分性能优化，总体开发思路跟RN是比较像的。\n但是在今年上半年，苹果以安全为理由，开始拒绝有热修复功能的应用，但其实苹果拒的不是热更新，拒的是从网络下载代码并修改应用行为，苹果禁止的是“基于反射的热更新“，而不是 “基于沙盒接口的热更新”。而大部分框架（如 React Native、weex）和游戏引擎（比如 Unity、Cocos2d-x等）都属于后者，所以不在被警告范围内。而JSPatch因为在国内大部分应用来做热更新修复bug的行为，所以才回被苹果禁止。\n降级 用户使用App一段时间后，可能会遇到这样的情况：每次打开App时闪退，或者正常操作到某个界面时闪退，无法正常使用App。这样的用户体验十分糟糕，如果没有一个好的解决方案，很容易被用户删除App，导致用户量的流失。因为热更新基本不能使用，那就只能是App自身修复能力。目前常用的修复能力有：\n启动Crash的监控及修复 1 在应用起来的时候，记录flag并保存本地，启动一个定时器，比如5秒钟内，如果没有发生Crash，则认为用户操作正常，清空本地flag。\n2 下次启动，发现有flag，则表明上次启动Crash，如果flag数组越大，则说明Crash的次数越多，这样就需要对整个App进行降级处理，比如登出账号，清空Documents/Library/Caches目录下的文件。\n具体业务下的Crash及修复 针对某些具体业务Crash场景，如果是上线的前端页面引起的，可以先对前端功能进行回滚，或者隐藏入口，等修复完毕后再上线，如果是客户端的某些异常，比如数据库升迁问题，主要是进行业务数据库修复，缓存文件的删除，账号退出等操作，尽量只修复此业务的相关的数据。\n网络降级 比如点评App，本身有CIP（公司内部自己研发的）长连接，接入腾讯云的WNS长连接，UDP连接，HTTP短连接，如果CIP服务器发生问题，可以及时切换到WNS连接，或者降级到Http连接，保证网络连接的成功率。\n线上监控 Crash监控 Crash是对用户来说是最糟糕的体验，Crash日志能够记录用户闪退的崩溃日志及堆栈，进程线程信息，版本号，系统版本号，系统机型等有用信息，收集的信息越详细，越能够帮助解决崩溃，所以各大App都有自己崩溃日志收集系统，或者也可以使用开源或者付费的第三方Crash收集平台。\n端到端成功率监控 端到端监控是从客户端App发出请求时计时，到App收到数据数据的成功率，统计对象是：网络接口请求（包括H5页面加载）的成败和端到端延时情况。端到端监控SDK提供了监控上传接口，调用SDK提供的监控API可以将数据上报到监控服务器中。\n整个端到端监控的可以在多个维度上做查询端到端成功率、响应时间、访问量的查询，维度包括：返回码、网络、版本、平台、地区、运营商等。\n用户行为日志 用户行为日志，主要记录用户在使用App过程中，点击元素的时间点，浏览时长，跳转流程等，然后基于此进行用户行为分析，大部分应用的推荐算法都是基于用户行为日志来统计的。某些情况下，Crash分析需要查询用户的行为日志，获取用户使用App的流程，帮助解决Crash等其他问题。\n代码级日志 代码级别的日志，主要用来记录一个App的性能相关的数据，比如页面打开速度，内存使用率，CPU占用率，页面的帧率，网络流量，请求错误统计等，通过收集相关的上下文信息，优化App性能。\n总结 虽然现在市面上第三方平台已经很成熟，但是各大互联公司都会自己开发线上监控系统，这样保证数据安全，同时更加灵活。因为移动用户的特点，在开发测试过程中，很难完全覆盖所有用户的全部场景，有些问题也只会在特定环境下才发生，所以通过线上监控平台，通过日志回捞等机制，及时获取特定场景的上下文环境，结合数据分析，能够及时发现问题，并后续修复，提高App的稳定性。\n全文总结 本文主要从开发测试发布等流程来介绍了一个App稳定性指标及监测方法，开发阶段主要针对一些比较具体的指标，静态检查主要是扫描代码潜在问题，然后通过测试保证App功能的稳定性，线上降级主要是在尽量不发版的情况下，进行自修复，配合线上监控，信息收集，用户行为记录，方便后续问题修复及优化。本文观点是作者从事iOS开发的一些经验，希望能对你有所帮助，观点不同欢迎讨论。\n参考： 微信mars 的高性能日志模块 xlog 基于 CADisplayLink 的 FPS 指示器详解 今日头条iOS客户端启动速度优化 微信读书 iOS 性能优化总结 移动端监控体系之技术原理剖析 美团点评移动网络优化实践 iOS 启动连续闪退保护方案 微信 SQLite 数据库修复实践\n作者：美团点评点餐 链接：https://juejin.im/post/58ca0832a22b9d006418fe43 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n"
},
{
	"uri": "https://leverkusen188.github.io/iosrelated/%E6%BA%90%E7%A0%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E5%88%87%E6%8D%A2/",
	"title": "IOS 子工程 源码和二进制库 编译方式切换方案",
	"tags": [],
	"description": "",
	"content": "https://www.jianshu.com/p/a6d0f37cdc27 这个主要是用 环境变量控制 podspec 里，是使用源码还是 .a 。最终 pod install 来让主工程切换子模块的 源码和二进制编译方式。\nhttps://juejin.im/entry/5b5308c66fb9a04f932ff87e 这个好一点，需要创建私有pod，在podspec里配置 subspec；然后通过修改 主工程podfile，指定私有pod的 subspec 来切换编译方式。\n具体实施：\n为需要提供切换功能的工程配好podspec，作为local pods来管理。 pod lib create \u0026ldquo;podname\u0026rdquo;\n编写 该工程的 build 脚本，用以将该工程的 framework / .a 以及头文件等输出为二进制，以供切换编译用。 #!/bin/sh #要build的target名 TARGET_NAME=\u0026#39;BottomStatic\u0026#39; CONFIGURATION=\u0026#39;Debug\u0026#39; #${PROJECT_NAME} if [[ $1 ]] then TARGET_NAME=$1 fi UNIVERSAL_OUTPUT_FOLDER=\u0026#34;${SRCROOT}/${PROJECT_NAME}_Products/\u0026#34; UNIVERSAL_OUTPUT_FOLDER=\u0026#34;${TARGET_NAME}_Products/\u0026#34; BUILD_DIR=\u0026#34;Build/\u0026#34; BUILD_ROOT=\u0026#34;Output/\u0026#34; SRCROOT=\u0026#34;.\u0026#34; #创建输出目录，并删除之前的framework文件 mkdir -p \u0026#34;${UNIVERSAL_OUTPUT_FOLDER}\u0026#34; mkdir -p \u0026#34;${BUILD_DIR}\u0026#34; mkdir -p \u0026#34;${BUILD_ROOT}\u0026#34; rm -rf \u0026#34;${UNIVERSAL_OUTPUT_FOLDER}/${TARGET_NAME}.framework\u0026#34; #分别编译模拟器和真机的Framework xcodebuild -target \u0026#34;${TARGET_NAME}\u0026#34; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos BUILD_DIR=\u0026#34;${BUILD_DIR}\u0026#34; BUILD_ROOT=\u0026#34;${BUILD_ROOT}\u0026#34; clean build xcodebuild -target \u0026#34;${TARGET_NAME}\u0026#34; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphonesimulator BUILD_DIR=\u0026#34;${BUILD_DIR}\u0026#34; BUILD_ROOT=\u0026#34;${BUILD_ROOT}\u0026#34; clean build #拷贝framework到univer目录 cp -R \u0026#34;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${TARGET_NAME}.framework\u0026#34; \u0026#34;${UNIVERSAL_OUTPUT_FOLDER}\u0026#34; #合并framework，输出最终的framework到build目录 lipo -create -output \u0026#34;${UNIVERSAL_OUTPUT_FOLDER}/${TARGET_NAME}.framework/${TARGET_NAME}\u0026#34; \u0026#34;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${TARGET_NAME}.framework/${TARGET_NAME}\u0026#34; \u0026#34;${BUILD_DIR}/${CONFIGURATION}-iphoneos/${TARGET_NAME}.framework/${TARGET_NAME}\u0026#34; #删除编译之后生成的无关的配置文件 dir_path=\u0026#34;${UNIVERSAL_OUTPUT_FOLDER}/${TARGET_NAME}.framework/\u0026#34; for file in ls $dir_path do if [[ ${file} =~ \u0026#34;.xcconfig\u0026#34; ]] then rm -f \u0026#34;${dir_path}/${file}\u0026#34; fi done #判断build文件夹是否存在，存在则删除 if [ -d \u0026#34;${SRCROOT}/build\u0026#34; ] then rm -rf \u0026#34;${SRCROOT}/build\u0026#34; fi rm -rf \u0026#34;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator\u0026#34; \u0026#34;${BUILD_DIR}/${CONFIGURATION}-iphoneos\u0026#34; #打开合并后的文件夹 open \u0026#34;${UNIVERSAL_OUTPUT_FOLDER}\u0026#34; 直接执行 . build.sh target_name 即可。\n执行脚本，编译出framework后，修改 podspec文件。 #用环境变量控制编译方式 if ENV[\u0026#39;BINARY\u0026#39;] s.ios.vendored_framework = \u0026#39;DJIMidWare_Products/*.framework\u0026#39; else s.source_files = \u0026#39;DJIMidWare/DJIMidWare/**/*\u0026#39;, \u0026#39;DJIMidWare/DJIMidWare/*\u0026#39;, end 最后使用环境变量模式来 pod update一下这个local pods 即可。 BINARY=1 pod update BottomStatic --no-repo-update 有几点要注意一下：\n针对要切换编译模式的工程， 整个项目里其他依赖该工程的 工程，也需要配置pods来link它，而不能通过project link的模式。\n源码编译方式时，主工程跟该工程同时开发都是没问题的。如果只是修改了源码文件，直接build主工程即可体现修改；但如果新增了文件，需要 pod update一下才行\n"
},
{
	"uri": "https://leverkusen188.github.io/iosrelated/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%8A%A8%E6%80%81%E5%BA%93/",
	"title": "IOS 组件化-动态库实战",
	"tags": [],
	"description": "",
	"content": "起因\n理论功底\n动态库和静态库\n介绍\n静态库和动态库的区别\n举个例子， iOS 项目中使用 Embeded Framework\n静态库和动态库如何构建和加载\n静态库和动态库依赖关系\nXcode 项目结构\niOS 依赖管理事实上的标准\n解决问题\n制作动态库\n剖析下动态库 Framework 吧\n回过头来看 Embened Framework\nWhy Swift does not Support Staic Libraies\nCocoaPods 使用 Use_framework!\n动态库 Framework 的文件结构\n更愉快的导入文件\n资源问题\n参考\n起因\n去年，公司iOS端，之前由于所有的业务端代码都是混乱管理，造成开发有很多痛点无法单测，团队成员提交代码冲突机率大，CI配合效果差，功能性代码多端无法复用，单仓库代码量大，编译时间长 等等痛点，领导和组内多次沟通开始着手组件化开发，希望能改进这些开发中的痛点，成立组件化团队。\n组件化的方案大同小异，基础性代码封装私有库，业务组件交互交由中间件负责，项目依赖工具用iOS项目事实上的标准CocoaPods\n前期的基础性组件拆分都较为顺利，从依赖树的叶子节点开发是最合适的方案。\n随着组件抽离的越来越多，私有库的依赖体系也越来越复杂，慢慢过渡到了业务组件。业务组件用了Swift的第三方组件，用了Swift库的同学都知道必须加上use_frameworks!，这个标记是说Pod管理的依赖全部编译为动态库，然后呢我们的很多组件又依赖了诸如百度地图，微信分享等静态库，于是我在执行 pod install 报了一个没有碰见过的错误。\n1[!] The \u0026lsquo;Pods-LJA_Example\u0026rsquo;target has transitive dependencies that include static binaries:\n这就尴尬了，于是一阵疯狂的搜索google stackoverflow等，然而并没有什么卵用，而且上面催得急，根本没时间处理这些小问题 业务重构是最主要的，以至于我们的业务组件没有做到独立仓库拆分。\n直到最近终于找到了解决办法:( 主要是自己的功力不够深厚）\n理论功底\n动态库和静态库\n介绍\n首先静态库和动态库都是以二进制提供代码复用的代码库\n静态库 常见的是 .a\n动态库常见的是 .dll(windows)，.dylib(mac)，so(linux)\nframework(in Apple): Framework 是Cocoa/Cocoa Touch程序中使用的一种资源打包方式，可以将代码文件、头文件、资源文件、说明文档等集中在一起，方便开发者使用。也就是说我们的 framework其实是资源打包的方式，和静态库动态库的本质是没有关系的\n静态库和动态库的区别\n静态库: 链接时会被完整的复制到可执行文件中，所以如果两个程序都用了某个静态库，那么每个二进制可执行文件里面其实都含有这份静态库的代码\n动态库: 链接时不复制，在程序启动后用dyld加载，然后再决议符号，所以理论上动态库只用存在一份，好多个程序都可以动态链接到这个动态库上面，达到了节省内存(不是磁盘是内存中只有一份动态库)，还有另外一个好处，由于动态库并不绑定到可执行程序上，所以我们想升级这个动态库就很容易，windows和linux上面一般插件和模块机制都是这样实现的。\nBut我们的苹果爸爸在iOS平台上规定不允许存在动态库，并且所有的 IPA 都需要经过苹果爸爸的私钥加密后才能用，基本你用了动态库也会因为签名不对无法加载，(越狱和非 APP store 除外)。于是就把开发者自己开发动态库掐死在幻想中。\n直到有一天，苹果爸爸的iOS升级到了8，iOS出现了APP Extension，swift编程语言也诞生了，由于iOS主APP需要和Extension共享代码，Swift语言的机制也只能有动态库，于是苹果爸爸尴尬了，不过这难不倒我们的苹果爸爸，毕竟我是爸爸，规则是我来定，我想怎样就怎样，于是提出了一个概念Embedded Framework，这种动态库允许APP和APP Extension共享代码，但是这份动态库的生命被限定在一个APP进程内。简单点可以理解为被阉割的动态库。\n举个例子，iOS项目中使用Embeded Framework\n如果你把某个自己开发的动态库(系统的不算，毕竟苹果是爸爸)放在了Linked Frameworks and Libraries里面，程序一启动就会报Reason: Image Not Found，你只能把它放在Embeded Binaries里面才能正常使用，\n看图:\n静态库和动态库如何构建和加载\n简单点，说话的方式简单点~~\n上面的介绍貌似有点抽象啊套用在美团技术分享大会上的话就是:\n静态库: 一堆目标文件(.o/.obj)的打包体(并非二进制文件)\n动态库: 一个没有main函数的可执行文件\n这里我们来复习下C语言的基本功，编译和链接\n编译: 将我们的源代码文件编译为目标文件\n链接: 将我们的各种目标文件加上一些第三方库，和系统库链接为可执行文件。\n由于某个目标文件的符号(可以理解为变量，函数等)可能来自其他目标文件，其实链接这一步最主要的操作就是决议符号的地址。\n若符号来自静态库(本质就是.o 的集合包)或 .o，将其纳入链接产物，并确定符号地址\n若符号来自动态库，打个标记，等启动的时候再说\u0026mdash;交给dyld去加载和链接符号\n于是链接加装载就有了不同的情况\nLoad 装载：将库文件载入内存\nStatic Loading：启动时 Dynamic Loading：启动后（使用时） Link 链接：决议符号地址\nStatic Linking：构建（链接）时 Dynamic Linking：运行时（启动时或使用时） 然后组合起来就是 2 * 2 = 4 了\nStatic Loading + Static Linking\nStatic Loading + Dynamic Linking\nDynamic Loading + Dynamic Linking\nDynamic Loading + Static Linking\n第一种是纯静态库相关了\n第二种就是静态加载(启动时)，动态链接，链接时，动态库参与链接，但是这时候只是给符号打了标记告诉我这个符号来自与动态库，程序启动时，iOS或者Mac OS操作系统的dyld自动load + link。\n既然全部都是自动的。那么符号的调用方完全不知道你到底是源码还是静态库，动态库 。\n第三种收到调用dlopen + performSelector通常iOS的APP不适用这里不讨论\n第四种，没见过，个人也不是特别懂\n有需求请参看文后的程序员的自我修养一书\n静态库和动态库依赖关系\n既然有 2 种库，那么依赖关系又是 2 * 2 喽\nlibA.a dependency libB.a\nUIKit.dylib dependency Foundation.dylib\nlibA.a dependency Foundation.dylib\nMyXX.dylib dependency libA.a\n第一种 静态库互相依赖，这种情况非常常见，制作静态库的时候只需要有被依赖的静态库头文件在就能编译出来。但是这就意味者你要收到告诉使用者你的依赖关系\n幸运的是CocoaPod就是这样做的\n第二种动态库依赖动态库，两个动态库是相互隔离的具有隔离性，但是制作的静态库的时候需要被依赖动态库参与链接，但是具体的符号决议交给dyld来做。\n第三种，静态库依赖动态库，也很常见，静态库制作的时候也需要动态库参与链接，但是符号的决议交给dyld来做。\n第四种，动态库依赖静态库，这种情况就有点特殊了。首先我们设想动态库编译的时候需要静态库参与编译，但是静态库交由dyld来做符号决议，but这和我们前面说的就矛盾了啊。静态库本质是一堆.o 的打包体，首先并不是二进制可执行文件，再者你无法保证主程序把静态库参与链接共同生成二进制可执行文件。这就尴尬了。\n怎么办？\n目前的编译器的解决办法是，首先我无法保证主程序是否包含静态库，再者静态库也无法被dyld加载，那么我直接把你静态库的.o 偷过来，共同组成一个新的二进制。也被称做吸附性\n那么我有多份动态库都依赖同样的静态库，这就尴尬了，每个动态库为了保证自己的正确性会把静态库吸附进来。然后两个库包含了同样的静态库，于是问题就出现了。 看到这里想必前面出现的错误你已经能猜出来了把~_~\n后面再详细解释\n先来个总结\n可执文件（主程序或者动态库）在构建的链接阶段\n遇到静态库，吸附进来\n遇到动态库，打标记，彼此保持独\nXcode 项目结构\ntarget：对于一个产物(app,.a ,.framework)\nproject：一个项目包含多个 target\nworkspace: 一个包含多个 target\nschema: 指定了一个产物是按照何种的依赖关系，编译-链接到最终的一个产物\niOS 依赖管理事实上的标准\n这么多年，Apple的博客和文档也就告诉了我们什么是静态库什么是动态库，如何制作等。但是并没有给我们提供一系列的依赖管理工具。所以CocoaPods成了事实上的标准。\n通常CocoaPods管理的工程结构如下:\n那么当我们按下CMD + B的时候，整个项目按照先编译被依赖Pod，然后依赖其他Pod的Pod也被构建出来，最终所有的组件被编译为一个lib-Pods-XXXAPP.a被添加进项目进去。资源通过CocoaPods提供的脚本也一并被复制进去。想了解CocoaPods做了什么的读者可以参看后面的链接\n解决问题\n这么多理论功底的建立，相信我们已经能分析出来之前pod install的原因了。就是用了use_framework那么我们的所有Pod都会以动态库(Embeded Framework)的形式去构建，于是那些非开源的库(如百度地图，微信分享)如果被多个Pod依赖(组件化开发中太常见了)于是被吸附到动态库里面，所以CocoaPod直接就不让我们install成功。因为你现在的依赖管理就是错误的。\n在听取美团叶樉老师分享的时候 他们的出发点是因为要绕过苹果爸爸在iOS9以下对__text 段60M的限制使用了动态库方案，我们是因为某些swift库必须要用到(历史遗留原因)动态库。美团的做法是摘除依赖关系，自定义CocoaPods(开源的本来就是用着不爽我就改)。但是我是个小菜鸡啊。我也不会 ruby(以后会学的)，但是叶樉老师给我提了别的idea。前面我们知道 动态库和动态库是隔离性，动态库依赖静态库具有吸附性，那么我们可以自定义一个动态库把百度地图这种静态库吸附进来。对外整体呈现的是动态库特性。其他的组件依赖我们自定义的动态库，由于隔离性的存在，不会出现问题。\n制作动态库\n1 创建动态库项目这里以 wx 举例\n2 按照微信的官方文档。添加依赖库(我是因为pod install巨慢所以我直接拽进来了)\n3 将wx的PublicHeader暴露出来，注意由于我并没有使用到wx相关API所以链接器帮我们链接动态库的时候可能并不会把wx静态库吸附进来。我们手动在build Setting的other link flags加上-all_load标记\n4.在Schema里面跳转编译配置为Release，并且选择所有的CPU架构\n5 然后选择模拟器或者 Generic iOS Device 运行编译就会生成对应版本的 Framework 了。\n6.但是为了保证开发者使用的时候是真机模拟器都能正常使用，我们需要合并不同架构\n这里在Build Phases里添加以下脚本，真机和模拟器都Build一遍之后就会在工程目录下生成Products文件夹，\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nif[ \u0026ldquo;${ACTION}\u0026quot;= \u0026ldquo;build\u0026rdquo;]\nthen\nINSTALL_DIR=${SRCROOT}/Products/${PROJECT_NAME}.framework\nDEVICE_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework\nSIMULATOR_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework\nif[ -d \u0026ldquo;${INSTALL_DIR}\u0026rdquo;]\nthen\nrm -rf \u0026ldquo;${INSTALL_DIR}\u0026rdquo;\nfi\nmkdir -p \u0026ldquo;${INSTALL_DIR}\u0026rdquo;\ncp -R \u0026ldquo;${DEVICE_DIR}/\u0026rdquo;\u0026quot;${INSTALL_DIR}/\u0026rdquo;\n#ditto \u0026ldquo;${DEVICE_DIR}/Headers\u0026rdquo; \u0026ldquo;${INSTALL_DIR}/Headers\u0026rdquo;\nlipo -create \u0026ldquo;${DEVICE_DIR}/${PROJECT_NAME}\u0026rdquo;\u0026quot;${SIMULATOR_DIR}/${PROJECT_NAME}\u0026quot;-output \u0026ldquo;${INSTALL_DIR}/${PROJECT_NAME}\u0026rdquo;\nopen \u0026ldquo;${DEVICE_DIR}\u0026rdquo;\nopen \u0026ldquo;${SRCROOT}/Products\u0026rdquo;\nfi\n于是我们有了我们自己的私有动态库LJWXSDK，那么我们来验证我们之前的问题\n首先指定一个LJWXSDK.podspec这里我直接传到了我的Github上面\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nBe sure to run `pod lib lint LJPod.podspec\u0026rsquo; to ensure this is a valid spec before submitting. Any lines starting with a # are optional, but their use is encouraged To learn more about a Podspec seehttp://guides.cocoapods.org/syntax/podspec.html Pod:: Spec.newdo|s|\ns.name = \u0026lsquo;LJWXSDK\u0026rsquo;\ns.version = \u0026lsquo;0.1.0\u0026rsquo;\ns.summary = \u0026lsquo;A short description of LJWXSDK.\u0026rsquo;\ns.description = \u0026lt; \u0026lsquo;MIT\u0026rsquo;, : file =\u0026gt; \u0026lsquo;LICENSE\u0026rsquo;}\ns.author = { \u0026lsquo;ValiantCat\u0026rsquo;=\u0026gt; \u0026lsquo;519224747@qq.com\u0026rsquo;}\ns.source = { : http =\u0026gt; \u0026lsquo;http://onk2m6gtu.bkt.clouddn.com/LJWXSDK.framework.zip'}\ns.ios.deployment_target = \u0026lsquo;8.0\u0026rsquo;\ns.default_subspec = \u0026lsquo;zip\u0026rsquo;\ns.subspec \u0026lsquo;zip\u0026rsquo;do|zip|\nputs '-------------------------------------------------------------------' puts 'Notice: LJWXSDK is zip now' puts '-------------------------------------------------------------------' zip.ios.vendored_frameworks = '*.framework' end\nend\n注意上面我是把二进制压缩丢进了七牛的 oss 文件存储。毕竟免费还快。\n然后通过 pod lib create 创建了一个 pod 用来验证之前我们的传递性依赖问题，\n文件夹结构如下\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n.\n├── Example\n│ ├── LJA\n│ │ ├── Base.lproj\n│ │ │ ├── LaunchScreen.storyboard\n│ │ │ └── Main.storyboard\n│ │ ├── Images.xcassets\n│ │ │ └── AppIcon.appiconset\n│ │ │ └── Contents.json\n│ │ ├── LJA-Info.plist\n│ │ ├── LJA-Prefix.pch\n│ │ ├── LJAppDelegate.h\n│ │ ├── LJAppDelegate.m\n│ │ ├── LJViewController.h\n│ │ ├── LJViewController.m\n│ │ ├── en.lproj\n│ │ │ └── InfoPlist.strings\n│ │ └── main.m\n│ ├── LJA.xcodeproj\n│ ├── LJA.xcworkspace\n│ ├── Podfile\n│ ├── Podfile.lock\n│ ├── Pods\n│ │ ├── Headers\n│ │ ├── LJWXSDK\n│ │ │ └── LJWXSDK.framework\n│ │ │ ├── Headers\n│ │ │ │ ├── LJWXSDK.h\n│ │ │ │ ├── WXApi.h\n│ │ │ │ ├── WXApiObject.h\n│ │ │ │ └── WechatAuthSDK.h\n│ │ │ ├── Info.plist\n│ │ │ ├── LJWXSDK\n│ │ │ ├── Modules\n│ │ │ │ └── module.modulemap\n│ │ │ ├── _CodeSignature\n│ │ │ │ └── CodeResources\n│ │ │ └── read_me.txt\n│ │ ├── Local\\ Podspecs\n│ │ │ ├── LJA.podspec.json\n│ │ │ ├── LJB.podspec.json\n│ │ │ └── LJWXSDK.podspec.json\n│ │ ├── Manifest.lock\n│ │ ├── Pods.xcodeproj\n│ │ │ ├── project.pbxproj\n│ │ │ ├── project.xcworkspace\n│ │ ├── Target\\ Support\\ Files\n│ │ │ ├── LJA\n│ │ │ │ ├── Info.plist\n│ │ │ │ ├── LJA-dummy.m\n│ │ │ │ ├── LJA-prefix.pch\n│ │ │ │ ├── LJA-umbrella.h\n│ │ │ │ ├── LJA.modulemap\n│ │ │ │ └── LJA.xcconfig\n│ │ │ ├── LJB\n│ │ │ │ ├── Info.plist\n│ │ │ │ ├── LJB-dummy.m\n│ │ │ │ ├── LJB-prefix.pch\n│ │ │ │ ├── LJB-umbrella.h\n│ │ │ │ ├── LJB.modulemap\n│ │ │ │ └── LJB.xcconfig\n│ │ │ ├── Pods-LJA_Example\n│ │ │ │ ├── Info.plist\n│ │ │ │ ├── Pods-LJA_Example-acknowledgements.markdown\n│ │ │ │ ├── Pods-LJA_Example-acknowledgements.plist\n│ │ │ │ ├── Pods-LJA_Example-dummy.m\n│ │ │ │ ├── Pods-LJA_Example-frameworks.sh\n│ │ │ │ ├── Pods-LJA_Example-resources.sh\n│ │ │ │ ├── Pods-LJA_Example-umbrella.h\n│ │ │ │ ├── Pods-LJA_Example.debug.xcconfig\n│ │ │ │ ├── Pods-LJA_Example.modulemap\n│ │ │ │ └── Pods-LJA_Example.release.xcconfig\n│ │ │ └── Pods-LJA_Tests\n│ │ │ ├── Info.plist\n│ │ │ ├── Pods-LJA_Tests-acknowledgements.markdown\n│ │ │ ├── Pods-LJA_Tests-acknowledgements.plist\n│ │ │ ├── Pods-LJA_Tests-dummy.m\n│ │ │ ├── Pods-LJA_Tests-frameworks.sh\n│ │ │ ├── Pods-LJA_Tests-resources.sh\n│ │ │ ├── Pods-LJA_Tests-umbrella.h\n│ │ │ ├── Pods-LJA_Tests.debug.xcconfig\n│ │ │ ├── Pods-LJA_Tests.modulemap\n│ │ │ └── Pods-LJA_Tests.release.xcconfig\n│ │ └── libWeChatSDK\n│ │ ├── README.md\n│ │ ├── WXApi.h\n│ │ ├── WXApiObject.h\n│ │ ├── WechatAuthSDK.h\n│ │ └── libWeChatSDK.a\n├── LICENSE\n├── LJA\n│ ├── Assets\n│ └── Classes\n│ └── LJA.m\n├── LJA.podspec\n├── LJB\n│ ├── Assets\n│ └── Classes\n│ └── LJB.m\n├── LJB.podspec\n├── README.md\n└── _Pods.xcodeproj -\u0026gt; Example/Pods/Pods.xcodeproj\n测试工程我也丢在7牛上面。下载测试即可\n编译运行。完美。我们又可以愉快的和swift第三方库配合使用。\n很多人可能会问 诸如百度地图 微信这种sdk为什么官方不支持动态库版(所说的都是embeded Framework)，猜测是为了兼容更低iOS7版本吧\n很多人会觉得麻烦的要死。首先每个公司多多少少都有历史包袱，麻烦也要做，再者这是一次对基本功的补充，即便你们没有用到，但是为了学习，这篇教程所做的也值得你尝试一次。\n剖析下动态库 Framework 吧\n上述解决了我们一开始遇到的问题。but既然动态库和静态库压根就不一回事，所以里面还是有很多细节值得我们去了解的。\n回过头来看 Embened Framework\n首先我们之前记得如果一个动态库加在LinkedFrameworksand Libraies程序启动就会报ImageNotFound，如果放在EmbededBinaries里面就可以。这是为什么呢。我们拿MacoView来看下两种情况下可执行文件的细节\n其中@rpth 这个路径表示的位置可以查看Xcode中的链接路径问题\n这样我们就知道了其实加在EmbededBinaries里面的东西其实会被复制一份到xx.app里面，所以这个名字起得还是不错的直译就是嵌入的框架\nWhy Swift does not Support Staic Libraies\n造成这个的主要原因是Swift的运行时库(不等同于OC的runtime概念)，由于Swift的ABI不稳定，静态库会导致最终的目标程序中包含重复的运行库，相关可以看下最后的参考文章SwiftInFlux#static-libraries。等到我们的SwiftABI稳定之后，我们的静态库支持可能就又会出现了。当然也可能不出Swift伴随诞生的SPM(Swift，Package Manager)，可能有更好的官方的包依赖管理工具。让我们期待吧。\nCocoaPods使用Use_framework!\n既然加了Swift的第三方库之后就需要在Podfile里面加上use_framework! 那么CocoaPods就会帮我们生成动态库，但是奇怪的是，我们并没有在主工程的embeded binaries看到这个动态库，这又是什么鬼。其实是CocoaPods使用脚本帮我们加进去了。脚本位置在主工程的build Phase下的Emded Pods frameworks\n1\u0026quot;${SRCROOT}/Pods/Target Support Files/Pods-LJA_Example/Pods-LJA_Example-frameworks.sh\u0026quot;\n动态库Framework的文件结构\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n.\n├── Headers\n│ ├── LJWXSDK.h\n│ ├── WXApi.h\n│ ├── WXApiObject.h\n│ └── WechatAuthSDK.h\n├── Info.plist\n├── LJWXSDK\n├── Modules\n│ └── module.modulemap\n└── _CodeSignature\n└── CodeResources Headers 一般是头文件。非private里面的头文件都会在里面\ninfo.plist 配置信息，不深究\nModules 这个文件夹里有个module.modulemap文件，后面在讲解\n二进制文件，这就是上面提到的不带main的二进制文件了，.o 的打包体\n_codeSignature签名文件 (苹果爸爸的约束)\nmore资源文件。这里暂时没用到，所以没有 ，但是这个也是个大坑\n更愉快的导入文件\n@class，@protocol：不说了就是声明一个类，并不导入。\n#import \u0026lt;\u0026gt;, #import\u0026quot;\u0026quot;：是加强版的#include\u0026lt;\u0026gt;，#include\u0026quot;\u0026quot; 防止重复导入的。\n#import\u0026lt;\u0026gt; : 通过build setting里面中的header Search Path里面去找\n#import\u0026quot;\u0026quot; : 第一步先搜索user Header search Path再搜索 header search Path 。所以对我们的framework来说，CocoaPod帮我们加到了Header search Path目前2种导入方式都是可以支持的。\n上面的导入方式都带了 某个framework的路径\u0026quot;xx/xx.h\u0026quot; ，我们在开发自己主工程的时候会发现我们导入主工程其他类是不需要导入前缀的。 这又是怎么回事。\n看下面的配置\n目前的配置是non-recursive。如果把non去掉意思就是我可以递归的去查找某些framework下面的头文件了。 但是Xcode的效率肯定就会有影响。\n还是不建议修改的好。\n大家都知道iOS7之后多了@import，这又是什么鬼。\n简单理解这个方式叫做Module导入，好处就是使用了@import 之后不需要在project setting手动添加framework，系统会自动加载，而且效率更高。\n最主要的是swift也只能这样用。\n导入的时候系统会查找如果有模块同名的文件就会导入这个文件。如果没有CocoaPods帮我们生成一个module-umbrela.hl文件，然后就是导入的这个文件。\n回过头来看我们的framework的结构 里面有个Modules文件夹，里面有个文件module.modulemap\n1\n2\n3\n4\n5\n6\nframework module LJWXSDK {\numbrella header \u0026ldquo;LJWXSDK.h\u0026rdquo;\nexport *\nmodule * { export * }\n}\n我们可以看到其实被暴露的header就是这个文件，之前我在按照#import \u0026ldquo;/\u0026ldquo;的时候有个警告\n而且按照@import 导入的东西发现没有导入可用的头文件就是因为并没有在umbrella header的头文件中加入其他头文件。\n加入之后我们就可以完美的使用@import ，并且#import\u0026rdquo;/\u0026rdquo; 也不会报warning\n更多关于umbrella Header 参看文后参考\n资源问题\n首先我们来看常见的资源文件: 主要分为图片和其他类资源那么加载图片和加载其他资源都是怎么做的？\n1: [UIimage imageNamed:]\n2: [NSbundle bundleForclass[XXX class]]\n其实方式1去本质就是去mainBundle去拿资源，方式2从XXX所在的框架里面去拿。\n前面也说道framework只是资源的打包方式，本质上是有两种的。\n我们这个framework如果本质是静态库，那么无需改变使用方式，资源最终都会打包到Main Bundle里面\n如果我们这个framework本质是动态库，那么我们的资源就发生了变化，资源就会被存放在framework里面。所以我们需要使[NSbundle bundleForclass[XXX class]]。需要注意的是很多人为了简单，下意\n的使用self class传递，但是有可能这个self实例不在资源所属的framework。所以会出现资源加载失败。一定要谨慎使用。\n抄自： http://www.cocoachina.com/ios/20170427/19136.html\n参考\n程序员的自我修养，链接，装载 和库\niOS 里的动态库和静态库\nSystems Programming: What is the exact difference between Dynamic loading and dynamic linking?\nCocoaPods 都做了什么？\nDynamic Linking of Imported Functions in Mach-O\nOS 里的导入头文件\niOS - Umbrella Header 在 framework 中的应用\nSwiftInFlux#static-libraries\niOS 里的导入头文件\niOS - Umbrella Header 在 framework 中的应用\n@import vs #import - iOS 7\n"
},
{
	"uri": "https://leverkusen188.github.io/iosrelated/",
	"title": "IOSRelateds",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://leverkusen188.github.io/javascript/",
	"title": "Javascripts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://leverkusen188.github.io/reactnative/js_native_ui/",
	"title": "JS 使用原生UI组件",
	"tags": [],
	"description": "",
	"content": "使用原生UIView Native端： 首先创建一个RCTViewManager的子类。 @interface NativeView : RCTViewManager @end\n添加RCT_EXPORT_MODULE()宏标记导出的模块名称 RCT_EXPORT_MODULE(MyNativeView)\n实现-(UIView *)view方法，返回对应的native视图给JS\n- (UITextField*)view { UITextField * field = [UITextField new]; field.text = @\u0026#34;BBBB\u0026#34;; field.textColor = [UIColor blueColor]; field.textAlignment = UITextAlignmentCenter; return field; } JS端： 用一个js文件来导入模块。 NativeView.js import { requireNativeComponent } from \u0026#39;react-native\u0026#39;; // requireNativeComponent 自动把\u0026#39;RNTMap\u0026#39;解析为\u0026#39;RNTMapManager\u0026#39; export default requireNativeComponent(\u0026#39;MyNativeView\u0026#39;); 然后在其他js里使用即可。 import NativeView from \u0026#39;./MyNativeView\u0026#39; \u0026lt;NativeView style={{width:150, height:50, backgroundColor:\u0026#34;green\u0026#34;}}\u0026gt; \u0026lt;/NativeView\u0026gt; 封装原生属性 可以将view 方法里返回的视图的属性封装并供给JS端来设置.\n以上面代码为例，Native 端：\nRCT_EXPORT_VIEW_PROPERTY(userInteractionEnabled, BOOL) JS端：\n\u0026lt;NativeView style={{width:150, height:50, backgroundColor:\u0026#34;green\u0026#34;}} userInteractionEnabled={false}\u0026gt; \u0026lt;/NativeView\u0026gt; 那么view返回的UITextField 将无法接收点击等操作。\nJS 修改原生组件属性 为原生组件声明一个属性，在设置时，Native属性函数可以获取到 JS端设置的值。 RCT_CUSTOM_VIEW_PROPERTY(frameTest, CGRect, UITextField) { CGRect rect = [RCTConvert CGRect:json]; //json是js端传递的数据结构的字典化数据 view.frame = rect; //view就是设置属性的那个视图对象 } 在JS端，直接设置 frameTest 属性即可，注意保持传递的结构体的key 与 CGRect的一致 NativeView.propTypes = { frameTest: PropTypes.shape({ x: PropTypes.number, y: PropTypes.number, width: PropTypes.number, height: PropTypes.number, }), }; \u0026lt;NativeView style={{width:150, height:50, backgroundColor:\u0026#34;green\u0026#34;}} userInteractionEnabled={true} frameTest={{x:1.1, y:2.3, width:50, height:40}}\u0026gt; \u0026lt;/NativeView\u0026gt; 原生组件发送给JS的事件 在js使用Native组件时，如果native组件发生了事件（比如点击，滚动），需要将事件和数据传递给 JS端。 可以自定义事件，数据则是一个 Dictionary。\nNative端：\nNative端的view 返回的视图类型，需要给它新增一个 RCTBubblingEventBlock 的property。 以上面的 UITextField 为例 @interface MyUITextField : UITextField @property (nonatomic, copy) RCTBubblingEventBlock onHello; @end @implementation MyUITextField @end 然后给 NativeView 新增一个导出属性。（必须与上面那个同名） RCT_EXPORT_VIEW_PROPERTY(onHello, RCTBubblingEventBlock) 在发生事件时，调用返回视图的 onHello，并将相关数据一并给回 - (void)tapped:(UITapGestureRecognizer*)gesture { dispatch_async(dispatch_get_main_queue(), ^{ MyUITextField * field = gesture.view; if (field.onHello) { field.onHello(@{@\u0026#34;first\u0026#34;:@(12)}); } }); } JS 端：\n编写 onHello的响应函数即可 \u0026lt;NativeView style={{width:250, height:50, backgroundColor:\u0026#34;black\u0026#34;}} userInteractionEnabled={true} onHello={ (event) =\u0026gt; { console.log(\u0026#39;event data=\u0026#39;+event.nativeEvent.first) //PS：事件传递过来的event参数不会直接是Native的Dictionary，它的 nativeEvent 属性才是 }} \u0026gt; \u0026lt;/NativeView\u0026gt; 大PS：事件名必须以 “on” 开头，否则js无法响应！\n代码实例： NativeView.h NativeView.m NativeView.js Modal.js\n"
},
{
	"uri": "https://leverkusen188.github.io/",
	"title": "My New Hugo Site",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://leverkusen188.github.io/python/",
	"title": "Pythons",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://leverkusen188.github.io/python/python%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/",
	"title": "python基础环境搭建",
	"tags": [],
	"description": "",
	"content": "虚拟环境： 主要是创建一个虚拟的 python 环境，相关的第三方package会独立放在指定的目录下。 但python相关的bin文件，都是从正式环境 景象过来的。 参考：https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/\n安装虚拟环境： On macOS and Linux:\npython3 -m pip install --user virtualenv On Windows:\npy -m pip install --user virtualenv 创建虚拟环境： On macOS and Linux:\npython3 -m venv env_name On Windows:\npy -m venv env_name 进入/退出 虚拟环境： On macOS and Linux:\nsource env/bin/activate On Windows:\n.\\env\\Scripts\\activate 退出 deactivate 关于python package安装包 参考： https://python-packaging.readthedocs.io/en/latest/minimal.html\npackage文件结构和组成 用pip install安装的包，在根目录下需要有个 setup.py 文件，里面配置了 这个package的相关信息（类似cocoapods的 podspec 文件） from setuptools import setup setup(name=\u0026#39;requests1\u0026#39;, version=\u0026#39;0.1\u0026#39;, description=\u0026#39;The funniest joke in the world\u0026#39;, url=\u0026#39;http://github.com/storborg/funniest\u0026#39;, author=\u0026#39;Flying Circus\u0026#39;, author_email=\u0026#39;flyingcircus@example.com\u0026#39;, license=\u0026#39;MIT\u0026#39;, packages=[\u0026#39;requests2\u0026#39;, \u0026#39;requests1\u0026#39;, \u0026#39;requests1/sub_request\u0026#39;], zip_safe=False) 每个目录下，需要有一个 init.py 文件，里面定义了这个目录模块的相关声明，以及 其他模块的import关系。 以上面setup.py 的requests1 模块为例。 init.py: import os from .test_module import print_string from .sub_request.sub_test_module import sub_print_string test_module.py\nimport os def print_string(str): print(\u0026#39;test_module printstring={0}\u0026#39;.format(str)) package安装方法 cd 到 setup.py 同级目录下，执行\npip3 install . "
},
{
	"uri": "https://leverkusen188.github.io/reactnative/rn_optimization/",
	"title": "React Native 优化相关",
	"tags": [],
	"description": "",
	"content": "JS加载 在 react-native 执行 JS 代码之前，必须将代码加载到内存中并进行解析。如果你加载了一个 50MB 的 bundle，那么所有的 50mb 都必须被加载和解析才能被执行。RAM 格式的 bundle 则对此进行了优化，即启动时只加载 50MB 中实际需要的部分，之后再逐渐按需加载更多的包。\n使用内联引用，可以实现懒加载，降低启动时间。\n直接加载的样例代码：\nimport ModalApp from \u0026#39;./MyJS/Modal\u0026#39;; AppRegistry.registerComponent(\u0026#34;ModalApp\u0026#34;, () =\u0026gt; ModalApp); 内联引用加载:\nlet m = require(\u0026#39;./MyJS/Modal\u0026#39;).default AppRegistry.registerComponent(\u0026#34;ModalApp\u0026#34;, () =\u0026gt; m); "
},
{
	"uri": "https://leverkusen188.github.io/reactnative/js_native_communication/",
	"title": "React Native 的JS与Oc 通信",
	"tags": [],
	"description": "",
	"content": "JS 调用 OC 创建一个OC类，实现 RCTBridgeModule 协议。 H 头文件 #import \u0026lt;React/RCTBridgeModule.h\u0026gt; @interface TestObjectForJS : NSObject\u0026lt;RCTBridgeModule\u0026gt; @end M 文件 #import \u0026lt;React/RCTLog.h\u0026gt; @implementation TestObjectForJS RCT_EXPORT_MODULE(TestObject); //声明导出的模块名 //声明并实现导出的方法（实际上是类方法） RCT_EXPORT_METHOD(testFunc:(NSString *)first location:(NSString *)second) { NSString *output = [first stringByAppendingString:second]; RCTLogInfo(@\u0026#34;Pretending to create an event: %@\u0026#34;, output); } @end 在JS中调用即可。 import { NativeModules } from \u0026#39;react-native\u0026#39;; NativeModules.TestObject.testFunc(\u0026#39;11\u0026#39;, \u0026#39;22\u0026#39;) OC 给JS调用的方法支持的参数类型 RCT_EXPORT_METHOD 支持所有标准 JSON 类型，包括：\nstring (NSString) number (NSInteger, float, double, CGFloat, NSNumber) boolean (BOOL, NSNumber) array (NSArray) 可包含本列表中任意类型 object (NSDictionary) 可包含 string 类型的键和本列表中任意类型的值 function (RCTResponseSenderBlock) RCTConvert 声明的也都可以支持 以NSDate 为例： JS端, 可以传递 Date 的 getTime() (时间戳) const date = new Date(\u0026#39;1995-12-17T03:24:00\u0026#39;); NativeModules.TestObject.testFunc(\u0026#39;11\u0026#39;, \u0026#39;22\u0026#39;, date.getTime()) 也可以传递 Date的 toISOString().\nconst date = new Date(\u0026#39;1995-12-17T03:24:00\u0026#39;); NativeModules.TestObject.testFunc(\u0026#39;11\u0026#39;, \u0026#39;22\u0026#39;, date.toISOString()) 而在native端，如果是接收时间戳参数，可以用 NSNumber 或是直接用 NSDate\nRCT_EXPORT_METHOD(testFunc:(NSString *)first location:(NSString *)second time:(NSNumber*)time) { NSDate * date = [RCTConvert NSDate:time]; …… } RCT_EXPORT_METHOD(testFunc:(NSString *)first location:(NSString *)second time:(NSDate*)time) { } 如果是接收时间字符串，可以用 NSString 或是直接用 NSDate\nRCT_EXPORT_METHOD(testFunc:(NSString *)first location:(NSString *)second time:(NSString*)time) { NSDate * date = [RCTConvert NSDate:time]; } 多参数，可以用 Dictionary 来包装 JS端：\nNativeModules.TestObject.testFunc(\u0026#39;11\u0026#39;, \u0026#39;22\u0026#39;, { location: \u0026#39;4 Privet Drive, Surrey\u0026#39;, time: date.getTime(), description: \u0026#39;...\u0026#39; }) Native端：\nRCT_EXPORT_METHOD(testFunc:(NSString *)first location:(NSString *)second param:(NSDictionary*)param){ } Callback参数（由native将数据异步还给 JS） Native端，函数可以带一个 RCTResponseSenderBlock 类型的callback，将多个数据返还给 JS。\nRCT_EXPORT_METHOD(testCallback:(NSString *)first callback:(RCTResponseSenderBlock)callback) { if (callback) { callback(@[@(1),@\u0026#34;b\u0026#34;, @\u0026#34;afgg\u0026#34;]); } } PS: native端的callback只能调用一次，否则JS端会报错（如果 testCallback 声明了两个callback参数，那么一个代码分支只能调用其中一个callback）\nRCT_EXPORT_METHOD(testCallback:(NSString *)first callback:(RCTResponseSenderBlock)callback callback2:(RCTResponseErrorBlock)callback2) { BOOL b = YES; if (b) { if (callback) { callback(@[@(1),@\u0026#34;b\u0026#34;, @\u0026#34;afgg\u0026#34;]); } } else { if (callback2) { callback2([NSError errorWithDomain:@\u0026#34;hello\u0026#34; code:1001 userInfo:nil]); } } } 而在JS端，传入的callback函数可以带任意个参数，个数与 Native端传入的相同（如果JS端多出的声明参数，值会是 undefined\nNativeModules.TestObject.testCallback(\u0026#34;1\u0026#34;, (i, s, s2, i2) =\u0026gt; { console.log(\u0026#39;int=\u0026#39;+i) //int=1 console.log(\u0026#39;string=\u0026#39;+s) //string=b console.log(\u0026#39;string2=\u0026#39;+s2) //string2=afgg console.log(‘int2=\u0026#39;+s2)\t//int2=undefined }) RCTEventEmitter 事件发送器 可以在native端发送指定的事件（带有参数）给JS端。 样例代码：\nOC类要继承自 RCTEventEmitter 重写 方法来声明支持的事件id - (NSArray\u0026lt;NSString *\u0026gt; *)supportedEvents { return @[@\u0026#34;EventReminder\u0026#34;]; } native端用 sendEventWithName:body: 方法来发送事件和数据 JS端监听事件并获取数据 const eventListener = new NativeEventEmitter(NativeModules.TestObject) const listener = eventListener.addListener(\u0026#34;hello\u0026#34;, (data) =\u0026gt; { console.log(\u0026#34;hello data=\u0026#34;+data) }) //用remove 取消监听 listener.remove() 线程 React Native 在一个独立的串行 GCD 队列中调用Native的方法，但这属于实现的细节，并且可能会在将来的版本中改变。 如果要指定 native代码的执行线程，可以重写 methodQueue 方法。\n- (dispatch_queue_t)methodQueue { return dispatch_get_main_queue(); } PS：methodQueue方法会在模块被初始化的时候被执行一次，然后会被 React Native 的桥接机制保存下来。如果要重用队列，要用成员变量保存下来。\n"
},
{
	"uri": "https://leverkusen188.github.io/reactnative/",
	"title": "ReactNatives",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://leverkusen188.github.io/rxswift/rxfeedback/",
	"title": "RxFeedback 学习",
	"tags": [],
	"description": "",
	"content": " 核心功能：自定义Event的触发事件集合，以及订阅该事件触发后会修改的一个状态集对象的Observable。同时自定义 在事件触发后，对状态集对象进行数据变更。\n样例代码：\n//在下面代码中，状态集对象就是Int typealias State = Int //自定义事件是 增加和减少 enum Event { case increment case decrement } Observable.system( initialState: 0,\t//声明状态集对象的初始化值 //reduce里，是接收到 event事件后，对状态集对象进行自定义处理的代码。然后将新的状态集对象返回。 STEP 2 reduce: { (state, event) -\u0026gt; State in switch event { case .increment: return state + 1 case .decrement: return state - 1 } }, scheduler: MainScheduler.instance, feedback: //bind 传入owner对象，作为 第二个closure的首个参数返回。 //第二个closure参数作用是 自定义Event的触发时机，以及 对状态集对象Observable的订阅操作 //state就是一个 状态集对象的Observable，即 ObservableSchedulerContext\u0026lt;State\u0026gt; bind(self) { me, state -\u0026gt; Bindings\u0026lt;Event\u0026gt; in //对状态集对象Observable的订阅集合 let subscriptions = [ state.map(String.init).bind(to: me.label.rx.text) //STEP3 ] //自定义Event的触发器；这里虚构了两个button的action let events = [ me.plus.rx.tap.map { Event.increment }, //STEP 1 me.minus.rx.tap.map { Event.decrement } //STEP 1 ] return Bindings( subscriptions: subscriptions, events: events ) } ) "
},
{
	"uri": "https://leverkusen188.github.io/rxswift/rxswift_subject/",
	"title": "RxSwift 的Subject",
	"tags": [],
	"description": "",
	"content": "ReplaySubject ReplaySubject 在创建时候需要设置一个 bufferSize，表示它对于它发送过的 event 的缓存个数。 比如一个 ReplaySubject 的 bufferSize 设置为 2，它发出了 3 个 .next 的 event，那么它会将后两个（最近的两个）event 给缓存起来。此时如果有一个 subscriber 订阅了这个 ReplaySubject，那么这个 subscriber 就会立即收到前面缓存的两个.next 的 event。 如果一个 subscriber 订阅已经结束的 ReplaySubject，除了会收到缓存的 .next 的 event外，还会收到那个终结的 .error 或者 .complete 的event。 样例代码：\nlet subject = ReplaySubject\u0026lt;String\u0026gt;.create(bufferSize: 2) subject.onNext(“1”) subject.onNext(“2”) subject.onNext(“3”) //第一次订阅，会收到 2 和 3 事件 subject.subscribe(onNext: { (event) in print(event) }, onError: { (error) in print(error) }, onCompleted: { print(\u0026#34;这是一个 完成\u0026#34;) }) { print(\u0026#34;销毁了\u0026#34;) }.disposed(by: bag) subject.onCompleted() //设置ReplaySubject为完成状态 //第二次订阅，会立刻收到 2 和3事件，以及 completed事件 subject.subscribe(onNext: { (event) in print(event) }, onError: { (error) in print(error) }, onCompleted: { print(\u0026#34;完成之后的订阅完成\u0026#34;) }) { print(\u0026#34;完成之后销毁了\u0026#34;) }.disposed(by: bag) BehaviorSubject BehaviorSubject 需要通过一个默认初始值来创建 当一个订阅者来订阅它的时候，这个订阅者会立即收到 BehaviorSubjects 上一个发出的event。之后就跟正常的情况一样，它也会接收到 BehaviorSubject 之后发出的新的 event 这个地方正好区别了PublishSubject 订阅之前发出信号无法监听。 注意，如果BehaviorSubject complete了，那么再次订阅，是无法获取到上一次的next 事件的，而且再用此 Subject发送事件，也无效了，只会立刻获取到complete事件（说明 BehaviorSubject 是无buffer的）\nlet subject1 = BehaviorSubject(value: “1”) subject1.subscribe(onNext: { (event) in print(event) } , onCompleted: { print(\u0026#34;completed 1\u0026#34;) }) { print(\u0026#34;销毁了1\u0026#34;) }.disposed(by: bag) subject1.onNext(“2”) subject1.onCompleted()\t//标定该subject结束了 subject1.onNext(“3”) //因为已经结束，因此此事件发送无效 //再次订阅，也只能获取到 complete事件了 subject1.subscribe(onNext: { (event) in print(event) } , onCompleted: { print(\u0026#34;completed 2\u0026#34;) }) { print(\u0026#34;销毁了2\u0026#34;) }.disposed(by: bag) 打印结果为 1, 2, “completed 1”, \u0026ldquo;completed 2\u0026rdquo;\nPublishSubject 基本同 BehaviorSubject，只是订阅前的消息是无法获取到的。\n补充知识点： Relay 和 Subject Relay 对应Subject也有三种，Publish, Behavior, Replay Relay 只是对subject的包装，它并不遵循 ObserverType 协议，因此无法被 complete. 可以通过 accept 方法来抛出 onNext事件。\n"
},
{
	"uri": "https://leverkusen188.github.io/rxswift/rxswift_note/",
	"title": "RxSwift 笔记",
	"tags": [],
	"description": "",
	"content": "响应机制 响应机制核心是 Observable 和 ObserverType. 前者用来发送事件，使用者可以订阅（subscribe）后，监听 onNext ，onError等事件。 样例代码：\nlet switch = UISwitch! = UISwitch.init(frame: CGRect(x: 0, y: 50, width: 100, height: 40)) Let swiOnEvent = switch.rx.isOn swiOnEvent.subscribe(onNext: { booValue in print(“isOn=\\(booValue)\u0026#34;) }, onError: { i in }) Observable 转换 Observable 的 map 可以在监听到onNext 事件后，将当前Observable的 element 换成自定义的其他类型，并返回一个对应泛型的Observable。 样例代码：\nlet switch = UISwitch! = UISwitch.init(frame: CGRect(x: 0, y: 50, width: 100, height: 40)) Let swiOnEvent = switch.rx.isOn swiOnEvent.map{ isOn in //isOn 是swiOnEvent的泛型类型，也就是 Bool return 12 //换成Int了 }.subscribe(onNext: { intValue in //作为int来用了 print(\u0026#34;st=\\(intValue)\u0026#34;) } Observable 事件过滤 Observable 的filter 可以通过自定义条件来过滤发送 onNext事件，并返回一个同样泛型的Observable。\n样例代码：\nlet switch = UISwitch! = UISwitch.init(frame: CGRect(x: 0, y: 50, width: 100, height: 40)) Let swiOnEvent = switch.rx.isOn swiOnEvent.filter{ isOn in //这里转变一下条件，只有 isOn’ 是false时，该observable 才发送onNext事件 If isOn { Return false } Return true }.subscribe(onNext: { boolValue in //由于filter里，只有 isOn 为false时，才发送next事件，因此这里的boolValue 一定是false print(\u0026#34;st=\\(boolValue)\u0026#34;) } Filter 和 map 能嵌套组合使用，最后构造出自己需要的 Observable 用 filter来过滤监听到的值。 再接map 来转换Observable的泛型数据类型。\n自定义Observable. 定义并创建一个 Observable 对象，给外面用来订阅监听。 声明一个 AnyObserver对象，在 创建上面的 Observable 时，赋值后，用来抛出onNext，onError等事件和数据 样例代码： //声明和创建 Observable typealias CustomFrame = (CGPoint, CGSize) private var myPointObsevablePtr : (AnyObserver\u0026lt;CustomFrame\u0026gt;)? public lazy var myPointObsevable : Observable\u0026lt;CustomFrame\u0026gt; = { Observable\u0026lt;CustomFrame\u0026gt;.create { [weak self] (ob) -\u0026gt; Disposable in self?.myPointObsevablePtr = ob return Disposables.create() } }() //在需要的时机，抛出onNext事件 self?.myPointObsevablePtr?.onNext((position, CGSize(width: 500, height: 1000))) 然后 myPointObsevable 给外面订阅监听即可。\n"
},
{
	"uri": "https://leverkusen188.github.io/rxswift/rxswift_advanced_function/",
	"title": "RxSwift 高阶函数用法",
	"tags": [],
	"description": "",
	"content": "distinctUntilChanged(). 是ObservableType的扩展方法，当 ObservableType 的Element 必须是遵循Equatable 协议的类型。 该函数返回一个ObservableType，只有Element的值发生变化时，才会抛出onNext事件。 例如 Observable.of(1,2,1,3,5,4).distinctUntilChanged() , 会抛出 1,2,1,3,5,4 而 Observable.of(1,1,3,5,4).distinctUntilChanged() , 会抛出 1,3,5,4\nelement(at:) 只通知 指定index的Element 的onNext事件\nignoreElements() 忽略onNext事件，只抛出 onError 和 completed事件\ntake(count) 只抛出序列中指定count数的事件，满足count 数后，直接抛出 completed\ntakeLast(count) 只抛出序列中最后的指定count数的事件。满足count 数后，直接抛出 completed\nPS: 注意take系列，如果是未指定个数的事件序列，则takeLast是不生效的。\nskip(count)： 跳过指定个数的事件。\ndelaySubscription() 在指定的时间内，无法获取到序列事件，到时间后，就能获取到事件了。\ndelay() 将所有信号事件 delay 指定时间后再发送。订阅者获取到的事件都是延迟后的。\nPS：但对于指定个数序列事件的ObservableType，两者行为是一致的，都会延迟 指定时间后，订阅者才收到消息\ndebounce() 指定信号之间间隔未达到指定时差时，就会忽略前面的事件，只抛出最后一个事件。\ngroupBy() 可以将指定的Observable 分割成多个 字定义key的Observable。 样例代码（根据自定义的 keySelector，将 1-6的序列化的Observable 分组成 两个GroupedObservable，它们的key 就是自定义的 “奇数”和“偶数”）：\nObservable.of(1,2,3,4,5,6).groupBy(keySelector: { (ele) -\u0026gt; String in return ele % 2 == 1 ? “奇数” : “偶数” }).subscribe(onNext: { group in os_log(\u0026#34;groupBy key=\\(group.key)\u0026#34;) group.asObservable() .subscribe({ event in switch event { case .next(let v): os_log(\u0026#34;groupBy onNext=\\(v)\u0026#34;) default: break } }) }) flatMap() 将操作源Observable的每一个元素转换成 对应的一个Observable，然后把这些新生成的Observables 数组拍扁，变成一个 Observable 序列。 当Observable的元素也是一个Observable时，flatMap 很有用。 样例代码：\n//声明两个 Observable let subject1 = BehaviorSubject(value: \u0026#34;A\u0026#34;) let subject2 = BehaviorSubject(value: \u0026#34;a\u0026#34;) //用两个Observable 新建一个Observable序列 let variable = Observable.of(subject1, subject2) variable.asObservable() .flatMap { $0 //将序列里的Observable直接返回，也就是 subject1 和 subject2 } .subscribe(onNext: { print(\u0026#34;hhhhhhh \\($0)\u0026#34;) }) //再发送两个Observable的新值事件 subject1.onNext(\u0026#34;B\u0026#34;) subject2.onNext(\u0026#34;b\u0026#34;) PS：打印出来的应该是 AaBb\nflatMapLatest 不同于 flatMap的是，它只响应最后转换的那个Observable的事件了。 同上的代码，使用 flatMapLatest的话，打印出来的应该是 Aab\nconcatMap() 功能同flatMap，但它在转换 元素为多个Observable的Observable时，必须等待前一个Observable 完成（onCompleted），后一个Observable才能发出数据。 样例代码\nlet subject1 = BehaviorSubject(value: \u0026#34;A\u0026#34;) let subject2 = BehaviorSubject(value: \u0026#34;a\u0026#34;) let variable = Observable.of(subject1, subject2) variable.asObservable() .concatMap { $0 } .subscribe(onNext: { print(\u0026#34;hhhhhhh \\($0)\u0026#34;) }) subject1.onNext(\u0026#34;B\u0026#34;) subject1.onCompleted() //在subject1 完成后，才开始接收到subject2的事件 print(“Subject1 Completed”) subject2.onNext(\u0026#34;b\u0026#34;) PS：打印结果应该是 A B “Subject1 Completed” a b\nbuffer() 返回一个 Observable\u0026lt;[Element]\u0026gt;, 在原Observable的元素达到指定count 或是 设定的timeSpan 到时了，都会触发一次事件。该事件会将一个 array（count是这段时间内接收到的原Observable的元素个数）。 如果是满足count个数的事件，那么array的元素个数就是指定的count；如果是到期了，则array的元素个数是该时间内接收到的原Observable的元素个数。 样例代码\nvar subject = PublishSubject\u0026lt;String\u0026gt;() subject.buffer(timeSpan: RxTimeInterval.seconds(1), count: 2, scheduler: MainScheduler.instance) .subscribe(onNext: { (event) in os_log(\u0026#34;\\(flag) buffer=\\(event)\u0026#34;) }) .disposed(by: bag) subject.onNext(\u0026#34;111\u0026#34;) subject.onNext(\u0026#34;222\u0026#34;) DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 1.5) { subject.onNext(\u0026#34;444\u0026#34;) } PS：打印结果应该是 [111,222] (第一次，满足了指定count条件) 然后一秒后 [], （这一次，timeSpan到期了，但原Observable 没有发送事件） 再过1秒后 [444] （这一次，也是timeSpan到期，原Observable 发送了一个 444）\nwindow() 返回一个 Observable\u0026lt;Observable\u0026gt;\ntimeSpan 指定该Observable发送的事件最大间隔。count指定 收到的作为Element的 Observable所能发送的最大事件个数。 一旦timespan到期，或是 作为Element的Observable 已发送了count个事件，原Observable都会重新发送一个Observable过来，而上一个则会 Completed。 样例代码：\nsubject = PublishSubject\u0026lt;String\u0026gt;() subject.window(timeSpan: RxTimeInterval.seconds(1), count: 2, scheduler: MainScheduler.instance) .subscribe(onNext: { (event) in os_log(\u0026#34;get window event\u0026#34;) event.subscribe(onNext: { os_log(\u0026#34;\\(flag) window=\\($0)\u0026#34;) },onCompleted: { os_log(\u0026#34;\\(flag) subwindow completed\u0026#34;) }).disposed(by: bag) },onCompleted: { os_log(\u0026#34;\\(flag) window completed\u0026#34;) }) .disposed(by: bag) //subject 会先发送第一个Observable，该Observable 会发送 111， 222 两个事件，然后completed subject.onNext(\u0026#34;111\u0026#34;) subject.onNext(\u0026#34;222\u0026#34;) //接着发送第二个Observable，该Observable会发送 333 这个事件，由于指定的timeSpan 1秒内，原Observable（subject）没有其他事件，则该Observable会再1秒后complete subject.onNext(“333”) DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 1.5) { //第三个Observable会在 1秒时发送，接着 0.5秒后收到subject的 444消息。 subject.onNext(“444”) } Log输出如下： 2022-04-25 15:26:21.78 get window event 2022-04-25 15:26:21.78 RxSwiftGaojie window=111 2022-04-25 15:26:21.78 RxSwiftGaojie window=222 2022-04-25 15:26:21.78 RxSwiftGaojie subwindow completed //满足count个数，该Observable 会complete 2022-04-25 15:26:21.78 get window event 2022-04-25 15:26:21.78 RxSwiftGaojie window=333 2022-04-25 15:26:22.78 RxSwiftGaojie subwindow completed //第二个Observable 1秒内只收到1个事件，到期了会complete 2022-04-25 15:26:22.78 get window event 2022-04-25 15:26:23.42 RxSwiftGaojie window=444 //第三个Observable在 0.5秒后收到了444消息 2022-04-25 15:26:23.78 RxSwiftGaojie subwindow completed //第三个Observable 同第二个，到期了自动complete\ncombineLatest() 可以将多个Observable的事件整合为一个Observable 必须每个Observable都有onNext事件，才会触发整合Observable的 onNext。 completed事件同上，所有Observable都触发了complete才行。 Error 只要其中一个 Observable触发了，就能触发整合Observable的error 样例代码：\nlet comSub = BehaviorSubject(value: 1) let comSub2 = PublishSubject\u0026lt;String\u0026gt;() Observable.combineLatest(comSub, comSub2) .subscribe({ event in switch event { case .next(let i, let s): print(\u0026#34;\\(s)\u0026#34;) break case .completed: break case .error(let e): break default: break } }) comSub2.onNext(“A”) //会触发整合Observable的next事件，元素值分别为两个subject的最后一次元素值 comSub.onCompleted() comSub2.onCompleted() //触发整合Observable的complete事件 zip() 将多个Observable 整合为一个多参数的Observable。 打包的Observable 必须事件个数完全一样，才会触发新Observable的事件，会将所有Observable相同index的事件打包触发。 样例代码：\nlet zip1 = BehaviorSubject(value: 1) let zip2 = BehaviorSubject(value: \u0026#34;a\u0026#34;) Observable.zip(zip1, zip2) .subscribe(onNext: { (i, s) in print(\u0026#34;zip 1=\\(i) 2=\\(s)\u0026#34;) }, onCompleted: { print(\u0026#34;\u0026#34;) }).dispose() zip1.onNext(2) zip1.onNext(3) //zip1 有三个事件了，但zip2 只有一个，不会触发onNext zip2.onNext(\u0026#34;b\u0026#34;) //zip2 的第二个事件，与 zip1的第二个一起打包触发 zip1.onCompleted() zip2.onCompleted() 那么打印出来的应该是 zip 1=1 2=a zip 1=2 2=b\n"
},
{
	"uri": "https://leverkusen188.github.io/rxswift/",
	"title": "RxSwifts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://leverkusen188.github.io/swift/string_custom_format/",
	"title": "String 自定义格式化",
	"tags": [],
	"description": "",
	"content": "比如一个自定义结构，在打印时，print 会按照 Swift struct 的默认格式打印 Person 值\nstruct Person { let name: String let place: String } print(\u0026#34;Hi, \\(Person(name: \u0026#34;Geralt\u0026#34;, place: \u0026#34;Rivia\u0026#34;))\u0026#34;) 如果要自定义Person的打印结果，可以 扩展String.StringInterpolation，样例代码：\nextension String.StringInterpolation { mutating func appendInterpolation(_ person: Person) { // 调用的 `appendLiteral(_ literal: String)` 接受 `String` 参数 appendLiteral(\u0026#34;\\(person.name) of \\(person.place)\u0026#34;) } } 这样，打印出来的Person会变成\nprint(\u0026#34;Hi, \\(Person(name: \u0026#34;Geralt\u0026#34;, place: \u0026#34;Rivia\u0026#34;))\u0026#34;) Hi, Geralt of Rivia\n"
},
{
	"uri": "https://leverkusen188.github.io/xctest/stub_mock/",
	"title": "Stub 和 Mock",
	"tags": [],
	"description": "",
	"content": "Stub 用在修改 测试代码里出现无法预期其行为（比如返回数据）的相关函数时，将该函数的返回值用插桩方式修改为自定义的数据（修改方式可自定义，比如 在输入参数为多少时，才返回对应的字定义数据），以满足整块代码的单测需要。\n下面是例子说明 (stub 实现基于 Kiwi 框架 https://github.com/kiwi-bdd/Kiwi)：\n功能是接收温度和湿度参数，通过weatherForecaster 的方法计算出对应的结果，并存入数据库。\n假设 resultWithTemprature 方法是无法被测试的，那么整块代码里，可以测试的是 写入数据库的代码（write函数）\n@class WeatherRecorder -(void) writeResultToDatabaseWithTemprature:(NSInteger)temprature humidity:(NSInteger)humidity { id result = [self.weatherForecaster resultWithTemprature:temprature humidity:humidity]; [self write:result]; } 为了不影响单测用例，可以改写 resultWithTemprature 的行为，返回自定义的 result，来测试数据库写入代码。\n[weatherForecaster stub:@selector(resultWithTemprature:humidity:) andReturn:someResult withArguments:theValue(23),theValue(50)]; mock 其实就是一个对象，它是对现有类的行为一种模拟（或是对现有接口实现的模拟），它是一种更全面更智能的 Stub。\n以上面代码为例，在OC里，实际上就是将 weatherForecaster 换为自定义的mock类，从而使 resultWithTemprature 函数的行为是我们测试需要的。\n样例代码：\n创建 weatherForecaster 的 mock实例 id weatherForecasterMock **=** [WeatherForecaster **mock**]; [[weatherForecasterMock **should**] **receive**:**@selector**(**resultWithTemprature**:humidity**:**) andReturn**:**someResult withArguments**:**theValue(23),theValue(50)]; 然后将WeatherRecorder的 weatherForecaster 属性替换为该mock实例 [weatherRecorder stub:@selector(weatherForecaster) andReturn:weatherForecasterMock]; "
},
{
	"uri": "https://leverkusen188.github.io/swift/swift_dynamicmemberlookup/",
	"title": "Swift dynamicMemberLookup",
	"tags": [],
	"description": "",
	"content": " 类或是struct声明为 @dynamicMemberLookup 后，并实现 subscript(dynamicMember:), 就可以用带 点的语法来访问对应的数据了。\n实现dynamicMemberLookup 的类： @dynamicMemberLookup class TestData\u0026lt;Value\u0026gt; { var value : Value var name : String init(_ v : Value, name : String) { self.value = v self.name = name } //subscript(dynamicMember:) 只能用 String 或 KeyPath 作为参数 subscript(dynamicMember pro : String) -\u0026gt; Bool { return true } subscript\u0026lt;T\u0026gt;(dynamicMember key : KeyPath\u0026lt;Value, T\u0026gt;) -\u0026gt; T { value[keyPath: key] } } 使用方法 //使用带点语法访问数据时有优先级 let data = TestData(\u0026#34;b\u0026#34;, name: \u0026#34;haha”) //Value 泛型推导为 “b”的类型，也就是String //优先级1: 访问已有的属性，比如 TestData 的name属性。 let name = data.name //优先级2: 访问 keypath对应的 Value类型所拥有的属性。 这里Value是String，那么count 访问的就是 value.count let count = data.count //值为1 //优先级3: 访问 String类型参数的subscript let value = data.haha //返回 true 总结： dynamicMemberLookup 是否安全？ 是安全的。 如果用String 来访问，那么在实现的 subscript 里确保了返回数据是安全的。 如果用keyPath 访问，不存在的keyPath 无法通过编译。\n可以声明多个 相同参数类型，但不同返回值的subscript。编译时通过返回值来区分调用哪个subscript let b : Bool = data.haha let c : String = data.haha\n不能给已有类和结构添加 dynamicMemberLookup 功能\n"
},
{
	"uri": "https://leverkusen188.github.io/swift/swift-keypath/",
	"title": "Swift Keypath",
	"tags": [],
	"description": "",
	"content": "译自 The power of key path in Swift\nSwift 最初的设计就专注于编译期尽量保证程序运行安全 以及 静态类型匹配，因此它比较缺乏类似 OC，Javascript 和ruby等运行时语言的动态特性。比如，在OC里，我们可以在运行时动态访问类对象的属性和方法，甚至改变方法的实现。\n但这些动态特性的缺乏正表现出Swift的伟大，它能保证我们写出的程序运行结果更加可预料，且更可能运行不出错。不过有时候我们的代码能拥有一些动态特性也是很有帮助的。\n谢天谢地，随着版本更新，Swift 开始拥有更多的动态特性，但却依然保持着静态安全类型特性。其中一种新特性就是KeyPath。本周，我们一起来看看KeyPath在Swift中是如何运作的，以及我们能用它来实现哪些强大的功能。\n基础 KeyPath 本质上让我们可以用一个值来引用任意对象的特定属性。像这样，它可以被到处传递引用，在表达式中使用，甚至可以在不用知道它是哪个类的属性时，对它进行set 和get 操作。\nKeyPath一般有三种类型：\nKeyPath：提供只读的属性访问 WritableKeyPath: 通过特定语法，提供某个对象的可变更属性的读写权限。（该对象必须是可修改的） ReferenceWritableKeyPath: 只能对可引用的类型使用，比如类的对象实例。同上，提供该对象的某个可修改的属性的读写权限。 还有一些其他的keyPath类型，用来减少代码重复性，同时移除类型限制。不过我们暂时只关注主要的这几个类型。\n让我们来看看如何使用KeyPath，以及为什么它这么有趣又功能强大。\n功能速记 比如说我们要开发一个 让用户可以从各种Web上阅读文章的App，可以设计一个Article 数据模型来表示一篇文章，像这样：\nstruct Article { let id: UUID let source: URL let title: String let body: String } 当我们使用这种数据模型的数组时，经常需要从类里摘取单一属性出来重新生成一个新的数据数组。比如下面的例子，我们将所有id 和source数据拿出来生成新的数据数组。\nlet articleIDs = articles.map { $0.id } let articleSources = articles.map { $0.source } 当我们只需要使用到一个属性数据时，上面的代码是ok的。但其实我们不需要使用到闭包的所有功能，这时候使用keypath 就是比较合适的选择了。\n我们可以重载Sequence 的map 方法，让它使用一个keypath来替代之前的闭包作为参数。在这个例子里，我们只对只读属性数据感兴趣，因此使用KeyPath 类型即可。使用传入的KeyPath 来生成数据返回，就像下面这样：\nextension Sequence { func map\u0026lt;T\u0026gt;(_ keyPath: KeyPath\u0026lt;Element, T\u0026gt;) -\u0026gt; [T] { return map { $0[keyPath: keyPath] } } } 注意：Swift 5.2 以上的Sequence map函数已经支持用KeyPath作为参数了。automatically converted into functions.\n使用上面的扩展方法，我们可以很方便地将对象的单一任意属性从数组里截取出来，上面的例子代码可以修改为：\nlet articleIDs = articles.map(\\.id) let articleSources = articles.map(\\.source) 这很cool，但keypath真正的强大之处我们可以用更复杂一点的表达式体现出来，比如将数组进行排序。\n标准库已经可以将任意带有Sortable 元素的序列进行排序了，但是对于所有类型，我们都必须实现自己的排序闭包。然而，使用keypath，我们就可以很简单地使用数组元素的Comparable类型keypath来进行排序了。像上面做的那样，我们给Sequence新增一个扩展方法，将传入的keypath 转换成排序闭包返回。\nextension Sequence { func sorted\u0026lt;T: Comparable\u0026gt;(by keyPath: KeyPath\u0026lt;Element, T\u0026gt;) -\u0026gt; [Element] { return sorted { a, b in return a[keyPath: keyPath] \u0026lt; b[keyPath: keyPath] } } } 使用上面的方法，我们可以用指定的keypath来更快速和方便地对一个序列进行排序了。如果我们要开发一个 使用可排序数据列表的app，比如一个带播放列表的音乐app，我们就可以使用任何可比较的属性来对播放列表进行排序，甚至可以使用嵌套的多层属性。\nplaylist.songs.sorted(by: \\.name) playlist.songs.sorted(by: \\.dateAdded) playlist.songs.sorted(by: \\.ratings.worldWide) 像上面那样的代码就像新增了一个语法糖，对任意属性都能使用同样的排序代码，不但能让处理序列的复杂代码的可读性变得更高，也能减少重复代码。\n不需要对象实例了 适量的语法糖还是很棒的。keypath的真正强大之处在于我们可以引用任意属性却不用关心它所属的对象实例。回到上面所说的音乐主题，比如说我们开发的app要显示一个音乐列表，需要为一首音乐配置一个UITableViewCell，我们可以定一个配置信息如下：\nstruct SongCellConfigurator { func configure(_ cell: UITableViewCell, for song: Song) { cell.textLabel?.text = song.name cell.detailTextLabel?.text = song.artistName cell.imageView?.image = song.albumArtwork } } 你可以从下面的网站了解到更多关于为视图定义配置信息的知识 \u0026ldquo;Preventing views from being model aware in Swift\u0026rdquo;.\n上面代码没什么问题，但有很高的几率我们还要用同样的风格来渲染数据模型（tableview经常要显示包含标题，副标题以及图片，无论它使用的是什么类型的数据模型）我们来看看是否可以用keypath来创建一套通用配置，无论什么类型的数据模型都能使用。\n先创建一个叫 CellConfigurator 的泛型类型，当我们需要为不同的数据模型渲染不同的数据时，可以定义一组基于keypath类型的属性，每一个属性对应一个需要渲染的数据。\nstruct CellConfigurator\u0026lt;Model\u0026gt; { let titleKeyPath: KeyPath\u0026lt;Model, String\u0026gt; let subtitleKeyPath: KeyPath\u0026lt;Model, String\u0026gt; let imageKeyPath: KeyPath\u0026lt;Model, UIImage?\u0026gt; func configure(_ cell: UITableViewCell, for model: Model) { cell.textLabel?.text = model[keyPath: titleKeyPath] cell.detailTextLabel?.text = model[keyPath: subtitleKeyPath] cell.imageView?.image = model[keyPath: imageKeyPath] } } 上面方法的美妙之处在于我们可以很简单地为每个数据模型设定一个泛型CellConfigurator，只要使用keypath就可以达到目的。就像这样：\nlet songCellConfigurator = CellConfigurator\u0026lt;Song\u0026gt;( titleKeyPath: \\.name, subtitleKeyPath: \\.artistName, imageKeyPath: \\.albumArtwork ) let playlistCellConfigurator = CellConfigurator\u0026lt;Playlist\u0026gt;( titleKeyPath: \\.title, subtitleKeyPath: \\.authorName, imageKeyPath: \\.artwork ) 我们可以用闭包来创建CellConfigurator，就像基础库里的功能性函数 sort 和 map方法一样。我们可以使用keypath来实现优美的语法，我们也不用编写特定的代码来与数据模型实例直接打交道了，也让这些配置声明更加简单和易懂。\n转换为函数 到目前为止，我们只用了keypath来读取数据，现在来看看我们怎么使用keypath来动态写入数据。在各种开源代码里最常见的就像下面的例子 - 我们在ListViewController里加载渲染一个物品列表，当加载工作完成时，我们将相关数据设置给ViewController的一个属性。\nclass ListViewController { private var items = [Item]() { didSet { render() } } func loadItems() { loader.load { [weak self] items in self?.items = items } } } 我们来看看keypath是否可以让上面的语法更加简单，我们是否可以将 weak self这种经常要手动实现的东西给移除掉（使用weak self 主要是为了避免循环引用）。\n我们需要做的是将传给我们实现的闭包的数据设置给ViewController的一个属性。如果我们可以为这个属性传递一个setter函数，那是不是就更酷了？方法是我们load函数直接传入一个函数作为回调处理，这样就行的通了。\n要实现这个功能，我们需要定义一个可以将传入的可写keypath转换成 为这个keypath设定数据的闭包的函数。这次我们可以使用 ReferenceWritableKeyPath 类型，因为我们需要限定只对可引用类型来使用（不然的话我们改变的是实例数据的拷贝而不是实例本身）。传入对象实例和实例的属性keypath后，就可以自动将实例捕获为weak引用，并在调用返回的闭包后更改keypath对应的属性 - 就像这样：\nfunc setter\u0026lt;Object: AnyObject, Value\u0026gt;( for object: Object, keyPath: ReferenceWritableKeyPath\u0026lt;Object, Value\u0026gt; ) -\u0026gt; (Value) -\u0026gt; Void { return { [weak object] value in object?[keyPath: keyPath] = value } } 用上面的方法，我们就可以将之前的代码简化，去掉weak self的语法，最终得到看上去更干净的代码。\nclass ListViewController { private var items = [Item]() { didSet { render() } } func loadItems() { loader.load(then: setter(for: self, keyPath: \\.items)) } } 太酷了！如果我们将它应用在进阶的功能里，比如函数组合，那就更酷了，比如我们可以将多个setter和其他函数绑定在一起。接下来我们会更深入地探讨keypath功能，函数组合将是接下来的文章话题。\n结论 一开始，可能有点难以理解如何以及何时使用swift的keypath，认为它只是简单的语法糖而已 而忽略它的真正强大之处。能更动态地引用对象的属性是一个强大的功能，尽管闭包能经常能达到相似的功能，但简单的语法和可声明性的本质让它成为处理各种各样的数据的很棒的选择。\n作为一个比较新出的功能（Swift 4 以上），我相信随着时间的推移，技术社区里会出现关于keypath的新用法和思路，因此在以后的技术文章里我们还会回顾keypath功能。到那时，我也想听听大家关于keypath的想法 - 比如你们是否真的在使用它 或是 正在尝试着使用它？\n谢谢阅读我的文章。\n"
},
{
	"uri": "https://leverkusen188.github.io/swift/swift_oc_communicate/",
	"title": "Swift 与 OC的互相使用tips",
	"tags": [],
	"description": "",
	"content": "Swift要使用OC代码 Case1 : 如果是主工程里，则需要将对应的OC头文件放入 生成的 \u0026ldquo;-Bridging-Header.h\u0026rdquo; 头文件里。 Case2: 如果是子工程，必须将OC对应的头文件设为Public；再将该头文件放入modular header里来import。 Swift使用OC的 枚举。（不同的声明方式对应不同的使用方式） **Case1: **\ntypedef enum : NSUInteger { XXXX1, } XXXX; 在swift中： let vv : XXXX = XXXX1 Case2:\ntypedef NS_ENUM(NSUInteger, JapaneseFoodType1) { JapaneseFoodType1_Sushi = 1, JapaneseFoodType1_Tempura = 2, }; 在swift中： let v : JapaneseFoodType1 = .sushi PS：也都可以用 init(rawValue:) 来使用，但不推荐。\nSwift 使用OC的指针 Swift 端的指针类型有： UnsafePointer: 类似于const Pointee * UnsafeMutablePointer: 类似于Pointee * UnsafeRawPointer: 类似于const void * UnsafeMutableRawPointer: 类似于void * //OC传指针给Swift //Swift端 @objc class SwiftClosure : NSObject { @objc class func test1(_ ptr: UnsafeMutablePointer\u0026lt;Int\u0026gt;) { ptr.pointee += 10 } } //OC端 NSInteger b = 4; [SwiftClosure test1:\u0026amp;b]; //b 为 14 //Swift传指针给OC //Swift端 var intV = 4 var intVP = withUnsafeMutablePointer(to: \u0026amp;intV) { $0 } ClassForSwift1.myPointer(intVP) //intV 为 8 //OC端 + (void)myPointer:(NSInteger *) intP { *intP += 4; } Swift的指针常用方法 //分配内存，创建指针，类型是 UnsafeMutableRawPointer let p = malloc(50) //另一个指针指向 offset 16的位置 let anotherPointer = p! + 16 //或者用 p!.advanced(by: 16) //写入数据到指定位置 p?.storeBytes(of: 55, toByteOffset: 16, as: Int.self) //获取内存制定位置的值 var p1 : Int = p!.load(fromByteOffset: 0, as: Int.self) //销毁内存 free(p) //创建 大小为3个Int的内存指针 var ptr = UnsafeMutablePointer\u0026lt;Int\u0026gt;.allocate(capacity: 3) // 先初始化内存 ptr.initialize(to: 11) // ptr.successor表示下一个Int，也就是跳一个类型字节大小 ptr.successor().initialize(to: 22) ptr.successor().successor().initialize(to: 33) print(ptr.pointee) // 11 // ptr + 1，意味着跳过一个Int类型大小的字节数 print((ptr + 1).pointee) // 22 print((ptr + 2).pointee) // 33 // 释放要调用反初始化，调用了几个就释放几个 ptr.deinitialize(count: 3) ptr.deallocate() //RawPointer 和 Pointer之间的转换 let convertedIntP : UnsafeMutablePointer\u0026lt;Int\u0026gt; = p!.assumingMemoryBound(to: Int.self) let convertedIntP2 : UnsafePointer\u0026lt;Int\u0026gt; = unsafeBitCast(p!, to: UnsafePointer\u0026lt;Int\u0026gt;.self) "
},
{
	"uri": "https://leverkusen188.github.io/swift/swift_function_closure/",
	"title": "Swift 函数和闭包",
	"tags": [],
	"description": "",
	"content": "可变参数 可以设定同类型的参数为可变个数，然后在函数里将该参数作为数组来使用。 可变参数的位置不一定是最后一个。\n示例代码：\nfunc manyVar(v : Int..., d : Double) { for i in v {\t//作为数组使用 } } manyVar( d: 2.2) //传 0 个v参数 manyVar(v:1,2,3, d: 2.2) //传3个 v参数 闭包 和 函数 对外部变量的引用 Block 和 函数在使用它们外部的变量时，使用的是该变量的引用（无论是基本类型还是 类结构），当变量变化时，block和函数内部的该变量也会一起变化。\n代码例子：\nvar bInt : Int = 4 func capture(_ num : Int) -\u0026gt; String { bInt += num return \u0026#34;caturpe \\(bInt)\u0026#34; } bInt += 1 print(\u0026#34;capture \\(capture(1))”) //打印 capture 6 print(\u0026#34;capture \\(capture(2))”) //打印 capture 7, 此时 bInt 变成7了 尾随闭包 当闭包作为函数最后一个参数时，可以将闭包体放在函数的括号外面，这是一个语法糖。\n代码例子：\nfunc someFunctionThatTakesAClosure(closure: () -\u0026gt; Void) { // 函数体部分 } someFunctionThatTakesAClosure({ //闭包体 }) someFunctionThatTakesAClosure() { //闭包体 } 闭包的缩写 在闭包体内，可以用 $0 下标来获取对应的位置的参数。 代码例子：\nlet sort : (Int, Int) -\u0026gt; Bool = { $0 \u0026gt; $1 } [1,2,3].sorted(by: sort) 重载运算符 可以改写特定类型数据（对象）的运算符行为。\n样例代码：\nclass EqualClass : Equatable { var value : Int = 2 init(v : Int) { value = v } static func == (o1 : EqualClass, o2 : EqualClass) -\u0026gt; Bool { return o1.value == o2.value } static func \u0026gt; (o1 : EqualClass, o2 : EqualClass) -\u0026gt; Bool { return o1.value \u0026gt; o2.value } } 可逃逸闭包 @escaping 逃逸闭包：闭包有可能在函数结束后调用，闭包调用逃离了函数的作用域，需要通过@escaping声明。 比如下面例子，传入的闭包用对象属性保存了下来，可能在任意时间被调用。\nclass SwiftClosure : SwiftTestProtocol { typealias emptyClosure = () -\u0026gt; () var callback :emptyClosure? = nil func setCallback(_ call : @escaping emptyClosure) { self.callback = call } func main() { self.setCallback { print(\u0026#34;my callback\u0026#34;) } } } 逃逸闭包里不能使用外面的 inout 参数。\nfunc modifyInt(_ value : inout Int) { self.setCallback { [weak self] in value += 4 //编译报错 print(\u0026#34;my callback\u0026#34;) } self.callback!() self.callback!() } "
},
{
	"uri": "https://leverkusen188.github.io/swift/swift_pattern_match/",
	"title": "Swift 字面量协议和模式匹配",
	"tags": [],
	"description": "",
	"content": "字面量协议(Literal Type) 字面量(Literal Type)就是基本类型的常量值。 比如： 10、false、\u0026ldquo;Jack\u0026quot;就是字面量\nvar age = 10 var isRed = false var name = \u0026#34;Jack\u0026#34; 而如果类实现了对应的字面量协议后，就可以用字面量来初始化对象了。 常用的字面量协议有：\nBool: ExpressibleByBooleanLiteral Int: ExpressibleByIntegerLiteral Float、Double: ExpressibleByIntegerLiteral、ExpressibleByFloatLiteral String: ExpressibleByStringLiteral Array、Set: ExpressibleByArrayLiteral Dictionary: ExpressibleByDictionaryLiteral Optional: ExpressibleByNilLiteral 样例代码：\nclass LiteralTypeClass : ExpressibleByBooleanLiteral { var boolValue : Bool //实现了bool的字面量协议，可以用bool来初始化了 required init(booleanLiteral value: BooleanLiteralType) { boolValue = value } } let obj : LiteralTypeClass = false 模式匹配 模式是用于匹配的规则，比如switch的case、捕捉错误的catch、if\\guard\\while\\for语句的条件等。\n1. 通配符模式（Wildcard Pattern） 1.1 _ 匹配任何值 1.2 _? 匹配非nil值\n样例代码：\nenum Life { case human(name: String, age: Int?) case animal(name: String, age: Int?) } func check(_ life: Life) { switch life { case .human(let name, _): //case 1 print(\u0026#34;human\u0026#34;, name) case .animal(let name, _?): //case 2 print(\u0026#34;animal\u0026#34;, name) default: //case 3 print(\u0026#34;other\u0026#34;) } } check(.human(name: \u0026#34;Rose\u0026#34;, age: 20)) // 满足case 1 check(.human(name: \u0026#34;Jack\u0026#34;, age: nil)) //满足 case 1 check(.animal(name: \u0026#34;Dog\u0026#34;, age: 5)) // 满足case 2 check(.animal(name: \u0026#34;Cat\u0026#34;, age: nil)) // 满足 case3 2. 值绑定模式（Value-Binding Pattern） let point = (3, 2) switch point { case let (x, y): print(\u0026#34;The point is at (\\(x), \\(y).\u0026#34;) } 3. 元组模式（Tuple Pattern） let name: String? = \u0026#34;jack\u0026#34; let age = 18 let info: Any = [1, 2] switch (name, age, info) { case (_?, _, _ as String): print(\u0026#34;case\u0026#34;) default: print(\u0026#34;default\u0026#34;) } // default 4. 枚举Case模式（Enumeration Case Pattern） if case语句等价于只有1个case的switch语句\nlet age = 2 // 枚举Case模式 if case 0...9 = age { print(\u0026#34;[0, 9]\u0026#34;) } let ages: [Int?] = [2, 3, nil, 5] for case nil in ages { print(\u0026#34;有nil值\u0026#34;) break } // 有nil值 let points = [(1, 0), (2, 1), (3, 0)] for case let (x, 0) in points { print(x) } // 1 3 5. 可选模式（Optional Pattern） let ages: [Int?] = [nil, 2, 3, nil, 5] for case let age? in ages { print(age) } // 2 3 5 // 同上面效果等价 let ages: [Int?] = [nil, 2, 3, nil, 5] for item in ages { if let age = item { print(age) } } 6. 类型转换模式（Type-Casting Pattern） class Animal { func eat() { print(type(of: self), \u0026#34;eat\u0026#34;) } } class Dog: Animal { } class Cat: Animal { } func check(_ animal: Animal) { switch animal { case let dog as Dog: dog.eat() dog.run() case is Cat: animal.eat() default: break } } check(Dog()) // Dog eat, Dog run check(Cat()) // Cat eat 7. 表达式模式（Expression Pattern） 表达式用在 case 中\nlet point = (1, 2) switch point { case (0, 0): print(\u0026#34;(0, 0) is at the origin.\u0026#34;) case (-2...2, -2...2): print(\u0026#34;(\\(point.0), \\(point.1) is near the origin.\u0026#34;) default: print(\u0026#34;The point is at (\\(point.0), \\(point.1).\u0026#34;) } // (1, 2) is near the origin. 自定义表达式模式 重载 ~= 运算符，可以实现 case 里的字定义条件匹配。\n下面是数值类型以及区间的自定义匹配实现。\nstruct Student { var score = 0, name = \u0026#34;\u0026#34; // pattern：放的是case后面的值 // value：放的是switch后面的值 //与Int 值的匹配判断 static func ~= (pattern: Int, value: Student) -\u0026gt; Bool { value.score \u0026gt;= pattern } //与 0…5 此类区间的匹配判断 static func ~= (pattern: ClosedRange\u0026lt;Int\u0026gt;, value: Student) -\u0026gt; Bool { pattern.contains(value.score) } //与 0..\u0026lt;5 此类区间的匹配判断 static func ~= (pattern: Range\u0026lt;Int\u0026gt;, value: Student) -\u0026gt; Bool { pattern.contains(value.score) } //与Double值的匹配判断 static func ~= (pattern: Double, value : Student) -\u0026gt; Bool { return Double(value.score) \u0026gt; pattern } } var stu = Student(score: 75, name: \u0026#34;Jack\u0026#34;) switch stu { case 61.1: print(\u0026#34;DOuble???\u0026#34;) case 100: print(\u0026#34;\u0026gt;= 100\u0026#34;) case 90: print(\u0026#34;\u0026gt;= 90\u0026#34;) case 80..\u0026lt;90: print(\u0026#34;[80, 90]\u0026#34;) case 60...79: print(\u0026#34;[60, 79]\u0026#34;) case 0: print(\u0026#34;\u0026gt;= 0\u0026#34;) default: break } // [60, 79] if case 60 = stu { print(\u0026#34;\u0026gt;= 60\u0026#34;) } // \u0026gt;= 60 打印结果是： DOuble??? \u0026gt;= 60\n下面是字符串的自定义匹配实现 extension String { static func ~= (pattern: (String) -\u0026gt; Bool, value: String) -\u0026gt; Bool { pattern(value) } } func hasPrefix(_ prefix: String) -\u0026gt; ((String) -\u0026gt; Bool) { { $0.hasPrefix(prefix) } } func hasSuffix(_ suffix: String) -\u0026gt; ((String) -\u0026gt; Bool) { { $0.hasSuffix(suffix) } } var str = \u0026#34;jack\u0026#34; switch str { //这里 hasPrefix和 hasSuffix 返回的closure 就是重载的 ~= 运算符的 pattern 参数 case hasPrefix(\u0026#34;j\u0026#34;), hasSuffix(\u0026#34;k\u0026#34;): print(\u0026#34;以j开头，以k结尾\u0026#34;) default: break } // 以j开头，以k结尾 "
},
{
	"uri": "https://leverkusen188.github.io/swiftui/swiftui_pandding/",
	"title": "Swift 常用UI界面设置",
	"tags": [],
	"description": "",
	"content": "背景色设置 一个指定颜色的空视图。 color.red.ignoresSafeArea() 给一个或多个视图指定背景颜色 Color.green.overlay { //用 overlay作为背景的 多个重叠的视图 Text(\u0026#34;hello\u0026#34;).bold().foregroundColor(.white) }.frame(width: 50, height: 50) 控件位置设置 HStack 和 VStack 初始化时都有spacing参数来设定 它们里面的控件的间距。\n控件的offset 属性可以设置该控件相比原布局位置的位移。\n但注意其他控件并不会因为它的位置变化而自动布局（也就是 如果下面的控件不设offset时，可能会跟它重叠，比如下面这样：） padding 填充设置\nfunc padding( _ edges: Edge.Set = .all, _ length: CGFloat? = nil ) -\u0026gt; some View 往指定的Edge 填充指定(Length) 大小的空间。edges 可以是多个。 样例代码：\n//往控件的底部和右边尾部 填充20像素宽度空间 Text(\u0026#34;Text padded by 20 points on the bottom and trailing edges.\u0026#34;) .padding([.bottom, .trailing], 20) .border(.gray) "
},
{
	"uri": "https://leverkusen188.github.io/swift/swift_array_dictionary/",
	"title": "Swift 数组和字典",
	"tags": [],
	"description": "",
	"content": "数组和字典的遍历(enumerated) 数组和字典的遍历有两种方式。\n方式1: let arr = [1,2,3] for v in arr.enumerated() { v.offset //就是下标序号 v.element //就是当前元素 } let dict = [1: “first”, 2: “second”] for v in dict.enumerated() { v.offset //就是序号 v.element //类型是 [Int: String].Element, 有key 和value属性； } 方式2: for (index, value) in arr.enumerated() { //index 是下标，value是元素 } for (index, value) in arr.enumerated() { //index 是下标，value是 [Int: String].Element } 用数组里的对象的属性贵族归组 快速创建字典 样例代码：\nstruct Data { var i : Int var text : String } //dic 会用 Data的 i 属性来作为key生成。 let dic = Dictionary(grouping: [ Data999(i: 1, text: \u0026#34;haha\u0026#34;), Data999(i: 1, text: \u0026#34;baa\u0026#34;), Data999(i: 4, text: \u0026#34;abnn\u0026#34;), Data999(i: 4, text: \u0026#34;erwr\u0026#34;), Data999(i: 6, text: \u0026#34;babr\u0026#34;), ], by: { $0.i }) 数组转换成字典 下面例子，将长度相同的字符串放入一个数组作为value，key为字符长度\nvar playerNames = [\u0026#34;Harry\u0026#34;, \u0026#34;Ron\u0026#34;, \u0026#34;Hermione\u0026#34;, \u0026#34;Bil\u0026#34;] //into 参数是初始化的字典。 最终返回的是另一个字典 let scoreboard = playerNames.reduce(into: [Int: [String]]()) { if $0[$1.count] == nil { $0[$1.count] = [] } $0[$1.count]?.append($1) } "
},
{
	"uri": "https://leverkusen188.github.io/swift/swift_class_structure/",
	"title": "Swift 类和结构",
	"tags": [],
	"description": "",
	"content": "结构的mutating 函数 结构体中，除了init 函数外，其他函数中如果有修改自身属性，必须声明为 mutating\nstruct s { var str : String = \u0026#34;\u0026#34; mutating func(s1 : String) { self.str = s1 } } 类方法和 Static 方法 类方法和static方法都是通过 类名(结构名) 直接调用的方法。 但 类方法可以被子类重写，而static 不行.\nclass EqualClass { class func canOverride() { print(\u0026#34;EqualClass canOverride\u0026#34;) } static func cannotOverride() { print(\u0026#34;EqualClass cannotOverride\u0026#34;) } } class SubEqualClass : EqualClass { override class func canOverride() { print(\u0026#34;SubEqualClass canOverride\u0026#34;) } //下面代码无法编译 override static func cannotOverride() { print(\u0026#34;SubEqualClass cannotOverride\u0026#34;) } } 下标脚本（subscript） 在类，结构或是枚举 声明中，可以定义下标脚本，通过一个或多个索引来访问实例里的数据。\nclass EqualClass { subscript(first : Int, second : String) -\u0026gt; String { return \u0026#34;Int=\\(first) second=\\(second)\u0026#34; } } let object = EqualClass() print(\u0026#34;subscript = \u0026#34;+object[1,\u0026#34;bb\u0026#34;]) //用两个索引参数来访问上面声明的下标脚本 实例构造相关 类和结构体在实例创建时，必须为所有存储型属性设置合适的初始值。可选类型的不用。 存储属性在构造器中赋值时，它们的值是被直接设置的，不会触发任何属性观测器（也就是didSet，willSet等）。case 1 同时，属性在声明处的初始化也是不会触发属性观测器的。 Case 2\nclass SubCls { override init(v : String) { self.sss = v + \u0026#34;sss\u0026#34; //case 1 } var sss : String? = \u0026#34;\u0026#34; { //case 2 willSet { print(\u0026#34;\\(newValue)\u0026#34;) } } } 可失败构造器 在某些自定义条件不满足时，在 可失败构造器内返回nil，表示构造失败. 你可以用一个非可失败构造器覆盖一个可失败构造器，但反过来却行不通。 一个非可失败的构造器永远也不能代理调用一个可失败构造器。\nClass Failure { init?(v : Int) { if v \u0026lt; 0 { return nil } } init(v1 : Int) { } } class SubFailure : Failure { override init?(v : Int) { super.init(v1: v) //可失败构造器 可以调用父类的 非可失败构造器 } init(v2 : Int) { //编译错误！ 非可失败构造器不能调用父类的 可失败构造器 super.init(v: v2) } } 关联类 associatedtype 用 associatedtype 关键字来设置关联类型实例。 声明的关联类型可以替代任何其他类型，类似泛型。\nprotocol Cont { associatedtype ItemType // 该协议声明关联类型，可以替代任何其他类型 mutating func append(_ item: ItemType) } extension Int : Cont { func append(_ item: Int) { //关联类型 Int print(\u0026#34;Int append\u0026#34;) } } extension Double : Cont { func append(_ item: Double) { //关联类型Double print(\u0026#34;Double append\u0026#34;) } } 类型约束 Where语句 类型约束语句可以确保 指定的类型符合 泛型或是类的定义。 可以在参数列表中定义泛型参数的约束，以保证参数类型符合你的预期。 Where 放在函数的所有参数类型最后，可以接多个约束语句，来满足自己对参数类型的需求。\n样例代码(自定义一个Stack容器类，实现一个compareStack函数，对比两个容器里元素是否完全一致)：\n//先声明协议，声明一下 compareStack 里用到的容器类的方法 protocol Cont { associatedtype ItemType var count : Int {get} // 添加一个新元素到容器里 mutating func append(_ item: ItemType) subscript(i : Int) -\u0026gt; ItemType {get} } //实现自定义Stack 容器类 class MyStack\u0026lt;Element\u0026gt; : Cont { var myItems : [Element] = [] init(v : Element...) { for value in v { myItems.append(value) } } var count: Int { get {myItems.count} } func append(_ item: Element) { myItems.append(item) } subscript(i : Int) -\u0026gt; Element { return myItems[i] } } // 扩展，将 Array 当作 Cont 来使用, 因为Array本身也实现了 Cont里声明的方法 extension Array: Cont {} //容器对比函数 func compareStack\u0026lt;C1 : Cont, C2 : Cont\u0026gt;(stack1 : C1, stack2 : C2) -\u0026gt; Bool //C1 和 C2 类型都必须实现Cont 协议 where C1.ItemType == C2.ItemType, //约束1，C1的Element和C2的必须相同 C1.ItemType : Equatable { //约束2，C1的Element 必须实现Equatable 协议 guard stack1.count == stack2.count else { return false } for i in 0..\u0026lt;stack2.count { if stack1[i] != stack2[i] { return false } } return true } let arrr1 = [1,2,3] //一个Array let stack1 = MyStack.init(v: 1,2,3) //一个MyStack容器 if compareStack(stack1: arrr1, stack2: stack1) { //对比Array和MyStack容器元素是否完全一致 print(\u0026#34;the same!\u0026#34;) //会进入这里 } "
},
{
	"uri": "https://leverkusen188.github.io/swift/swift_privilege/",
	"title": "Swift 访问控制等级",
	"tags": [],
	"description": "",
	"content": "Top open: 允许在定义实体的模块、其他模块中访问，允许其他模块进行继承、重写（open只能用在类、类成员上） public: 允许在定义实体的模块、其他模块中访问，不允许其他模块进行继承、重写 internal: 只允许在定义实体的模块中访问，不允许在其他模块中访问 fileprivate: 只允许在定义实体的源文件中访问 private： 只允许在定义实体的封闭声明中访问 绝大部分实体默认都是internal级别\n准则1: 低等级的定义不能被高等级的定义包含，并暴露出去 //fileprivate 等级的类 fileprivate class Person {} public var p : Person //❌ public class Jason : Person {} //❌ fileprivate class John : Person {} //正确 准则2: 泛型使用场景中，应该以最低访问等级的那个类型为准。 internal class Car {} fileprivate class Dog {} //最低等级 public class Person\u0026lt;T1, T2\u0026gt; {} fileprivate var p = Person\u0026lt;Car, Dog\u0026gt;() //以最低等级为准，该变量必须设定为 fileprivate 准则3: 类型的等级会影响它的函数，变量等访问等级。 fileprivate class Person { var age : Int //也是fileprivate } 准则4: 源码文件最外面的private等同于 fileprivate。 //文件最外层的 private Dog结构，等同于fileprivate等级。 private struct Dog { private var age: Int = 0 //但它的属性和函数都是 private，只能在 Dog结构声明里使用。 func run() {} //跟随 Dog的等级，都是fileprivate } fileprivate struct Person { var dog: Dog = Dog() mutating func walk() { dog.run() //可以访问 dog.age = 1 //❌编译报错，因为age 是private的 } } 准则5: 可以单独设定属性的 set 和 get的访问等级 struct Dog { fileprivate private(set) var age: Int = 0 //get是 fileprivate，set 是 private } 准则6: 不能给枚举的值单独设置访问等级 enum Weather { case winter private case spring //❌ } "
},
{
	"uri": "https://leverkusen188.github.io/swift/swift_operator_override/",
	"title": "Swift 运算符重载",
	"tags": [],
	"description": "",
	"content": "加减乘除重载 在对应的结构，类，枚举里重写即可。\nstruct Point { var x: Int, y: Int static func + (p1: Point, p2: Point) -\u0026gt; Point { Point(x: p1.x + p2.x, y: p1.y + p2.y) } } Equatable，Comparable Equatable 设定对象可以比较是否相等。重写 == 运算符。 Comparable 设定对象可以比较大小。重写 \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;= 等运算符。\n自定义运算符（Custom Operator） 可以自定义新的运算符：在全局作用域使用operator进行声明。\nprefix operator 前缀运算符 postfix operator 后缀运算符\n//前后运算符，自定义 +++ 为整型加2 prefix operator +++ postfix operator ++- prefix func +++ (_ i: inout Int) { i += 2 } postfix func ++- (_ i: inout Int) { i -= 2 } var age = 10 +++age print(age) // 12 age++- print(age) // 10 //中缀运算符，也就是放置在两个变量中间的运算符，可以定义它的运算优先级 infix operator 中缀运算符：优先级组 precedencegroup 优先级组 { associativity: 结合性（left\\right\\none） higherThan: 比谁的优先级更高 lowerThan: 比谁的优先级低 assignment: true代表在可选链操作中拥有跟赋值运算符一样的优先级 } 样例代码：\n//声明自定义的中缀运算符，名称为 PlusMinusPrecedence infix operator +-: PlusMinusPrecedence //定义该运算符的优先级 precedencegroup PlusMinusPrecedence { /*** left: 从左往右执行，可以多个进行结合 right: 从右往左执行，可以多个进行结合 none: 不支持多个结合 比如 p1 +- p2 +- p3 就会报错 */ associativity: none higherThan: AdditionPrecedence lowerThan: MultiplicationPrecedence assignment: true } struct Point { var x = 0, y = 0 //实现运算符 static func +- (p1: Point, p2: Point) -\u0026gt; Point { Point(x: p1.x + p2.x, y: p1.y - p2.y) } } print(Point(x: 10, y: 20) +- Point(x: 5, y: 10)) // Point(x: 15, y: 10) "
},
{
	"uri": "https://leverkusen188.github.io/swift/",
	"title": "Swifts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://leverkusen188.github.io/swiftui/swiftui_ui_refresh/",
	"title": "SwiftUI UI刷新细节",
	"tags": [],
	"description": "",
	"content": "SwiftUI 的View 每次刷新都会重新创建里面的View //每次text改变引起的刷新，都会重新创建一个Text @State var text : String var body : some View { Text(text) } Body 中的ForEach 重用 Body中的ForEach 每次刷新并不会重建。 因此下面的例子里，即使多次刷新View，但ForEach对象还是最初那个，循环的次数也不会随着 increasingValue 增加而改变。\nvar increasingValue : Int = 1 func testLoopCount() -\u0026gt; Int { increasingValue += 1 return increasingValue } var body : some View { let loop = testLoopCount() //每次都只循环两次，因为第一次时 loop 是2 ForEach(0..\u0026lt;loop) {_ in Text(“Text”) } } "
},
{
	"uri": "https://leverkusen188.github.io/swiftui/swiftu_uikit_merge/",
	"title": "SwiftUI 与 UIKit 混用",
	"tags": [],
	"description": "",
	"content": "UIKit 到 SwiftUI 用实现了 UIViewRepresentable 协议的 “final class” 或是 “struct”，都可以直接作为 SwiftUI里的 View 来使用。样例代码如下： UIKit 里： final class ButtonForSwiftUI : UIViewRepresentable { var btn : UIButton = UIButton(type: .system) //当SwiftUI第一次初始化 ButtonForSwiftUI时 会调用 func makeUIView(context: Context) -\u0026gt; UIButton { btn.setTitle(\u0026#34;Button1\u0026#34;, for: .normal) btn.setTitleColor(.green, for: .normal) btn.backgroundColor = .black btn.addTarget(self, action: #selector(onClick), for: .touchUpInside) return btn } //当SwiftUI 初始化或刷新view时，如果用到了ButtonForSwiftUI，就会调用 func updateUIView(_ uiView: UIButton, context: Context) { //从 context.coordinator 来访问创建的 DoWithAction 实例 } //创建一个专门处理数据的实例 func makeCoordinator() -\u0026gt; DoWithAction { DoWithAction(self) } @objc private func onClick() { print(\u0026#34;\\(self)\u0026#34;) } //声明 数据处理类 class DoWithAction { var control : ButtonForSwiftUI init(_ c : ButtonForSwiftUI) { control = c } } } SwiftUI里：\nButtonForSwiftUI().frame(width: 100, height: 50, alignment: .leading) SwiftUI 到 UIKit 使用 SwiftUI 的View来创建 UIHostingController，然后使用 UIHostingController的view属性即可。 样例代码：\nlet swiftUIVC = UIHostingController(rootView: SwiftUIView()) swiftUIVC.view.frame = CGRect(x: 50, y: 200, width: 200, height: 200) Objective-C 使用SwiftUI 由于 SwiftUI 对OC是不能直接使用的，那么需要用Swift 在中间搭桥，由Swift 创建 UIHostingController，作为UIViewController 返回给OC来使用。 样例代码：\nObjective-C\nUIViewController * vc = [SwiftUIFactory vc_swiftUI]; [self presentViewController:vc animated:YES completion:NULL]; Swift\n@objc class SwiftUIFactory : NSObject { @objc class func vc_swiftUI() -\u0026gt; UIViewController { return UIHostingController(rootView: SwiftUIView()) } } SwiftUI和OC之间可以通过传入的closure 来通讯。\n"
},
{
	"uri": "https://leverkusen188.github.io/swiftui/swiftui_common_controller/",
	"title": "SwiftUI 基础交互控件",
	"tags": [],
	"description": "",
	"content": "导航页面跳转 导航页面（NavigationView）的点击（NavigationLink）后跳转至另一个页面。\n样例代码：\n//NavigationView 的点击事件与 NavigationLink 的跳转绑定 NavigationView { //NavigationLink 的跳转目标，也是一个View. 这里是 LandmarkDetail //创建 NavigationLink 的第二个参数，closure 返回的View 就是可点击的区域 NavigationLink(destination: LandmarkDetail(landmark: landmarkData[0])) { Text(\u0026#34;hello22\u0026#34;).background(Color.red) } //在 NavigationView 里可以创建多个 NavigationLink，跳转到不同的页面 NavigationLink(destination: LandmarkDetail(landmark: landmarkData[1])) { Text(\u0026#34;hello22\u0026#34;).background(Color.red) } } PS：页面跳转区域是该NavigationView 的区域，界面里可以有多个NavigationView，分别进行跳转。 参考截图： 弹出窗口(Present) 同 presentViewController 用一个 Binding 来控制弹出时机。\n@State var showingProfile = false //当 showingProfile 为true时，触发present .sheet(isPresented: $showingProfile) { //返回 present出来的view ProfileHost() .environmentObject(self.userData) } //将 showingProfile 设为false，能dismiss对应的present view\n开关控件Toggle（UISwitch） 可以绑定一个声明为 @State 的Bool属性。\n//绑定声明为 @State的对象的一个bool属性，该bool属性需要设置为 @Pubished Toggle(isOn: $profile.isOn) { Text(\u0026#34;Is He On:\u0026#34;) //返回 左边订制的视图 } 日期选择器（DatePicker） 日期选择控件\nDatePicker( \u0026#34;Date Pick:\u0026#34;, selection: $profile.birth, in: dateRange, displayedComponents: .date) "
},
{
	"uri": "https://leverkusen188.github.io/swiftui/swiftui_property_wapper/",
	"title": "SwiftUI 常用属性包装器",
	"tags": [],
	"description": "",
	"content": "@State 可监听的基本类型 可监听的的数据属性，可以触发对应view的刷新。 用于基本数据类型，比如 Bool, Int, String\n样例代码：\n//声明 可监听的属性 @State private var showScore = true Button(“ShowOrHide”) { //修改该属性，会触发执行 使用该属性的代码 showScore = !showScore } if showScore { ScorePlate(model: model).padding(.top, 20) } @Binding 双向绑定两个属性 将一个 @State 属性绑定到一个 @Binding 属性上。 当双方发生改变时，都会改变另一个。\nstruct CategoryHome: View { @State var showingProfile = false var body: some View { List { //将 self.showingProfile 设为 true 来弹出 ProfileHost Button(\u0026#34;Change\u0026#34;) { self.showingProfile = true } } .sheet(isPresented: $showingProfile) { //将 showingProfile 绑定到 ProfileHost的 shouldHide 上，然后 ProfileHost就可以控制shouldHide来做dismiss操作了。 ProfileHost(shouldHide: $showingProfile) } } } struct ProfileHost: View { @Binding var shouldHide : Bool var body: some View { Button(\u0026#34;Close\u0026#34;) { // 绑定的showingProfile 也会改为false，将当前view 给dismiss掉 self.shouldHide = false } } } Binding 属性可以用常量来初始化 比如上面的 Binding：\nBinding.constant(false) Binding属性的初始化可以是\n@Binding(projectedValue: .constant(1)) var currentPage : Int init(currentPage : Binding\u0026lt;Int\u0026gt;) { self._currentPage = currentPage } @ObservedObject 引用可监听的对象类型 可监听指定类的所有属性变化情况 以刷新UI. 当@Published 属性变化时，存储该对象的变量声明为 @ObservedObject 时，使用到该实例对象代码会执行。 该属性可以从外部传入，或是View 对象自己创建。\n样例代码：\n//类必须实现 ObservableObject 协议 class ObserverbleModel: ObservableObject { //需要监听的属性 声明为 @Published。只有在Published 属性变化时，才会触发声明了 @ObservedObject 属性的View 的body 重绘 @Published var score: Int = 0 var bigScore : Int = 0 } struct ScoreText: View { //需要监听的数据对象，声明为 @ObservedObject @ObservedObject var model: ObserverbleModel var body: some View { if model.bigScore \u0026gt; 5 { Text(\u0026#34;Big good\u0026#34;) } else { Text(\u0026#34;Big bad\u0026#34;) } } } @StateObject 初始化并持有的可监听对象 跟ObservedObject 一样都是可监听的。 不同的是，声明StateObject的View，必须是它创建的该对象（StateObject属性是只读的），该对象生命周期跟随View\n@EnvironmentObject 无需手动传递的可监听对象 使用ObservedObject 时，需要将对象逐个传递给子View的属性。 如果使用环境对象EnvironmentObject，则只用传递一次，该View 和它下面的子View里，声明为 EnvironmentObject的对象都能被赋值。 一个View的EnvironmentObject 只能声明一个，声明多个的话，都会指向同一个对象。 EnvironmentObject只能通过 environmentObject 方法从view 外部传入。\n样例代码：\n//第一级子view struct SubEnvironmentView : View { //声明了两个，但都会指向同一个对象 @EnvironmentObject fileprivate var data : TestBigData @EnvironmentObject fileprivate var data2 : TestBigData var body: some View { VStack { Text(\u0026#34;SubEnvironmentView\u0026#34;).font(.largeTitle).foregroundColor(.red) if data.showText { Text(data2.text).foregroundColor(.red) } SubEnvironmentView2() } } } //第二级子view struct SubEnvironmentView2 : View { @EnvironmentObject fileprivate var data : TestBigData var body: some View { VStack { Text(\u0026#34;SubEnvironmentView2\u0026#34;).font(.largeTitle).foregroundColor(.blue) if data.showText { Text(data.text).foregroundColor(.blue) } } } } //顶级view struct StateObservedEnvironment: View { @StateObject fileprivate var data : TestBigData = TestBigData() @EnvironmentObject fileprivate var envData : TestBigData var body: some View { VStack { Toggle(isOn: $data.showText) { Text(\u0026#34;开关\u0026#34;) }.onChange(of: data.showText) { newValue in envData.showText = newValue } SubEnvironmentView() } } } //最外面，将环境对象传入 StateObservedEnvironment().environmentObject(TestBigData()) 代码说明：\nObservedObject 和 StateObject 可以往下穿透 给下级view去使用（比如代码里的 ScoreText） ObservedObject 和 StateObject 可以由swiftUI 外面传入。 属性变化触发 使用属性的代码块执行的时机， 是变化属性的代码作用域完毕后才触发 比如： Button(“ShowOrHide”) { //修改该属性，会触发执行 使用该属性的代码 showScore = !showScore //此时不会同步触发 监听者的代码块 print(“over”) //该作用域代码执行完毕后，才会触发监听代码 } Published 属性的变化必须在主线程，因为UI刷新会同步执行。 可监听的对象A里，如果如果要让子属性为对象 或是数组对象的变化 也被监听到的话，那么该对象得是 struct（因为Published的成员变量只有变化时，才会触发主类的监听事件， 而struct 的属性变化时，会生成新的struct实例，由此触发主类的监听事件） 比如： class TestBigData : ObservableObject { var realShow : Bool = true @Published var subData : SubTestData = SubTestData() @Published var subDataArr = [SubTestData()] } //必须是struct struct SubTestData { var subShowFlag : Bool = true } PS: 如果声明为class，当subShowFlag 变化时，实际上 TestBigData 的那两个Published 属性的值并没有变化，因此无法触发 监听事件\n"
},
{
	"uri": "https://leverkusen188.github.io/swiftui/",
	"title": "SwiftUIs",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://leverkusen188.github.io/xctest/xctest_mork/",
	"title": "XCTest Mork",
	"tags": [],
	"description": "",
	"content": "以网络请求场景为例 样例代码：\nclass NetworkManager { func loadData(from url: URL, completionHandler: @escaping (NetworkResult) -\u0026gt; Void) { let task = URLSession.shared.dataTask(with: url) { data, _, error in // Create either a .success or .failure case of a result enum let result = data.map(NetworkResult.success) ?? .failure(error) completionHandler(result) } task.resume() } } 可以由两种方法来mock数据。\n创建 使用到的类的mock子类，并重写调用路径上的相关方法，来返回mock数据 // We create a partial mock by subclassing the original class class URLSessionDataTaskMock: URLSessionDataTask { private let closure: () -\u0026gt; Void init(closure: @escaping () -\u0026gt; Void) { self.closure = closure } // We override the \u0026#39;resume\u0026#39; method and simply call our closure // instead of actually resuming any task. override func resume() { closure() } } class URLSessionMock: URLSession { typealias CompletionHandler = (Data?, URLResponse?, Error?) -\u0026gt; Void // Properties that enable us to set exactly what data or error // we want our mocked URLSession to return for any request. var data: Data? var error: Error? override func dataTask( with url: URL, completionHandler: @escaping CompletionHandler ) -\u0026gt; URLSessionDataTask { let data = self.data let error = self.error return URLSessionDataTaskMock { completionHandler(data, nil, error) } } } //调整一下NetworkManager的实现 class NetworkManager { private let session: URLSession // By using a default argument (in this case .shared) we can add dependency // injection without making our app code more complicated. init(session: URLSession = .shared) { self.session = session } func loadData(from url: URL, completionHandler: @escaping (NetworkResult) -\u0026gt; Void) { let task = session.dataTask(with: url) { data, _, error in let result = data.map(NetworkResult.success) ?? .failure(error) completionHandler(result) } task.resume() } } 将网络请求的方法包装为session的一个方法（剥离与DataTask的关系）；然后创建一个自定义的协议，该协议实现了该方法；再让URLSession类来遵循该协议，并按需求实现该方法；最后创建一个自定义mock类病遵循该协议，在该方法里返回指定的Mock数据。 //网络请求方法收敛为一个自定义方法 class NetworkManager { private let session: NetworkSession init(session: NetworkSession = URLSession.shared) { self.session = session } func loadData(from url: URL, completionHandler: @escaping (NetworkResult) -\u0026gt; Void) { session.loadData(from: url) { data, error in let result = data.map(NetworkResult.success) ?? .failure(error) completionHandler(result) } } } //创建一个自定义的协议，该协议实现了该方法 protocol NetworkSession { func loadData(from url: URL, completionHandler: @escaping (Data?, Error?) -\u0026gt; Void) } //再让URLSession类来遵循该协议，并按需求实现该方法 extension URLSession: NetworkSession { func loadData(from url: URL, completionHandler: @escaping (Data?, Error?) -\u0026gt; Void) { let task = dataTask(with: url) { (data, _, error) in completionHandler(data, error) } task.resume() } } //最后创建一个自定义mock类并遵循该协议，在该方法里返回指定的Mock数据。 class NetworkSessionMock: NetworkSession { var data: Data? var error: Error? func loadData(from url: URL, completionHandler: @escaping (Data?, Error?) -\u0026gt; Void) { completionHandler(data, error) } } "
},
{
	"uri": "https://leverkusen188.github.io/xctest/xctest_waiter/",
	"title": "XCTest 基础知识 &amp; Waiter",
	"tags": [],
	"description": "",
	"content": "基本知识 异步接口测试，可以用 XCTestExpectation。 测试性能，可用 measureBlock 接口。 关于XCTWaiter用法 简单来说就是通过delegate的方式把处理XCTExpectation的方法解耦，可以在delegate回调中处理超时，中断等异步测试用例的异常，根据实际需求，决定是否让case 通过，或是抛出一个错误。\n样例代码：\nclass WeiboModelTest : XCTestCase { var model : WeiboModel? let bag = DisposeBag() let chinaCode = \u0026#34;001\u0026#34; var waiter : XCTWaiter? override func setUpWithError() throws { self.model = WeiboModel() self.waiter = XCTWaiter(delegate: self) } func testWaiter() { let expectaton1:XCTestExpectation = expectation(description: \u0026#34;Fail1\u0026#34;) DispatchQueue.global().async { Thread.sleep(forTimeInterval: 1) expectaton1.fulfill() } expectaton1.isInverted = true waiter?.wait(for: [expectaton1], timeout: 2) } func testWaiterSuccess() { let expectaton1:XCTestExpectation = expectation(description: \u0026#34;Pass\u0026#34;) DispatchQueue.global().async { Thread.sleep(forTimeInterval: 1) expectaton1.fulfill() } waiter?.wait(for: [expectaton1], timeout: 0.5) } } 然后在delegate回调里做自定义处理 extension WeiboModelTest { override func waiter(_ waiter: XCTWaiter, didFulfillInvertedExpectation expectation: XCTestExpectation) { if (expectation.expectationDescription == \u0026#34;Fail\u0026#34;) { XCTFail(expectation.expectationDescription) } } override func waiter(_ waiter: XCTWaiter, didTimeoutWithUnfulfilledExpectations unfulfilledExpectations: [XCTestExpectation]) { if (unfulfilledExpectations[0].expectationDescription != \u0026#34;Pass\u0026#34;) { XCTFail(unfulfilledExpectations[0].expectationDescription) } } } 虽然两个case里的expectation都超时了，但 testWaiter 会失败； 而testWaiterSuccess 会成功。 "
},
{
	"uri": "https://leverkusen188.github.io/xctest/",
	"title": "XCTests",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://leverkusen188.github.io/iosrelated/%E4%B8%80%E6%AC%A1%E8%BF%98%E5%8E%9Fios-release%E5%8C%85%E7%9A%84%E5%8D%A1%E9%A1%BF%E5%A0%86%E6%A0%88%E7%9A%84%E8%AE%B0%E5%BD%95/",
	"title": "一次还原ios release包的卡顿堆栈的记录",
	"tags": [],
	"description": "",
	"content": "前提： 测试提了一个关于某个操作下会比较卡顿的问题，并上传了applog。\nlog初探 app内部工具的InnerToolBlockDetect 里记录了卡顿的情况并打印了对应的线程堆栈信息。 但由于测试用的是release包，因此堆栈里都是相应函数的位移地址，无法看出真正的卡顿代码。\nlibsystem_kernel.dylib 0x1f59140f4 mach_msg_trap + 8 libsystem_kernel.dylib 0x1f59135a0 mach_msg + 72 libdispatch.dylib 0x1f5778884 \u0026lt;redacted\u0026gt; + 500 libdispatch.dylib 0x1f5778d14 \u0026lt;redacted\u0026gt; + 52 libxpc.dylib 0x1f59d891c xpc_connection_send_message_with_reply_sync + 204 CoreMedia 0x1f93a9514 FigXPCRemoteClientSendSyncMessageCreatingReply + 36 CoreMedia 0x1f92ca884 \u0026lt;redacted\u0026gt; + 192 CoreFoundation 0x1f5d15d30 \u0026lt;redacted\u0026gt; + 192 MediaToolbox 0x1fa95459c \u0026lt;redacted\u0026gt; + 1448 MediaToolbox 0x1fa953f6c FigAssetRemoteCreateWithURL + 120 AVFoundation 0x1fbdf5bb0 \u0026lt;redacted\u0026gt; + 192 AVFoundation 0x1fbd0a874 \u0026lt;redacted\u0026gt; + 884 AVFoundation 0x1fbd033e4 \u0026lt;redacted\u0026gt; + 100 Fly-rls 0x106382da0 _ZNSt3__114__thread_proxyINS_5tupleIJNS_10unique_ptrINS_15__thread_structENS_14default_deleteIS3_EEEEZN3dji6common6WorkerC1EvEUlvE_EEEEEPvSC_ + 1355164 Fly-rls 0x106383224 _ZNSt3__114__thread_proxyINS_5tupleIJNS_10unique_ptrINS_15__thread_structENS_14default_deleteIS3_EEEEZN3dji6common6WorkerC1EvEUlvE_EEEEEPvSC_ + 1356320 Fly-rls 0x1044c5fec _mh_execute_header + 303084 Fly-rls 0x1044c5e1c _mh_execute_header + 302620 Fly-rls 0x10466c0ec _mh_execute_header + 2031852 Fly-rls 0x10466b920 _mh_execute_header + 2029856 Fly-rls 0x1044bd92c _mh_execute_header + 268588 libdispatch.dylib 0x1f57c0a38 \u0026lt;redacted\u0026gt; + 24 libdispatch.dylib 0x1f57c17d4 \u0026lt;redacted\u0026gt; + 16 libdispatch.dylib 0x1f576f008 \u0026lt;redacted\u0026gt; + 1068 CoreFoundation 0x1f5d1432c \u0026lt;redacted\u0026gt; + 12 CoreFoundation 0x1f5d0f264 \u0026lt;redacted\u0026gt; + 1924 CoreFoundation 0x1f5d0e7c0 CFRunLoopRunSpecific + 436 GraphicsServices 0x1f7f0f79c GSEventRunModal + 104 UIKitCore 0x222813c38 UIApplicationMain + 212 Fly-rls 0x10448482c _mh_execute_header + 34860 libdyld.dylib 0x1f57d28e0 \u0026lt;redacted\u0026gt; + 4 堆栈还原 手头上有对应app包的 dysm 文件，查了一下，发现可以用 xcrun 命令来还原堆栈。比如：\nxcrun atos -o Foo.app/Foo -arch arm64 -l 0xd7000 0x0033f9bb 其中 0xd7000 是app执行文件的 运行开始内存地址，0x0033f9bb 是 对应的堆栈函数地址（比如上面的0x1044bd92c） 函数地址都已知，但不像crash的 ips文件，这里并没有列出 Fly-rls 执行文件的运行起始地址。 在 crash 的ips文件里,列出了 对应执行文件的运行时内存地址区间。\nBinary Images: 0x104144000 - 0x10922bfff Fly-dbg arm64 \u0026lt;191a2e0e899a36d2affc5183f78af174\u0026gt; /var/containers/Bundle/Application/25A26AFE-CE43-4E1C-B3E0-543BA6C28ADB/Fly-dbg.app/Fly-dbg 但我发现，main函数的入口地址 就是app运行开始地址 加上一部分位移（该位移在不同的build 包里，是不一样的）。 如：\n34 Fly-dbg 0x000000010415466c 0x104144000 + 67180 于是我便去bugly上，搜索 对应release包的crash记录，看能不能找到产生卡顿的版本的app包的 main函数位移地址。 随便搜了一条crash记录，并查看这个记录的原始 堆栈地址信息，成功找到了 位移大小（就是34860）。\nFly-rls\t0x000000010252082c 0x0000000102518000 + 34860 看，跟卡顿堆栈log 的 位移是一样的。 那么用 ** 0x10448482c** 减去 34860 就是卡顿发生那次运行的app的起始内存地址了。 算出来是 0x10447c000 然后再跑xcrun 命令就可以顺利解析出卡顿堆栈了。\nxcrun atos -o /Users/spy.liu/Downloads/_GO_Lite_Develop_697.dSYM/\\ Fly-rls.app.dSYM/Contents/Resources/DWARF/\\ Fly-rls -arch arm64 -l 0x10447c000 0x1044c5e1c 把多个堆栈地址放到一个文件里，换行隔开，可以一次解析多个堆栈。\nxcrun atos -o /Users/spy.liu/Downloads/_GO_Lite_Develop_697.dSYM/\\ Fly-rls.app.dSYM/Contents/Resources/DWARF/\\ Fly-rls -arch arm64 -l 0x10447c000 -f addresss.txt "
},
{
	"uri": "https://leverkusen188.github.io/javascript/function/",
	"title": "函数相关语法注意点",
	"tags": [],
	"description": "",
	"content": "参数与返回值 1. 无return值的函数，返回 undefined\nfunction tttt() { } if (tttt() === undefined) { console.log(\u0026#39;undefined111\u0026#39;) } 2. 函数只用名字来限定唯一性\nfunction t1(p1) { console.log(\u0026#39;t1 p1=\u0026#39; + p1) } function t1(p1, p2) { console.log(\u0026#39;t1 p1=\u0026#39; + p1 + \u0026#34;p2=\u0026#34;+p2) } 前面那个t1 会被覆盖\n3. 调用函数时，参数个数不一定要一致 如果参数多了，函数会忽略 如果参数少了，默认为 undefined\n4. 函数内使用 arguments arguments 可以访问函数传入的参数，但不同于数组。可以用 length 来判断个数，以及 下标来访问\nfunction abs() { if (arguments.length === 0) { return 0; } var x = arguments[0]; return x \u0026gt;= 0 ? x : -x; } abs(); // 0 abs(10); // 10 abs(-9); // 9 5. 用rest 获取多出的参数数组，rest只能放在参数最后面声明\nfunction foo(a, b, ...rest) { console.log(\u0026#39;a = \u0026#39; + a); console.log(\u0026#39;b = \u0026#39; + b); console.log(rest); } foo(1, 2, 3, 4, 5); 结果: a = 1 b = 2 Array [ 3, 4, 5 ]\n对象内的函数的 this 问题 以下面代码为例：\nfunction getAge() { var y = new Date().getFullYear(); return y - this.birth; } var xiaoming = { name: \u0026#39;小明\u0026#39;, birth: 1990, age: getAge }; xiaoming.age(); // 32, 正常结果 getAge(); // NaN 在一个方法内部，this是一个特殊变量，它始终指向当前对象。 通过 xiaoming 这个对象调用时，this 就是该对象。 而直接调用 getAge() 时，this 就变成全局的 window了。\nvar fn = xiaoming.age; // 先拿到xiaoming的age函数 fn(); // NaN 上面的用法也是不行的，必须要指定调用哪个对象的 age 函数。\nthis指针只在age方法的函数内指向xiaoming，如果是 age 方法内的方法里，则又指向全局window了，参考下例：\nfunction getAge() { function getAgeFromBirth() { var y = new Date().getFullYear(); return y - this.birth; } return getAgeFromBirth(); } var xiaoming = { name: \u0026#39;小明\u0026#39;, birth: 1990, age: getAge }; xiaoming.age(); // NaN 因为在getAge 的 getAgeFromBirth 里，this已经不再指向调用方法的对象了。 可以如下修改：(用一个临时变量 that 来保存this指针即可)\nfunction getAge() { const that = this; function getAgeFromBirth() { var y = new Date().getFullYear(); return y - that.birth; } return getAgeFromBirth(); } 函数的另类调用方式(apply 和 call) Apply和call 能指定函数的调用对象，以让this 指针指向我们需要的对象。 以上面的 xiaoming 为例。\nlet tmpAge = xiaoming.age; tmpAge.apply(xiaoming, []) tmpAge.call(xiaoming) Apply和call 的区别在于函数参数的传递方式，apply用的是数组，而 call是依次传入\n数组的 Map 和 Reduce用法 Map 就是把数组的每个元素 用传入的函数处理后 ，将返回的新元素组成新数组。 PS: 传入的函数 只接收一个参数，且必须有返回值。 样例代码：\n[1,2,3].map(function(x) { return x + 1; }) //返回 [2,3,4] Reduce 的函数参数 接收两个参数，分别为 上次两个元素的计算结果 和下一个元素。（如果是首个元素，那参数就是第一个和第二个元素） [1,2,3].reduce((a, b) =\u0026gt; a+b) //结果是6， 也就是 (1+2) + 3 [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)\n数组的Filter 用法 Filter 传入一个三参数（element， index， array）的函数，用以决定当前index的元素是否需要保留在返回的新数组里。 样例代码：(返回奇数数组)\n[1,2,3].filter( function (ele, i, array) { return eye % 2 == 1; }); 数组的其他高阶函数 every() 方法可以判断数组的所有元素是否满足测试条件。\nvar arr = [\u0026#39;Apple\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;orange\u0026#39;]; console.log(arr.every(function (s) { return s.length \u0026gt; 0; })); // true, 因为每个元素都满足s.length\u0026gt;0 find() 方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回undefined\nfindIndex() 和find() 类似，也是查找符合条件的第一个元素，不同之处在于findIndex()会返回这个元素的索引，如果没有找到，返回-1：\n"
},
{
	"uri": "https://leverkusen188.github.io/rxswift/citydemo/",
	"title": "国家省份城市demo 笔记心得",
	"tags": [],
	"description": "",
	"content": " 将view的rx的ControlEvent 于 model的某个Subject（Observable 和 Observer的合体）绑定起来。而model的这个subject作为网络请求的发起者，包装一个Observable 给UI去订阅，并获取查询返回的数据用以更新UI model提供Observable 来给UI 更新，尽量保证 该Observable的Element 与View的Observer 或是 setter属性一致，这样就可以直接通过binding 来更新，而不用多余的代码。 禁止出现嵌套订阅代码，难以阅读以及 容易出现retain circle Demo下载地址\n"
},
{
	"uri": "https://leverkusen188.github.io/reactnative/rn_image/",
	"title": "图片组件（image）",
	"tags": [],
	"description": "",
	"content": "加载本地图片（js package里） 图片放置在 js的package里\n使用 Image 组件即可。\n\u0026lt;Image source={require(\u0026#39;./img/check.png\u0026#39;)} /\u0026gt; 也能用变量来动态加载\nconst icon = \u0026#34;small.png\u0026#34;; \u0026lt;Image source={require(\u0026#34;./\u0026#34;+icon)} /\u0026gt; 上面描述的require语法也可以用来静态地加载你项目中的声音、视频或者文档文件。\n大多数常见文件类型都支持，包括.mp3, .wav, .mp4, .mov, .htm 和 .pdf等。\n参考 https://github.com/facebook/metro/blob/main/packages/metro-config/src/defaults/defaults.js#L14-L44\n加载混合app的图片 指的是加载原生app的asset里的图片资源。\niOS \u0026lt;Image source={{ uri: \u0026#39;app_icon\u0026#39; }} style={{ width: 40, height: 40 }} /\u0026gt; android \u0026lt;Image source={{ uri: \u0026#39;asset:/app_icon.png\u0026#39; }} style={{ width: 40, height: 40 }} /\u0026gt; 注意：这些做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。\n加载网络图片 使用远程地址作为参数即可. \u0026lt;Image source={{uri: \u0026#39;https://facebook.github.io/react/logo-og.png\u0026#39;}} style={{width: 400, height: 400}} /\u0026gt; 注意：跟加载app图片一样，需要指定尺寸。\n还能直接制定请求参数\n\u0026lt;Image source={{ uri: \u0026#39;https://facebook.github.io/react/logo-og.png\u0026#39;, method: \u0026#39;POST\u0026#39;, headers: { Pragma: \u0026#39;no-cache\u0026#39; }, body: \u0026#39;Your Body goes here\u0026#39; }} style={{ width: 400, height: 400 }} /\u0026gt; 组件的背景图** 用ImageBackground 将组件包起来即可，相关属性跟 Image 一样。\n\u0026lt;ImageBackground source={uri : ‘app_icon’} style={{width: \u0026#39;100%\u0026#39;, height: \u0026#39;100%\u0026#39;}}\u0026gt; \u0026lt;Text\u0026gt;Inside\u0026lt;/Text\u0026gt; \u0026lt;/ImageBackground\u0026gt; 图片的圆角 borderTopLeftRadius borderTopRightRadius borderBottomLeftRadius borderBottomRightRadius "
},
{
	"uri": "https://leverkusen188.github.io/python/python_selenium%E7%88%AC%E8%99%AB/",
	"title": "基于Python +Selenium的爬虫详解",
	"tags": [],
	"description": "",
	"content": "背景 Selenium Selenium 是一个用于web应用程序自动化测试的工具，直接运行在浏览器当中，支持chrome、firefox等主流浏览器。可以通过代码控制与页面上元素进行交互（点击、输入等），也可以获取指定元素的内容。\n2.优劣\n劣势：\n相比于抓包→构造请求→解析返回值的爬虫，由于Selenium需要生成一个浏览器环境，所有操作（与元素交互、获取元素内容等）均需要等待页面加载完毕后才可以继续进行，所以速度相比构造请求的慢很多。\n对于为了反爬做了特殊处理的展示内容，如字体加密（参考猫眼）、图片替换数字（参考自如）等，可能取不到想要的数据。\n使用图片替换数字的自如：\n优势：\n1、不需要做复杂的抓包、构造请求、解析数据等，开发难度相对要低一些。\n2、其访问参数跟使用浏览器的正常用户一模一样，访问行为也相对更像正常用户，不容易被反爬虫策略命中。\n3、生成的浏览器环境可以自动运行 JS 文件，所以不用担心如何逆向混淆过的JS文件生成用作人机校验的参数，如马蜂窝酒店评论的人机校验参数_sn，网易云音乐评论的人机校验参数params、encSecKey。可以自行抓包查看。\n4、如果需要抓取同一个前端页面上面来自不同后端接口的信息，如OTA酒店详情页的酒店基础信息、价格、评论等，使用Selenium可以在一次请求中同时完成对三个接口的调用，相对方便。\n实现 1.环境\npython3.6 + Macos\n2.依赖包\nSelenium\n安装的时候是大写的 S ，import的时候是 小写 s。\npip install Selenium 3.浏览器驱动（webdriver）\n加载浏览器环境需要下载对应的浏览器驱动，此处选择 Chrome。\n下载地址：http://npm.taobao.org/mirrors/chromedriver/ ，\n选择合适的版本下载解压后放在随便一个位置即可。\n4.hello world\nfrom selenium import webdriver \u0026#39;\u0026#39;\u0026#39;这里填刚刚下载的驱动的路径\u0026#39;\u0026#39;\u0026#39; path = \u0026#39;/Applications/Google Chrome.app/Contents/chromedriver\u0026#39; driver = webdriver.Chrome(executable_path=path) url = \u0026#39;http://hotel.qunar.com/city/beijing_city/\u0026#39; driver.get(url) \u0026#39;\u0026#39;\u0026#39;运行上述代码，会打开一个浏览器，并且加载去哪儿的酒店列表页\u0026#39;\u0026#39;\u0026#39; 这时候可以通过webdriver自带的一些的一些方法获取元素内容或者与元素进行交互。 #返回ID = js_block_beijing_city_7810的元素信息 hotel_info = driver.find_element_by_id(\u0026#39;js_block_beijing_city_7810\u0026#39;) print(hotel_info.text) #返回 展示在列表页的酒店信息 #同理，可以find_element_by_[class_name|name] 等，均可完成查询。 也可以通过方法 find_elements查找符合某条件的一组元素，以列表的形式返回。 #当需要查询的唯一标识带有空格时，可以使用find_elements_by_css_selector，否则会报错。 hotel_list = driver.find_elements_by_css_selector(\u0026#34;[class=\u0026#39;b_result_box js_list_block b_result_commentbox\u0026#39;]\u0026#34;) print(hotel_list) #返回酒店列表的全部信息。 5.关闭图片加载\n在不需要抓取图片的情况下，可以设置不加载图片，节约时间，这样属于调整本地设置，在传参上并不会有异常。\nfrom selenium import webdriver chrome_opt = webdriver.ChromeOptions() prefs={\u0026#34;profile.managed_default_content_settings.images\u0026#34;:2} chrome_opt.add_experimental_option(\u0026#34;prefs\u0026#34;,prefs) path = \u0026#39;\u0026#39; #驱动路径 browser_noPic = webdriver.Chrome(executable_path=path,chrome_options=chrome_opt) 使用webdriver与元素进行交互 1.模拟鼠标点击 hotel_info = driver.find_element_by_id(\u0026#34;js_plugin_tag_beijing_city_7810\u0026#34;) hotel.info.click() #进入酒店详情页 2.模拟键盘输入\nhotel_search = driver.find_element_by_id(\u0026#34;jxQ\u0026#34;) hotel_search.send_keys(\u0026#34;如\u0026#34;) hotel_search.send_keys(\u0026#34;如家\u0026#34;) #由于搜索框输入的第一个字会被选中，所以需要第二次才能完整输入，当然也可以模拟按键盘的 →(右键)取消选中后再次输入。 3.模拟下拉\nwebdriver中对鼠标的操作的方法封装在ActionChains类中 ，使用前要先导入ActionChains类：\nfrom selenium.webdriver.common.action_chains import ActionChains \u0026#34;\u0026#34;\u0026#34;在页面顶部、底部个找了一个元素，并模拟鼠标从顶到底的滑动\u0026#34;\u0026#34;\u0026#34; start = driver.find_element_by_class_name(\u0026#39;e_above_header\u0026#39;) target = driver.find_element_by_class_name(\u0026#39;qn_footer\u0026#39;) ActionChains(driver).drag_and_drop(start,target).perform() 此外，webdiver还提供丰富的交互功能，比如鼠标悬停、双击、按住左键等等，此处不展开介绍。\n一个完整的模拟浏览器爬虫 from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains import time \u0026#39;\u0026#39;\u0026#39;这里填刚刚下载的驱动的路径\u0026#39;\u0026#39;\u0026#39; path = \u0026#39;/Users/./Desktop/chromedriver\u0026#39; driver = webdriver.Chrome(executable_path=path) url = \u0026#39;http://hotel.qunar.com/city/beijing_city/\u0026#39; driver.get(url) time.sleep(6) #等待页面加载完再进行后续操作 \u0026#34;\u0026#34;\u0026#34;在页面顶部、底部个找了一个元素，并模拟鼠标从顶到底的滑动\u0026#34;\u0026#34;\u0026#34; start = driver.find_element_by_class_name(\u0026#39;e_above_header\u0026#39;) target = driver.find_element_by_class_name(\u0026#39;qn_footer\u0026#39;) ActionChains(driver).drag_and_drop(start,target).perform() time.sleep(5) #等待页面加载完再进行后续操作 hotel_link_list = driver.find_elements_by_css_selector(\u0026#34;[class=\u0026#39;item_price js_hasprice\u0026#39;]\u0026#34;) print(\u0026#34;在此页面共有酒店\u0026#34;,len(hotel_link_list),\u0026#34;家\u0026#34;) windows = driver.window_handles #此处可以爬整个页面任何想要想要的元素 list_hotel_info=[] def hotel_info_clawer(): list_hotel_info.append([driver.find_element_by_class_name(\u0026#34;info\u0026#34;).text, driver.find_element_by_class_name(\u0026#34;js-room-table\u0026#34;).text, driver.find_element_by_class_name(\u0026#34;dt-module\u0026#34;).text]) for i in range(len(hotel_link_list)): hotel_link_list[i].click() driver.switch_to.window(windows[-1]) #切换到刚打开的酒店详情页 hotel_info_clawer() driver.close() #关闭已经爬完的酒店详情页 print(\u0026#34;已经抓取酒店\u0026#34;,i,\u0026#34;家\u0026#34;) #后面可以补充翻页继续抓取的部分 使用截图+OCR抓取关键数据 对于做了特殊处理的信息，如上述的猫眼电影的票房信息、自如的价格等，不适用于直接获取制定元素的信息进行抓取，可以使用截图+OCR的方式抓取此类数据。\n以自如的房租为例： from selenium import webdriver \u0026#39;\u0026#39;\u0026#39;这里填刚刚下载的驱动的路径\u0026#39;\u0026#39;\u0026#39; path = \u0026#39;/Applications/Google Chrome.app/Contents/chromedriver\u0026#39; driver = webdriver.Chrome(executable_path=path) url = \u0026#39;http://www.ziroom.com/z/vr/61715463.html\u0026#39; driver.get(url) price = diver.find_element_by_class_name(\u0026#39;room_price\u0026#39;) print(price.text)#由于自如的价格用图片做了替换，这样并不能获取到实际价格，需要获取图片再做ocr处理 \u0026#34;对指定元素部分截图再保存\u0026#34; price.screenshot(\u0026#39;/Users/./Desktop/price.png\u0026#39;) 安装ocr工具：\nTesseract是一个开源的OCR引擎，能识别100多种语言（中，英，韩，日，德，法…等等），但是Tesseract对手写的识别能力较差，仅适用于打印字体。\n//仅安装tesseract，不安装训练工具和其他语音包，需要识别中文的话得额外下载 //下载地址：https://github.com/tesseract-ocr/tessdata brew install tesseract 使用Tesseract：\ntesseract ~/price.png result //识别图片并将结果存在result里面 在python下使用Tesseract：\n首先安装依赖包：pip install pytesseract\nimport pytesseract from PIL import Image # open image image = Image.open(\u0026#39;price.png\u0026#39;) code = pytesseract.image_to_string(image) print(code) "
},
{
	"uri": "https://leverkusen188.github.io/javascript/basicgramma/",
	"title": "基本语法注意点",
	"tags": [],
	"description": "",
	"content": "数据对比 不要使用==比较，始终坚持使用 === 比较。 == 会自动转换数据类型来对比，有时候会得到奇怪的结果（当对比数据类型不同时） === 会先判断数据类型是否一致（不一致返回false），再对比数据是否相同。\nfalse == 0; // 返回 true false === 0; // 返回 false 特例：\nNaN === NaN; //返回false 必须用 isNaN(Nan) 来判断\n字符串相关 格式化多行字符串\nvar name = \u0026#39;小明\u0026#39;; var age = 20; var message = `你好, ${name}, 你今年${age}岁了!`; 字符串是不可变的 使用以下方法，都无法改变字符串\nvar s = \u0026#39;Hello, world!\u0026#39;; s[0] = \u0026#39;X\u0026#39;; //还是 Hello world s.toUpperCase() //返回大写的字符串，但 s 不变 数组相关 直接给Array的length赋一个新的值会导致Array大小的变化\nvar arr = [1, 2, 3]; arr.length = 6; //arr变为[1, 2, 3, undefined, undefined, undefined] 如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化：\nvar arr = [1, 2, 3]; arr[5] = \u0026#39;x\u0026#39;;\t// arr变为[1, 2, 3, undefined, undefined, \u0026#39;x\u0026#39;] 对象相关 简单示例： var xiaoming = { name: \u0026#39;小明\u0026#39;, birth: 1990, school: \u0026#39;No.1 Middle School\u0026#39;, height: 1.70, weight: 65, score: null }; 判断对象是否有某个属性的方法 'name' in xiaoming; // true xiaoming.hasOwnProperty('name'); //只针对 该属性属于该类，忽略父类 条件判断 var s = ‘’123 If (s.length) JavaScript把null、undefined、0、NaN和空字符串\u0026rsquo;\u0026lsquo;视为false，其他值一概视为true，因此上述代码条件判断的结果是true。\n容器相关 循环 //对象key循环遍历 var o = { name: \u0026#39;Jack\u0026#39;, age: 20, city: \u0026#39;Beijing\u0026#39; }; for (var key in o) { console.log(key); // \u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;city\u0026#39; } //数组遍历， 遍历的是数组的序号（是字符串而不是数字类型） var a = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]; for (var i in a) { console.log(i); // \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39; } //遍历元素，用of For (var item of a) { console.log(i); // ‘A’, ‘B’, ‘C’ } for \u0026hellip; of循环和for \u0026hellip; in循环有何区别 Array实际上也是个对象，元素下标就是它的key。\nvar a = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]; a.name = ‘D‘ for (var x in a) { console.log(x); // \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;name\u0026#39; } 因此用 of 来遍历，就不会有上面的问题\nfor (var x of a) { console.log(x); // \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39; 不会有 ‘D’ } //forEach 遍历方法 ar.forEach(function (e, i, ar) { //e 是元素，i是序号，ar 是原数组 console.log(`element=${e} index=${i}`) }) 局部作用域 由于JavaScript的变量作用域实际上是函数内部，在函数代码块中声明的变量，在函数体内都是可以用的\nfunction foo() { { var i = 1 } i += 100; // 仍然可以引用变量i } 使用let 即可申请一个块级作用域的变量 function foo() { { let i = 1 } i += 100; // 会报错，无该变量 } PS：常量声明 const 也有块级作用域功能\n快速结构赋值 从数组里赋值 var [x,y,z] = [‘a’, ‘b’, ‘c’] var [x, [y, z]] = [‘a’, [1,2]] var [,y,z] = [1,2,3] 从对象结构里赋值 var person = { name: \u0026#39;小明\u0026#39;, age: 20, address: { city: \u0026#39;Beijing\u0026#39;, street: \u0026#39;No.1 Road\u0026#39;, zipcode: \u0026#39;100001\u0026#39; } }; var {name, address: {city, zip=‘55’}} = person; name //小明 city //Beijing zip //应该无值的，但有默认值 ’55‘\nvar {name: realName} = person; name //undefined realName //小明\n已经声明的变量 再从对象里赋值 var name, address; {name, address} = person; //执行会报错 ({name, address} = person; ) //用小括号包起来即可 "
},
{
	"uri": "https://leverkusen188.github.io/swift/swift_property_wrappers/",
	"title": "属性包装器Property Wrappers",
	"tags": [],
	"description": "",
	"content": "代码示例：\n@propertyWrapper struct Increase\u0026lt;T\u0026gt; { var wrappedValue : T { get {return value1} set { value1 = newValue if T.self is Int.Type { print(\u0026#34;\\(T.self)\u0026#34;) } if T.self is NSObject.Type || T.self is (NSObject?).Type { print(\u0026#34;\\(T.self)\u0026#34;) } } } var projectedValue : Increase\u0026lt;T\u0026gt; {return self} private var value1 : T init(wrappedValue: T) { self.value1 = wrappedValue } public func printValue() { if let v = wrappedValue as? Int { print(\u0026#34;Increase: value=\\(v+1)\u0026#34;) } } } class SwiftTestObject : NSObject { @Increase var wrappedInt : Int = 1 @Increase(wrappedValue: nil) var wrappedObject : NSObject? func testFunc() { self.wrappedObject. //NSObject _wrappedObject //Increase\u0026lt;NSObject\u0026gt; self.$wrappedObject. //Increase\u0026lt;NSObject\u0026gt; } } @propertyWrapper 来声明，必须带 泛型定义。 必须创建 var wrappedValue ，同时重写 set get方法。 在声明对应属性包装器 属性的class里，可以用 _value 来访问 Increase 对象。用 self.value 来访问对应的 T 类型对象 可以用 @Increase var value :int = 1. 或是 @Increase(wrappedValue: 1) var value : Int. 来声明并初始化 如果外面其他地方要访问 Increase 对象，必须在 propertyWrapper 里声明一个 projectedValue 来返回self，外面即可用 object.$value 语法糖来访问。 属性包装器的限制 带有包装器的属性不能在子类中覆盖。 具有包装器的属性不能是lazy，@NSCopying，@NSManaged，weak或unowned 具有包装器的属性不能具有自定义的set或get方法。 wrappedValue，init（wrappedValue :)和projectedValue必须具有与包装类型本身相同的访问控制级别 不能在协议或扩展中声明带有包装器的属性。 参考：Swift 5 属性包装器Property Wrappers完整指南\n"
},
{
	"uri": "https://leverkusen188.github.io/reactnative/rn_layout/",
	"title": "组件布局",
	"tags": [],
	"description": "",
	"content": "Flex Direction 一种子组件的排列方式。 使用的是 flexDirection 属性，默认是 column，一共四种：\n\u0026ldquo;column\u0026rdquo;, //从上往下 \u0026ldquo;row\u0026rdquo;, //从左往右 \u0026ldquo;row-reverse\u0026rdquo;, //从右往左 \u0026ldquo;column-reverse\u0026rdquo; //从下往上 Layout Direction 另一种排列方式，使用的是 direction 属性，决定子组件靠左，还是靠右，但不会递归传递下去。\n一共两种： ltr: 从左往右 rtl: 从右往左 Justify Content 在组件的 style 中指定justifyContent可以决定其子元素沿着主轴的排列方式。\nflex-start: 子元素从开始处依次排列。 当 flexDirection 为 row时 当 flexDirection 为 row-reverse时（因为布局是从右往左的） flex-end：所有子元素靠结尾处排列 当 flexDirection 为 row时(结尾处是右边) 当 flexDirection 为 row-reverse时（因为布局是从右往左的, 所以结尾处就是最左边） center： 所有子元素按总宽度计算后，靠中间一起排列 space-between：第一个和最后一个子元素分别靠开始和结尾，其他子元素平均排列，保证子元素之间距离相同。 space-around: 第一个和最后一个子元素会跟开始和结尾 空一小段，其他子元素平均排列，子元素之间距离相同 space-evenly：所有元素之间距离 以及 首尾元素跟边缘的距离 完全一样。 Align Items 在组件的 style 中指定alignItems可以决定其子元素沿着次轴（如果主轴是row，那么次轴就是 column）的排列方式\nstretch: 将子元素往次轴方向拉伸，以填满。（要求width不能限定值; 下图里 第一二个元素限定了width:50, 第三个未限定） flex-start: 子元素靠次轴的开始方向布局。（次轴是row，开始方向就是最左边） flex-end：子元素靠次轴的结尾方向布局。 center：子元素靠次轴的中间布局。 Align Self 可以将alignSelf 给单独的子元素（可设置的值跟 alignItems 一样），那么该子元素就会遵从 alignSelf的设置而忽略父元素的alignItems。 比如下面例子，第一个元素的alignSelf 设为 stretch, 因此完全忽略了父元素的 center设置。 Flex Wrap flexWrap 决定子元素在主轴上超过父元素大小时，是否在次轴方向进行换行显示。 默认是no-wrap, 可以设置为 wrap\n下面例子里，主轴是 column，然后子元素高度为150， 父元素一列放不下两个子元素，因此往row 方向进行了换行。 "
},
{
	"uri": "https://leverkusen188.github.io/reactnative/styleandsize/",
	"title": "组件的样式和大小",
	"tags": [],
	"description": "",
	"content": "样式 订制组件的样式，用style 属性。 Style 里可以放入js的变量，也能放入多个变量的数组（以数组靠后的变量样式为最优先）\n样例代码：\nimport React from \u0026#39;react\u0026#39;; import { StyleSheet, Text, View } from \u0026#39;react-native\u0026#39;; const LotsOfStyles = () =\u0026gt; { return ( \u0026lt;View style={styles.container}\u0026gt; \u0026lt;Text style={styles.red}\u0026gt;just red\u0026lt;/Text\u0026gt; \u0026lt;Text style={styles.bigBlue}\u0026gt;just bigBlue\u0026lt;/Text\u0026gt; \u0026lt;Text style={[styles.bigBlue, styles.red]}\u0026gt;bigBlue, then red\u0026lt;/Text\u0026gt; \u0026lt;Text style={[styles.red, styles.bigBlue]}\u0026gt;red, then bigBlue\u0026lt;/Text\u0026gt; //red的color 被后面的 bigBlue的color覆盖了 \u0026lt;/View\u0026gt; ); }; const styles = StyleSheet.create({ container: { marginTop: 50, }, bigBlue: { color: \u0026#39;blue\u0026#39;, fontWeight: \u0026#39;bold\u0026#39;, fontSize: 30, }, red: { color: \u0026#39;red\u0026#39;, }, }); export default LotsOfStyles; 显示效果： 组件大小 高宽的绝对值 最简单的给组件设定尺寸的方式就是在样式中指定固定的width和height。React Native 中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点, 其实也就是系统的 UIScreen 获取到的大小。\n样例代码：\nimport React from \u0026#39;react\u0026#39;; import { View } from \u0026#39;react-native\u0026#39;; const FixedDimensionsBasics = () =\u0026gt; { return ( \u0026lt;View\u0026gt; \u0026lt;View style={{width: 50, height: 50, backgroundColor: \u0026#39;powderblue\u0026#39;}} /\u0026gt; \u0026lt;View style={{width: 100, height: 100, backgroundColor: \u0026#39;skyblue\u0026#39;}} /\u0026gt; \u0026lt;View style={{width: 150, height: 150, backgroundColor: \u0026#39;steelblue\u0026#39;}} /\u0026gt; \u0026lt;/View\u0026gt; ); }; export default FixedDimensionsBasics; 弹性（Flex）宽高 一般用 flex:1 来设定组件撑满父容器的所有空间。 如果多个组件都用了 flex:1, 则大家平分。 如果值不一样，则按值的比例来分（比如 flex:3 和 flex1, 则分为 3/4 和 1/4)\n样例代码：\nimport React from \u0026#39;react\u0026#39;; import { View } from \u0026#39;react-native\u0026#39;; const FlexDimensionsBasics = () =\u0026gt; { return ( // 试试去掉父View中的`flex: 1`。 // 则父View不再具有尺寸，因此子组件也无法再撑开。 // 然后再用`height: 300`来代替父View的`flex: 1`试试看？ \u0026lt;View style={{width: 50, height:100}}\u0026gt; \u0026lt;View style={{flex: 1, backgroundColor: \u0026#39;powderblue\u0026#39;}} /\u0026gt; \u0026lt;View style={{flex: 2, backgroundColor: \u0026#39;skyblue\u0026#39;}} /\u0026gt; \u0026lt;View style={{flex: 3, backgroundColor: \u0026#39;steelblue\u0026#39;}} /\u0026gt; \u0026lt;/View\u0026gt; ); }; export default FlexDimensionsBasics; 百分比宽高 样例代码：\nimport React from \u0026#39;react\u0026#39;; import { View } from \u0026#39;react-native\u0026#39;; const PercentageDimensionsBasics = () =\u0026gt; { // Try removing the `height: \u0026#39;100%\u0026#39;` on the parent View. // The parent will not have dimensions, so the children can\u0026#39;t expand. return ( \u0026lt;View style={{ height: \u0026#39;100%\u0026#39; }}\u0026gt; \u0026lt;View style={{ height: \u0026#39;15%\u0026#39;, backgroundColor: \u0026#39;powderblue\u0026#39; }} /\u0026gt; \u0026lt;View style={{ width: \u0026#39;66%\u0026#39;, height: \u0026#39;35%\u0026#39;, backgroundColor: \u0026#39;skyblue\u0026#39; }} /\u0026gt; \u0026lt;View style={{ width: \u0026#39;33%\u0026#39;, height: \u0026#39;50%\u0026#39;, backgroundColor: \u0026#39;steelblue\u0026#39; }} /\u0026gt; \u0026lt;/View\u0026gt; ); }; export default PercentageDimensionsBasics; "
},
{
	"uri": "https://leverkusen188.github.io/reactnative/rndebug/",
	"title": "调试debug ",
	"tags": [],
	"description": "",
	"content": "本机模拟器调试： 实际上就是在本机器上启动了一个NPM的 web服务，将对应的js文件也放进去。 模拟器app 通过 localhost 来加载所有的js文件，通过 react-native 解析成native代码，最终渲染出UI。\n连手机调试： 在本机器上启动NPM的web服务，将对应的js文件也放进去。 联机编译时，react-native-xcode.sh 脚本会生成一个 ip.txt 文件，里面是本机器的ip地址，并将该txt文件放入app的bundle里。 手机app 通过该IP 以及 NPM的web服务来加载所有JS文件。\nUI层次调试 可以使用 react-devtools。 安装方式：\nexport ELECTRON_MIRROR=\u0026#34;https://npm.taobao.org/mirrors/electron/\u0026#34; //换一下package源，避免墙问题 npm install -g react-devtools PS：如果连手机调试，需要手机和电脑在同一个网段下。\n然后用 react-devtools 启动工具即可。\n堆栈还原 npx metro-symbolicate android/app/build/generated/sourcemaps/react/release/index.android.bundle.map \u0026lt; stacktrace.txt "
},
{
	"uri": "https://leverkusen188.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://leverkusen188.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]