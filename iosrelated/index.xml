<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IOSRelateds on My New Hugo Site</title>
    <link>https://leverkusen188.github.io/iosrelated/</link>
    <description>Recent content in IOSRelateds on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 22 Sep 2022 18:11:53 +0800</lastBuildDate><atom:link href="https://leverkusen188.github.io/iosrelated/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>IOS app性能调优相关知识点</title>
      <link>https://leverkusen188.github.io/iosrelated/ios%E6%80%A7%E8%83%BD/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/iosrelated/ios%E6%80%A7%E8%83%BD/</guid>
      <description>前言 本文较长（5000字左右），建议阅读时间： 20min+
一个iOS App的稳定性，主要决定于整体的系统架构设计，同时也不可忽略编程的细节，正所谓“千里之堤，溃于蚁穴”，一旦考虑不周，看似无关紧要的代码片段可能会带来整体软件系统的崩溃。尤其因为苹果限制了热更新机制，App本身的稳定性及容错性就显的更加重要，之前可以通过发布热补丁的方式解决线上代码问题，现在就需要在提交之前对App开发周期内的各个指标进行实时监测，尽量让问题暴漏在开发阶段，然后及时修复，减少线上出问题的几率。针对一个App的开发周期，它的稳定性指标主要有以下几个环节构成，用一个脑图表示如下：
1 开发过程 开发过程中，主要是通过监控内存使用及泄露，CPU使用率，FPS，启动时间等指标，以及常见的UI的主线程监测，NSAssert断言等，最好能在Debug模式下，实时显示在界面上，针对出现的问题及早解决。
内存问题 内存问题主要包括两个部分，一个是iOS中常见循环引用导致的内存泄露 ，另外就是大量数据加载及使用导致的内存警告。
mmap 虽然苹果并没有明确每个App在运行期间可以使用的内存最大值，但是有开发者进行了实验和统计，一般在占用系统内存超过20%的时候会有内存警告，而超过50%的时候，就很容易Crash了，所以内存使用率还是尽量要少，对于数据量比较大的应用，可以采用分步加载数据的方式，或者采用mmap方式。mmap 是使用逻辑内存对磁盘文件进行映射，中间只是进行映射没有任何拷贝操作，避免了写文件的数据拷贝。 操作内存就相当于在操作文件，避免了内核空间和用户空间的频繁切换。之前在开发输入法的时候 ，词库的加载也是使用mmap方式，可以有效降低App的内存占用率，具体使用可以参考链接第一篇文章。
循环引用 循环引用是iOS开发中经常遇到的问题，尤其对于新手来说是个头疼的问题。循环引用对App有潜在的危害，会使内存消耗过高，性能变差和Crash等，iOS常见的内存主要以下三种情况：
Delegate 代理协议是一个最典型的场景，需要你使用弱引用来避免循环引用。ARC时代，需要将代理声明为weak是一个即好又安全的做法：
@property (nonatomic, weak) id &amp;lt;MyCustomDelegate&amp;gt; delegate; 复制代码 NSTimer NSTimer我们开发中会用到很多，比如下面一段代码
- (void)viewDidLoad { [super viewDidLoad]; self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(doSomeThing) userInfo:nil repeats:YES]; } - (void)doSomeThing { } - (void)dealloc { [self.timer invalidate]; self.timer = nil; } 复制代码 这是典型的循环引用，因为timer会强引用self，而self又持有了timer，所有就造成了循环引用。那有人可能会说，我使用一个weak指针，比如
__weak typeof(self) weakSelf = self; self.mytimer = [NSTimer scheduledTimerWithTimeInterval:1 target:weakSelf selector:@selector(doSomeThing) userInfo:nil repeats:YES]; 复制代码 但是其实并没有用，因为不管是weakSelf还是strongSelf，最终在NSTimer内部都会重新生成一个新的指针指向self，这是一个强引用的指针，结果就会导致循环引用。那怎么解决呢？主要有如下三种方式：</description>
    </item>
    
    <item>
      <title>iOS 与外设通信</title>
      <link>https://leverkusen188.github.io/iosrelated/ios%E4%B8%8E%E5%A4%96%E8%AE%BE%E9%80%9A%E4%BF%A1/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/iosrelated/ios%E4%B8%8E%E5%A4%96%E8%AE%BE%E9%80%9A%E4%BF%A1/</guid>
      <description>蓝牙通讯 PS： _notifyCharacteristicID，_writeCharacteristicID，_externalCharacteristicID 都是跟硬件约定好的对应权限的Characteristic特征的uuid
基本概念 Peripheral、Central：中心和外设，发起连接的是 Central，被连接的设备为 Peripheral；外设设备会不停地向外广播以寻求连接。 在Mimo里，app的角色是 Central，而相机是 Peripheral
Service: 每个service 有唯一的uuid，多个外设可以共用一个service，也就是 扫描指定的uuid的service时，会返回所有使用了该service的 外设（Peripheral） 每个service会有一个或多个 Characteristic（特征），
Characteristic：特征，也是设备之间的数据传输通道，每个特征也有唯一的标识符（uuid）。分为 write，notify， Write类型用以 往外设上发送数据。
工作流程（以Central端为例） 开始扫描使用指定 uuid service的Peripheral 外设 //创建 CBCentralManager _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:_bleWorkQueue options:options]; //扫描指定的多个uuid的service [_centralManager scanForPeripheralsWithServices:_scanServices options:options]; 扫描到Peripheral 信息后，开始连接该外设 - (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&amp;lt;NSString *, id&amp;gt; *)advertisementData RSSI:(NSNumber *)RSSI { //发现外设后，尝试连接 [[DJIBLECentralManager defautManager] connectPeripheral:aPeripheral] } 连接到外设后，在该外设上检索 指定的service，并监听相关回调 - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral { [peripheral setDelegate:self]; [peripheral discoverServices:@[_serviceUUID]]; } 检索到service以后，开始在该service上检索 Characteristic 特征。 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error { for (CBService *aService in peripheral.</description>
    </item>
    
    <item>
      <title>IOS 子工程 源码和二进制库 编译方式切换方案</title>
      <link>https://leverkusen188.github.io/iosrelated/%E6%BA%90%E7%A0%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E5%88%87%E6%8D%A2/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/iosrelated/%E6%BA%90%E7%A0%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E5%88%87%E6%8D%A2/</guid>
      <description>https://www.jianshu.com/p/a6d0f37cdc27 这个主要是用 环境变量控制 podspec 里，是使用源码还是 .a 。最终 pod install 来让主工程切换子模块的 源码和二进制编译方式。
https://juejin.im/entry/5b5308c66fb9a04f932ff87e 这个好一点，需要创建私有pod，在podspec里配置 subspec；然后通过修改 主工程podfile，指定私有pod的 subspec 来切换编译方式。
具体实施：
为需要提供切换功能的工程配好podspec，作为local pods来管理。 pod lib create &amp;ldquo;podname&amp;rdquo;
编写 该工程的 build 脚本，用以将该工程的 framework / .a 以及头文件等输出为二进制，以供切换编译用。 #!/bin/sh #要build的target名 TARGET_NAME=&amp;#39;BottomStatic&amp;#39; CONFIGURATION=&amp;#39;Debug&amp;#39; #${PROJECT_NAME} if [[ $1 ]] then TARGET_NAME=$1 fi UNIVERSAL_OUTPUT_FOLDER=&amp;#34;${SRCROOT}/${PROJECT_NAME}_Products/&amp;#34; UNIVERSAL_OUTPUT_FOLDER=&amp;#34;${TARGET_NAME}_Products/&amp;#34; BUILD_DIR=&amp;#34;Build/&amp;#34; BUILD_ROOT=&amp;#34;Output/&amp;#34; SRCROOT=&amp;#34;.&amp;#34; #创建输出目录，并删除之前的framework文件 mkdir -p &amp;#34;${UNIVERSAL_OUTPUT_FOLDER}&amp;#34; mkdir -p &amp;#34;${BUILD_DIR}&amp;#34; mkdir -p &amp;#34;${BUILD_ROOT}&amp;#34; rm -rf &amp;#34;${UNIVERSAL_OUTPUT_FOLDER}/${TARGET_NAME}.framework&amp;#34; #分别编译模拟器和真机的Framework xcodebuild -target &amp;#34;${TARGET_NAME}&amp;#34; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos BUILD_DIR=&amp;#34;${BUILD_DIR}&amp;#34; BUILD_ROOT=&amp;#34;${BUILD_ROOT}&amp;#34; clean build xcodebuild -target &amp;#34;${TARGET_NAME}&amp;#34; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphonesimulator BUILD_DIR=&amp;#34;${BUILD_DIR}&amp;#34; BUILD_ROOT=&amp;#34;${BUILD_ROOT}&amp;#34; clean build #拷贝framework到univer目录 cp -R &amp;#34;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${TARGET_NAME}.</description>
    </item>
    
    <item>
      <title>IOS 组件化-动态库实战</title>
      <link>https://leverkusen188.github.io/iosrelated/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%8A%A8%E6%80%81%E5%BA%93/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/iosrelated/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%8A%A8%E6%80%81%E5%BA%93/</guid>
      <description>起因
理论功底
动态库和静态库
介绍
静态库和动态库的区别
举个例子， iOS 项目中使用 Embeded Framework
静态库和动态库如何构建和加载
静态库和动态库依赖关系
Xcode 项目结构
iOS 依赖管理事实上的标准
解决问题
制作动态库
剖析下动态库 Framework 吧
回过头来看 Embened Framework
Why Swift does not Support Staic Libraies
CocoaPods 使用 Use_framework!
动态库 Framework 的文件结构
更愉快的导入文件
资源问题
参考
起因
去年，公司iOS端，之前由于所有的业务端代码都是混乱管理，造成开发有很多痛点无法单测，团队成员提交代码冲突机率大，CI配合效果差，功能性代码多端无法复用，单仓库代码量大，编译时间长 等等痛点，领导和组内多次沟通开始着手组件化开发，希望能改进这些开发中的痛点，成立组件化团队。
组件化的方案大同小异，基础性代码封装私有库，业务组件交互交由中间件负责，项目依赖工具用iOS项目事实上的标准CocoaPods
前期的基础性组件拆分都较为顺利，从依赖树的叶子节点开发是最合适的方案。
随着组件抽离的越来越多，私有库的依赖体系也越来越复杂，慢慢过渡到了业务组件。业务组件用了Swift的第三方组件，用了Swift库的同学都知道必须加上use_frameworks!，这个标记是说Pod管理的依赖全部编译为动态库，然后呢我们的很多组件又依赖了诸如百度地图，微信分享等静态库，于是我在执行 pod install 报了一个没有碰见过的错误。
1[!] The &amp;lsquo;Pods-LJA_Example&amp;rsquo;target has transitive dependencies that include static binaries:
这就尴尬了，于是一阵疯狂的搜索google stackoverflow等，然而并没有什么卵用，而且上面催得急，根本没时间处理这些小问题 业务重构是最主要的，以至于我们的业务组件没有做到独立仓库拆分。
直到最近终于找到了解决办法:( 主要是自己的功力不够深厚）
理论功底
动态库和静态库
介绍
首先静态库和动态库都是以二进制提供代码复用的代码库
静态库 常见的是 .</description>
    </item>
    
    <item>
      <title>SDK 开发规范 &amp; 经验总结</title>
      <link>https://leverkusen188.github.io/iosrelated/sdk%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/iosrelated/sdk%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</guid>
      <description>开发规范 1. 开发规范 API功能单一，减少类似enum的入参设计 线程处理， 如非必要不要使用应用主线程，不能长时间占用，SDK内应有一个专门线程处理SDK 相关操作 尽量减少全局回调 提供异常情况回调和输出方便接入方定位，错误回调采用code+msg组合 能不用单例的就尽量少的使用 对iOS 来说能不用xib 就不用，能不用通知就不用通知 2. 命名规范 接口名称，参数命名清晰规范，参数尽可能少，所有传入参数要做好校验，禁止使用拼音和中文 类名，全局静态变量，宏等命名尽量使用自定义前缀来保证唯一性，避免与其他模块发生命名冲突。c++ 可以使用namespace来声明类和结构的模块层级，还能避免命名冲突。 函数命名遵循共性，不要出现歧义或者违背大家的共识 所有资源命名前缀：imageName_工程命名_平台名：toast_xxxSDK_iOS 3. 日志设计 log模块相关功能可配置（比如日志开关，日志文件输出目录，日志打印接管接口） log优先级分不同级别，可控制打印log级别 4. 第三方库依赖处理原则 最小可用性原则，即用最少的代码，如无必要勿增实体； 最少依赖性原则，即用最低限度的外部依赖，如无必要勿增依赖 SDK开发中，需要尽量避免依赖第三方库以免引起不必要的冲突；如实在需要，可以以源码形式引入稳定版本，并对类，结构，全局变量等添加前缀以避免外部使用到该第三方库时产生冲突。 5. 版本管理规范 使用三位版本号，每位版本号最高三位数字如：1.0.12
版本号递增原则： 第三位：bug修复，极小的变更 第二位：一般的功能迭代 第一位：项目重构，功能变更较大，需团队共同确定 6. 打包原则 使用脚本一键打包，提升打包效率，降低手动打包带来的出错率 要提供示例工程， 示例工程必须让开发者以最低的成本运行起来，可以用来验证主要功能接口 以及 SDK的接入方式。 经验 &amp;amp; 问题总结 业务型SDK里，当业务形态发生变化后，之前的接口参数无法满足需求，该如何处理？
添加新的接口，老接口标识为 该版本弃用，在SDK迭代数个版本后删除。 如何设计log的tag，才便于跟踪某个业务场景下产生的问题？</description>
    </item>
    
    <item>
      <title>一次还原ios release包的卡顿堆栈的记录</title>
      <link>https://leverkusen188.github.io/iosrelated/%E4%B8%80%E6%AC%A1%E8%BF%98%E5%8E%9Fios-release%E5%8C%85%E7%9A%84%E5%8D%A1%E9%A1%BF%E5%A0%86%E6%A0%88%E7%9A%84%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 22 Sep 2022 18:11:53 +0800</pubDate>
      
      <guid>https://leverkusen188.github.io/iosrelated/%E4%B8%80%E6%AC%A1%E8%BF%98%E5%8E%9Fios-release%E5%8C%85%E7%9A%84%E5%8D%A1%E9%A1%BF%E5%A0%86%E6%A0%88%E7%9A%84%E8%AE%B0%E5%BD%95/</guid>
      <description>前提： 测试提了一个关于某个操作下会比较卡顿的问题，并上传了applog。
log初探 app内部工具的InnerToolBlockDetect 里记录了卡顿的情况并打印了对应的线程堆栈信息。 但由于测试用的是release包，因此堆栈里都是相应函数的位移地址，无法看出真正的卡顿代码。
libsystem_kernel.dylib 0x1f59140f4 mach_msg_trap + 8 libsystem_kernel.dylib 0x1f59135a0 mach_msg + 72 libdispatch.dylib 0x1f5778884 &amp;lt;redacted&amp;gt; + 500 libdispatch.dylib 0x1f5778d14 &amp;lt;redacted&amp;gt; + 52 libxpc.dylib 0x1f59d891c xpc_connection_send_message_with_reply_sync + 204 CoreMedia 0x1f93a9514 FigXPCRemoteClientSendSyncMessageCreatingReply + 36 CoreMedia 0x1f92ca884 &amp;lt;redacted&amp;gt; + 192 CoreFoundation 0x1f5d15d30 &amp;lt;redacted&amp;gt; + 192 MediaToolbox 0x1fa95459c &amp;lt;redacted&amp;gt; + 1448 MediaToolbox 0x1fa953f6c FigAssetRemoteCreateWithURL + 120 AVFoundation 0x1fbdf5bb0 &amp;lt;redacted&amp;gt; + 192 AVFoundation 0x1fbd0a874 &amp;lt;redacted&amp;gt; + 884 AVFoundation 0x1fbd033e4 &amp;lt;redacted&amp;gt; + 100 Fly-rls 0x106382da0 _ZNSt3__114__thread_proxyINS_5tupleIJNS_10unique_ptrINS_15__thread_structENS_14default_deleteIS3_EEEEZN3dji6common6WorkerC1EvEUlvE_EEEEEPvSC_ + 1355164 Fly-rls 0x106383224 _ZNSt3__114__thread_proxyINS_5tupleIJNS_10unique_ptrINS_15__thread_structENS_14default_deleteIS3_EEEEZN3dji6common6WorkerC1EvEUlvE_EEEEEPvSC_ + 1356320 Fly-rls 0x1044c5fec _mh_execute_header + 303084 Fly-rls 0x1044c5e1c _mh_execute_header + 302620 Fly-rls 0x10466c0ec _mh_execute_header + 2031852 Fly-rls 0x10466b920 _mh_execute_header + 2029856 Fly-rls 0x1044bd92c _mh_execute_header + 268588 libdispatch.</description>
    </item>
    
  </channel>
</rss>
